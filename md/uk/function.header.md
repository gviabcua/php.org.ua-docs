---
navigation:
  - function.header-remove.html: « headerremove
  - function.headers-list.html: headerslist »
  - index.md: PHP Manual
  - ref.network.md: Мережеві функції
title: header
---
# header

(PHP 4, PHP 5, PHP 7, PHP 8)

header — Надсилання HTTP-заголовка

### Опис

```methodsynopsis
header(string $header, bool $replace = true, int $response_code = 0): void
```

**header()** використовується для надсилання HTTPзаголовка. У [» специфікації HTTP/1.1](http://www.faqs.org/rfcs/rfc2616) є докладний опис HTTPзаголовків.

Пам'ятайте, що функція **header()** можна викликати лише якщо клієнту ще не передавалися дані. Тобто вона повинна йти першою у висновку, перед її викликом не повинно бути жодних HTML-тегів, порожніх рядків тощо. Досить часто виникає помилка, коли при читанні коду файловими функціями, як [include](function.include.md) або [require](function.require.md), у цьому коді трапляються пробіли або порожні рядки, які виводяться до дзвінка **header()**. Ті самі проблеми можуть виникати і під час використання PHP/HTML в одному файлі.

```php
<html>
<?php
/* Этот пример приведёт к ошибке. Обратите внимание
 * на тег вверху, который будет выведен до вызова header() */
header('Location: http://www.example.com/');
exit;
?>
```

### Список параметрів

`header`

Рядок заголовка.

Існує два спеціальні заголовки. Один із них починається з "`HTTP/`" (реєстр не важливий) і використовується для надсилання коду стану HTTP. Наприклад, якщо веб-сервер Apache налаштований таким чином, щоб запити до неіснуючих файлів оброблялися засобами PHP-скрипту (використовуючи директиву `ErrorDocument`), ви, напевно, захочете переконатися, що скрипт генерує правильний код стану.

```php
<?php
// Этот пример иллюстрирует особый случай "HTTP/".
// Лучшие альтернативы в типичных случаях использования включают:
// 1. header($_SERVER["SERVER_PROTOCOL"] . " 404 Not Found");
//    (чтобы переопределить сообщения о состоянии http для клиентов, которые все еще используют HTTP/1.0)
// 2. http_response_code(404); (для использования сообщения по умолчанию)
header("HTTP/1.1 404 Not Found");
?>
```

Іншим спеціальним видом заголовків є "Location:". У цьому випадку функція не тільки надсилає цей заголовок браузеру, але також повертає код стану `REDIRECT` (302), якщо раніше не було встановлено код `201` або `3xx`

```php
<?php
header("Location: http://www.example.com/"); /* Перенаправление браузера */

/* Убедиться, что код ниже не выполнится после перенаправления .*/
exit;
?>
```

`replace`

Необов'язковий параметр `replace` визначає, чи треба замінювати попередній аналогічний заголовок чи заголовок того самого типу. За замовчуванням заголовок буде замінено, але якщо передати **`false`**, можна встановити кілька однотипних заголовків. Наприклад:

```php
<?php
header('WWW-Authenticate: Negotiate');
header('WWW-Authenticate: NTLM', false);
?>
```

`response_code`

Примусово вказує код відповіді HTTP. Слід враховувати, що це буде працювати тільки якщо рядок `header` не є порожньою.

### Значення, що повертаються

Функція не повертає значення після виконання.

### Помилки

Якщо не вдалося запланувати надсилання заголовка, **header()** видає помилку рівня **`E_WARNING`**

### Приклади

**Приклад #1 Діалог завантаження**

Якщо потрібно попередити користувача про необхідність зберегти дані, що пересилаються, такі як згенерований PDF-файл, можна скористатися заголовком [» Content-Disposition](http://www.faqs.org/rfcs/rfc2183), який підставляє ім'я файлу, що рекомендується, і змушує браузер показати діалог завантаження.

```php
<?php
// Будем передавать PDF
header('Content-Type: application/pdf');

// Он будет называться downloaded.pdf
header('Content-Disposition: attachment; filename="downloaded.pdf"');

// Исходный PDF-файл original.pdf
readfile('original.pdf');
?>
```

**Приклад #2 Директиви для роботи з кешем**

PHP-скрипти часто генерують динамічний контент, який не повинен кешуватися клієнтським браузером або проміжними обробниками, на кшталт проксі-серверів. Можна примусово відключити кешування на багатьох проксі-серверах та браузерах, передавши заголовки:

```php
<?php
header("Cache-Control: no-cache, must-revalidate"); // HTTP/1.1
header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); // Дата в прошлом
?>
```

> **Зауваження**
> 
> У деяких випадках ваші сторінки не кешуватимуться браузером, навіть якщо ви не передавали ці заголовки. У браузерах є певні установки, за допомогою яких користувач може змінювати звичайний хід кешування, відключати його. Ви повинні перевизначати будь-які настройки, які можуть вплинути на кешування скрипта, надсилаючи наведені вище заголовки.
> 
> Крім того, для випадків, коли використовуються сесії, можна задати налаштування конфігурації [sessioncachelimiter()](function.session-cache-limiter.html) і `session.cache_limiter`. Ці налаштування можна використовувати для автоматичного створення заголовків керуючих кешуванням.

### Примітки

> **Зауваження**
> 
> Доступ до заголовків та їх висновок здійснюватиметься лише у випадку, якщо у SAPI є їх підтримка.

> **Зауваження**
> 
> Щоб уникнути цієї проблеми, можна буферизувати висновок скрипта. У цьому випадку всі виведені дані буферизуватимуться на сервері, поки не буде дана явна команда на пересилання даних. Керувати буферизацією можна вручну функціями [проstart()](function.ob-start.html) і [проendflush()](function.ob-end-flush.html), або поставивши директиву `output_buffering` у конфігураційному файлі php.ini, або настроївши відповідним чином конфігурацію сервера.

> **Зауваження**
> 
> Рядок заголовка стану HTTP завжди надсилатиметься клієнту першим, незалежно від того був відповідний виклик функції **header()** першим чи ні. Цей стан можна перезаписати, викликаючи **header()** з новим рядком стану у будь-який час, коли можна надсилати HTTP-заголовки.

> **Зауваження**
> 
> Специфікація HTTP/1.1 вимагає вказувати абсолютний URI як аргумент [» Location:](http://tools.ietf.org/html/rfc7231#section-7.1.2), Що включає схему, ім'я хоста та абсолютний шлях, хоча деякі клієнти здатні приймати і відносні URI. Абсолютний URI можна побудувати самостійно за допомогою [SERVER\['HTTPHOST'\]](reserved.variables.server.md) [SERVER\['PHPSELF'\]](reserved.variables.server.md) і [dirname()](function.dirname.md)
> 
> ```php
> <?php
> /* Перенаправление браузера на другую страницу в той же директории, что и
> изначально запрошенная */
> $host  = $_SERVER['HTTP_HOST'];
> $uri   = rtrim(dirname($_SERVER['PHP_SELF']), '/\\');
> $extra = 'mypage.php';
> header("Location: http://$host$uri/$extra");
> exit;
> ?>
> ```

> **Зауваження**
> 
> Ідентифікатор сесії не буде передаватися разом із заголовком Location, навіть якщо увімкнено налаштування [session.usetranssid](session.configuration.html#ini.session.use-trans-sid). Його потрібно передавати вручну, використовуючи константу **`SID`**

### Дивіться також

-   [headerssent()](function.headers-sent.html) - Перевіряє, чи були надіслані заголовки
-   [setcookie()](function.setcookie.md) - Надсилає cookie
-   [httpresponsecode()](function.http-response-code.html) - Отримує або встановлює код відповіді HTTP
-   [headerremove()](function.header-remove.html) - Видаляє раніше встановлені заголовки
-   **headerlist()**
-   Розділ документації [HTTP-автентифікації](features.http-auth.html)
