Рядки

-   [Числа з плаваючою точкою](language.types.float.md)
    
-   [Числові рядки »](language.types.numeric-strings.html)
    
-   [PHP Manual](index.md)
    
-   [Типи](language.types.md)
    
-   Рядки
    

## Рядки

Рядок (тип string) - це набір символів, де символ - це те саме, що й байт. Це означає, що PHP підтримує рівно 256 різних символів, а також те, що в PHP немає вбудованої підтримки Unicode. Дивіться також [подробности реализации строкового типа](language.types.string.html#language.types.string.details)

> **Зауваження**: У 32-бітових системах і в ранніх версіях PHP, рядки (string) не можуть бути більше 2 ГБ (2147483647 байт).

### Синтаксис

Рядок може бути визначений чотирма різними способами:

-   [одинарними лапками](language.types.string.html#language.types.string.syntax.single)
-   [подвійними лапками](language.types.string.html#language.types.string.syntax.double)
-   [heredoc-синтаксисом](language.types.string.html#language.types.string.syntax.heredoc)
-   [nowdoc-синтаксисом](language.types.string.html#language.types.string.syntax.nowdoc)

#### Одинарні лапки

Найпростіший спосіб визначити рядок - це укласти його в одинарні лапки (символ `'`

Щоб використовувати одинарну лапку всередині рядка, проекрануйте її зворотним слішем (`\`). Якщо необхідно написати сам зворотний сліш, продублюйте його (`\\`). Всі інші випадки застосування зворотного сліша будуть інтерпретовані як звичайні символи: це означає, що якщо ви спробуєте використовувати інші послідовності, що управляють, такі як `\r` або `\n`, вони будуть виведені як є замість будь-якої особливої ​​поведінки.

> **Зауваження**: На відміну від синтаксису. [подвійних лапок](language.types.string.html#language.types.string.syntax.double) і [heredoc](language.types.string.html#language.types.string.syntax.heredoc) [змінні](language.variables.md) та керуючі послідовності для спеціальних символів, укладених у одинарні лапки, *не* обробляються.

```php
<?php
echo 'это простая строка';

echo 'Также вы можете вставлять в строки
символ новой строки вот так,
это нормально';

// Выводит: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выводит: Это не будет развёрнуто: \n новая строка
echo 'Это не будет развёрнуто: \n новая строка';

// Выводит: Переменные $expand также $either не разворачиваются
echo 'Переменные $expand также $either не разворачиваются';
?>
```

#### Подвійні лапки

Якщо рядок укладено в подвійні лапки ("), PHP розпізнає наступні послідовності спеціальних символів, що управляють:

**Керуючі послідовності**

| Последовательность | Значение |
| --- | --- |
| `\n` | новий рядок (LF або 0x0A (10) в ASCII) |
| `\r` | повернення каретки (CR або 0x0D (13) до ASCII) |
| `\t` | горизонтальна табуляція (HT або 0x09 (9) ASCII) |
| `\v` | вертикальна табуляція (VT або 0x0B (11) ASCII) |
| `\e` | escape-знак (ESC або 0x1B (27) ASCII) |
| `\f` | подання сторінки (FF або 0x0C (12) до ASCII) |
| `\\` | зворотна коса риса |
| `\$` | знак долара |
| `\"` | подвійна лапка |
| `\[0-7]{1,3}` | послідовність символів, що відповідає регулярному виразу символу у восьмеричній системі числення, який мовчки переповнюється, щоб поміститися в байт (тобто "400" === "000") |
| `\x[0-9A-Fa-f]{1,2}` | послідовність символів, що відповідає регулярному виразу символу в шістнадцятковій системі числення |
| `\u{[0-9A-Fa-f]+}` | послідовність символів, що відповідає регулярному виразу символу Unicode, яка відображається в рядок у поданні UTF-8 |

Як і в рядку, укладеному в одинарні лапки, екранування будь-якого іншого символу виведе також і символ екранування.

Але найважливішою властивістю рядків у подвійних лапках є обробка змінних. Дивіться докладніше [обработку строк](language.types.string.html#language.types.string.parsing)

#### Heredoc

Третій спосіб визначення рядків - це використання heredoc-синтаксису: `<<<`. Після цього оператора необхідно вказати ідентифікатор, потім переведення рядка. Після цього йде сам рядок, а потім той самий ідентифікатор, що закриває вставку.

Ідентифікатор, що закриває, може мати відступ за допомогою пробілу або табуляції, і в цьому випадку відступ буде видалений з усіх рядків у рядку документа. До PHP 7.3.0 закриває ідентифікатор *повинен* був перебувати на початку нового рядка.

Крім того, ідентифікатор, що закриває, повинен відповідати тим же правилам іменування, що і будь-яка інша мітка в PHP: він повинен містити тільки буквено-цифрові символи і підкреслення і повинен починатися з нецифрового символу або символу підкреслення.

**Приклад #1 Базовий приклад використання Heredoc у PHP 7.3.0**

```php
<?php
// без отступов
echo <<<END
      a
     b
    c
\n
END;

// 4 отступа
echo <<<END
      a
     b
    c
    END;
```

Результат виконання цього прикладу в PHP 7.3:

```
a
     b
    c

  a
 b
c
```

Якщо ідентифікатор, що закриває, зміщений далі, ніж будь-який рядок тіла, буде викинуто [ParseError](class.parseerror.md)

**Приклад #2 Ідентифікатор, що закриває, не повинен мати відступ більше, ніж будь-який рядок тіла**

```php
<?php
echo <<<END
  a
 b
c
   END;
```

Результат виконання цього прикладу в PHP 7.3:

```
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
```

Якщо закриваючий ідентифікатор має відступ, табуляції також можуть використовуватися, однак табуляції та прогалини *не повинні* змішуватися щодо відступу закриває ідентифікатора і відступу тіла (аж до ідентифікатора, що закриває). У будь-якому з цих випадків буде викинуто [ParseError](class.parseerror.md). Ці обмеження на прогалини були включені, тому що змішування табуляції та пробілів для відступів шкідливо для аналізу.

**Приклад #3 Інший відступ для закриває ідентифікатора тіла (прогалин)**

```php
<?php
// Весь следующий код не работает.

// Другой отступ для закрывающего идентификатора (табов) тела (пробелов)
{
    echo <<<END
     a
        END;
}

// смешивание пробелов и табуляции в теле
{
    echo <<<END
        a
     END;
}

// смешивание пробелов и табуляции в закрывающем идентификаторе
{
    echo <<<END
          a
         END;
}
```

Результат виконання цього прикладу в PHP 7.3:

```
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
```

За ідентифікатором основного рядка, що закриває, не обов'язково ставити крапку з комою або новий рядок. Наприклад, починаючи з PHP 7.3.0 дозволено наступний код:

**Приклад #4 Продовження виразу після ідентифікатора, що закриває**

```php
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
```

Результат виконання цього прикладу в PHP 7.3:

```
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
```

**Увага**

Якщо ідентифікатор, що закриває, був знайдений на початку рядка, то незалежно від того, чи був він частиною іншого слова, його можна розглядати як закриваючий ідентифікатор і викинути [ParseError](class.parseerror.md)

**Приклад #5 Закриваючий ідентифікатор у тексті має тенденцію викликати ParseError**

```php
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
```

Результат виконання цього прикладу в PHP 7.3:

```
PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
```

Щоб уникнути цієї проблеми, ви можете безпечно дотримуватися простого правила: *не вибирайте ідентифікатор, що закриває, який з'являється в тілі тексту*

**Увага**

До PHP 7.3.0 дуже важливо відзначити, що рядок з ідентифікатором, що закриває, не повинен містити інших символів, за винятком точки з комою (`;`). Це означає, що ідентифікатор *не повинен вводитися з відступом* і що не може бути ніяких пробілів або знаків табуляції до або після крапки з комою. Важливо також розуміти, що першим символом перед ідентифікатором, що закриває, повинен бути символ нового рядка, визначений у вашій операційній системі. Наприклад, у UNIX системах, включаючи macOS, це `\n`. Після ідентифікатора, що закриває, також відразу повинен починатися новий рядок.

Якщо це правило порушено і закриває ідентифікатор не є "чистим", вважається, що ідентифікатор, що закриває, відсутній і PHP продовжить його пошук далі. Якщо в цьому випадку правильний ідентифікатор, що закриває, так і не буде знайдений, то це викличе помилку парсингу з номером рядка в кінці скрипта.

**Приклад #6 Приклад неправильного синтаксису до PHP 7.3.0**

```php
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
// отступ перед закрывающим идентификатором недопустим
}
?>
```

**Приклад #7 Приклад правильного синтаксису, навіть до PHP 7.3.0**

```php
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
```

Heredoc, що містить змінні, не може використовуватися для ініціалізації властивостей класу.

Heredoc-текст поводиться так само, як і рядок у подвійних лапках, при цьому їх не маючи. Це означає, що вам немає необхідності екранувати лапки в heredoc, але ви, як і раніше, можете використовувати вищезгадані керуючі послідовності. Змінні обробляються, але із застосуванням складних змінних усередині неїдоцільно бути також уважним, як і при роботі з рядками.

**Приклад #8 Приклад визначення heredoc-рядка**

```php
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строк,
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Имярек';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;
?>
```

Результат виконання цього прикладу:

```
Меня зовут "Имярек". Я печатаю Foo.
Теперь, я вывожу Bar2.
Это должно вывести заглавную букву 'A': A
```

Також можна використовувати heredoc-синтаксис для передачі даних через аргументи функції:

**Приклад #9 Приклад застосування heredoc в аргументах**

```php
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
```

Можна ініціалізувати статичні змінні та властивості/константи класу за допомогою синтаксису heredoc:

**Приклад #10 Використання heredoc для інціалізації статичних змінних**

```php
<?php
// Статические переменные
function foo()
{
    static $bar = <<<LABEL
Здесь ничего нет...
LABEL;
}

// Константы/свойства класса
class foo
{
    const BAR = <<<FOOBAR
Пример использования константы
FOOBAR;

    public $baz = <<<FOOBAR
Пример использования поля
FOOBAR;
}
?>
```

Можна також оточувати ідентифікатор Heredoc подвійними лапками:

**Приклад #11 Використання подвійних лапок у heredoc**

```php
<?php
echo <<<"FOOBAR"
Привет, мир!
FOOBAR;
?>
```

#### Nowdoc

Nowdoc - це те ж саме для рядків в одинарних лапках, що й тутеред для рядків у подвійних лапках. Nowdoc схожий на heredoc, але всередині нього *не здійснюється жодних підстановок*. Ця конструкція ідеальна для використання PHP-коду або інших великих блоків тексту без необхідності його екранування. У цьому він трохи схожий на SGML-конструкцію `<![CDATA[ ]]>` тим, що повідомляє блок тексту, не призначений для обробки.

Nowdoc вказується тією ж послідовністю `<<<`, що використовується в heredoc, але наступний за нею ідентифікатор полягає в одинарних лапках, наприклад, `<<<'EOT'`. Всі умови, що діють для ідентифікаторів heredoc також дійсні і для nowdoc, особливо ті, що відносяться до ідентифікатора, що закриває.

**Приклад #12 Приклад використання nowdoc**

```php
<?php
echo <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc. Обратные слеши всегда обрабатываются буквально,
например, \\ и \'.
EOD;
```

Результат виконання цього прикладу:

```
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc. Обратные слеши всегда обрабатываются буквально,
например, \\ и \'.
```

**Приклад #13 Nowdoc приклад цитування рядка зі змінними**

```php
<?php
/* Более сложный пример с переменными. */
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Имярек';

echo <<<'EOT'
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41
EOT;
?>
```

Результат виконання цього прикладу:

```
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41
```

**Приклад #14 Приклад використання статичних даних**

```php
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
```

#### Обробка змінних

Якщо рядок вказується в подвійних лапках, або за допомогою heredoc, [змінні](language.variables.md) усередині неї обробляються.

Існує два типи синтаксису: [простий](language.types.string.html#language.types.string.parsing.simple) і [складний](language.types.string.html#language.types.string.parsing.complex). Простий синтаксис більш легкий та зручний. Він дає можливість обробки змінної значення масиву (array) або властивості об'єкта (object) з мінімумом зусиль.

Складний синтаксис може бути визначений за фігурними дужками, що оточують вираз.

##### Простий синтаксис

Якщо інтерпретатор зустрічає знак долара (`$`), він захоплює так багато символів, скільки можливо, щоб сформувати правильне ім'я змінної. Якщо ви хочете точно визначити кінець імені, укладайте ім'я змінної у фігурні дужки.

```php
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;

// Некорректно. 's' - верный символ для имени переменной, но переменная имеет имя $juice.
echo "He drank some juice made of $juices.";

// Корректно. Строго указан конец имени переменной с помощью скобок:
echo "He drank some juice made of ${juice}s.";
?>
```

Результат виконання цього прикладу:

```
He drank some apple juice.
He drank some juice made of .
He drank some juice made of apples.
```

Аналогічно можуть бути оброблені елемент масиву (array) чи властивість об'єкта (object). В індексах масиву квадратна дужка, що закриває (`]`) позначає кінець визначення індексу. Для властивостей об'єкта застосовуються самі правила, як і простих змінних.

**Приклад #15 Приклад простого синтаксису**

```php
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";

    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Не сработает
?>
```

Результат виконання цього прикладу:

```
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
```

У PHP 7.1.0 додано підтримку *негативних* числових індексів

**Приклад #16 Негативні числові індекси**

```php
<?php
$string = 'string';
echo "Символ с индексом -2 равен $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Изменение символа на позиции -3 на 'o' даёт следующую строку: $string.", PHP_EOL;
?>
```

Результат виконання цього прикладу:

```
Символ с индексом -2 равен n.
Изменение символа на позиции -3 на 'o' даёт следующую строку: strong
```

Для чогось складнішого, використовуйте складний синтаксис.

##### Складний (фігурний) синтаксис

Він називається складним не тому, що важкий у розумінні, а тому, що дозволяє використовувати складні висловлювання.

Будь-яка скалярна змінна, елемент масиву або властивість об'єкта, що відображається в рядок, може бути представлена ​​цим синтаксисом. Вираз записується так само, як і поза рядком, а потім полягає в `{` і `}`. Оскільки `{` не може бути екранований, цей синтаксис буде розпізнаватись тільки коли `$` слід безпосередньо за `{`. Використовуйте `{\$`, щоб надрукувати `{$`. Декілька прикладів, що пояснюють:

```php
<?php
// Показываем все ошибки
error_reporting(E_ALL);

$great = 'здорово';

// Не работает, выводит: Это { здорово}
echo "Это { $great}";

// Работает, выводит: Это здорово
echo "Это {$great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает, ключи, заключённые в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Работает
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределённая константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает. При использовании многомерных Масивов внутри
// строк всегда используйте фигурные скобки
echo "Это работает: {$arr['foo'][3]}";

// Работает.
echo "Это работает: " . $arr['foo'][3];

echo "Это тоже работает: {$obj->values[3]->name}";

echo "Это значение переменной по имени $name: {${$name}}";

echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";

// Не работает, выводит: C:\folder\{fantastic}.txt
echo "C:\folder\{$great}.txt"

// Работает, выводит: C:\folder\fantastic.txt
echo "C:\\folder\\{$great}.txt"
?>
```

За допомогою цього синтаксису також доступ до властивостей об'єкта всередині рядків.

```php
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->{$baz[1]}}\n";
?>
```

Результат виконання цього прикладу:

```
I am bar.
I am bar.
```

> **Зауваження**
> 
> Значення, до якого здійснюється доступ із функцій, викликів методів, статичних змінних класу та констант класу всередині `{$}`, інтерпретуватиметься як ім'я змінної в області, в якій визначено рядок. Використання одинарних фігурних дужок (`{}`) не працюватиме для доступу до значень функцій, методів, констант класів або статичних змінних класу.

```php
<?php
// Показываем все ошибки
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Это работает, выводит: Я бы хотел A & W
echo "Я бы хотел {${beers::softdrink}}\n";

// Это тоже работает, выводит: Я бы хотел Alexander Keith's
echo "Я бы хотел {${beers::$ale}}\n";
?>
```

#### Доступ до символу в рядку та його зміна

Символи в рядках можна використовувати і модифікувати, визначивши їхнє зміщення щодо початку рядка, починаючи з нуля, у квадратних дужках після рядка, наприклад $str. Думайте про рядок для цієї мети, як про масив символів. Якщо потрібно отримати або замінити більше 1 символу, можна використовувати функції [substr()](function.substr.md) і [substrreplace()](function.substr-replace.html)

> **Зауваження**: Починаючи з PHP 7.1.0, підтримуються негативні значення усунення. Вони задають зміщення з кінця рядка. Раніше негативні усунення викликали помилку рівня **`E_NOTICE`** під час читання (повертаючи порожній рядок) або **`E_WARNING`** під час запису (залишаючи рядок без змін).

> **Зауваження**: До PHP 8.0.0 для доступу до символу в рядку (string) також можна було використовувати фігурні дужки, наприклад $str{42}, для тієї ж мети. Синтаксис фігурних дужок застарів у PHP 7.4.0 і більше не підтримується у PHP 8.0.0.

**Увага**

Спроба запису у зміщення за межами рядка доповнить рядок пробілами до цього усунення. Нецілі типи буде перетворено на цілі. Неправильний тип зміщення викликає помилку рівня **`E_WARNING`**. Використовується лише перший символ рядка. Починаючи з PHP 7.1.0, присвоєння порожнього рядка викликає фатальну помилку. Раніше в такому разі присвоювався нульовий байт (Null).

**Увага**

Рядки в PHP внутрішньо являють собою масиви байт. Як результат, доступ або зміна рядка зі зміщення небезпечно з точки зору багатобайтного кодування, і має виконуватися тільки з рядками в однобайтних кодуваннях, таких як, наприклад, ISO-8859-1.

> **Зауваження**: Починаючи з PHP 7.1.0, використання порожнього індексу викликає фатальну помилку, раніше в подібному випадку рядок перетворювався на масив без попередження.

**Приклад #17 Кілька прикладів рядків**

```php
<?php
// Получение первого символа строки
$str = 'This is a test.';
$first = $str[0];

// Получение третьего символа строки
$third = $str[2];

// Получение последнего символа строки
$str = 'This is still a test.';
$last = $str[strlen($str)-1];

// Изменение последнего символа строки
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
```

Зміщення у рядку має задаватися або цілим числом, або рядком, що містить цифри, інакше видаватиметься попередження.

**Приклад #18 Приклад неприпустимого усунення рядка**

```php
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
```

Результат виконання цього прикладу:

```
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
```

> **Зауваження**
> 
> Спроба доступу до змінних інших типів (за винятком масивів або об'єктів, що реалізують певні інтерфейси) за допомогою `[]` або `{}` мовчки поверне **`null`**

> **Зауваження**
> 
> Доступ до символів у рядкових літералах можна отримати за допомогою синтаксису `[]` або `{}`

> **Зауваження**
> 
> Доступ до символів у рядкових літералах із використанням синтаксису `{}` оголошено застарілим у PHP 7.4. Функціонал вилучений у PHP 8.0.

### Корисні функції та оператори

Рядки можуть бути об'єднані за допомогою оператора '.' (крапка). Зверніть увагу, оператор додавання '+' *тут не працює*. Додаткову інформацію дивіться у розділі [Рядкові оператори](language.operators.string.md)

Для модифікації рядків існує багато корисних функцій.

Основні функції описані у розділі [рядкових функцій](ref.strings.md), а для розширеного пошуку та заміни - функції [Perl-сумісних регулярних виразів](ref.pcre.md)

Також існують [функції для роботи з URL](ref.url.md), та функції шифрування/дешифрування рядків ([Sodium](ref.sodium.md) і [Hash](ref.hash.md)

Зрештою, дивіться також [функції символьних типів](ref.ctype.md)

### Перетворення на рядок

Значення може бути перетворене на рядок за допомогою приведення `(string)`, або функції [strval()](function.strval.md). У виразах, де потрібний рядок, перетворення відбувається автоматично. Це відбувається, коли ви використовуєте функції [echo](function.echo.md) або [print](function.print.md)або коли значення змінної порівнюється з рядком. Прочитання розділів керівництва [Типи](language.types.md) і [Маніпуляції з типами](language.types.type-juggling.html) зробить наступне зрозумілішим. Дивіться також [settype()](function.settype.md)

Значення bool **`true`** перетворюється на рядок `"1"`, а значення **`false`** перетворюється на `""` (Порожній рядок). Це дозволяє перетворювати значення в обидві сторони - з бульова типу в рядковий і навпаки.

Ціле (int) чи число з плаваючою точкою (float) перетворюється на рядок, представлений числом, що з його цифр (включаючи показник ступеня чисел з плаваючою точкою). Числа з плаваючою точкою можуть бути перетворені за допомогою експоненційного подання (`4.1E+6`

> **Зауваження**
> 
> Починаючи з PHP 8.0.0, символом десяткової точки завжди є `.`. До PHP 8.0.0 символ десяткової точки визначався у локалі скрипта (категорія LCNUMERIC). Дивіться функцію [setlocale()](function.setlocale.md)

Масиви завжди перетворюються на рядок `"Array"`, так що ви не можете відобразити вміст масиву (array), використовуючи [echo](function.echo.md) або [print](function.print.md), щоб дізнатися, що він містить. Щоб переглянути окремий елемент, використовуйте щось на зразок `echo $arr['foo']`. Нижче наведено поради про те, як відобразити/переглянути весь вміст.

Для перетворення змінної типу `"Object"` у тип string використовується магічний метод [function toString() { \[native code\] }](language.oop5.magic.md)

Тип ресурс (resource) завжди перетворюється на рядок (string) виду `"Resource id #1"`, де `1` є номером ресурсу прив'язаного до ресурсу під час виконання. І хоча не варто точно покладатися на цей рядок, який може бути змінений у майбутньому, він завжди буде унікальним для поточного запуску скрипта (тобто веб-запиту або CLI-процесу) і не може використовуватися повторно для іншого ресурсу. Якщо ви бажаєте отримати тип ресурсу, використовуйте [getresourcetype()](function.get-resource-type.html)

Значення **`null`** завжди перетворюється на порожній рядок.

Як ви могли бачити вище, пряме перетворення в рядок масивів, об'єктів або ресурсів не дає жодної корисної інформації про значення, крім їх типів. Найкращий спосіб виведення значень для налагодження - використовувати функції [printr()](function.print-r.html) і [vardump()](function.var-dump.html)

Більшість значень у PHP може бути перетворена на рядок для постійного зберігання. Цей метод називається серіалізацією і може бути виконаний за допомогою функції [serialize()](function.serialize.md)

### Подробиці реалізації рядкового типу

Рядковий тип (string) у PHP реалізований у вигляді масиву байт і цілого числа, що містить довжину буфера. Він містить ніякої інформації про спосіб перетворення цих байт на символи, надаючи це завдання програмісту. Немає жодних обмежень на вміст рядка, наприклад, байт зі значенням `0` ("NUL"-байт) може розташовуватися будь-де (проте, варто враховувати, що деякі функції, як сказано в цьому посібнику, не є "бінарно-безпечними", тобто вони можуть передавати рядки бібліотекам, які ігнорують дані після NUL -Байт).

Дана природа рядкового типу пояснює чому PHP немає окремого типу "byte" - рядки грають цю роль. Функції, що повертають нетекстові дані - наприклад, довільний потік даних, що зчитується з мережевого сокету - повертають рядки.

Зважаючи на те, що PHP не диктує певне кодування для рядків, можна поставити запитання, як у такому випадку кодуються рядкові літерали. Наприклад, рядок `"á"` еквівалентна `"\xE1"` (ІSO-8859-1), `"\xC3\xA1"` (UTF-8, форма нормалізації C), `"\x61\xCC\x81"` (UTF-8, форма нормалізації D) чи будь-якому іншому можливому уявленню? Відповіддю є таке: рядок буде закодований тим чином, яким він записаний у файлі скрипта. Таким чином, якщо скрипт записаний у кодуванні ISO-8859-1, то рядок буде закодовано в ISO-8859-1 і т.д. Однак, це правило не застосовується при включеному режимі Zend Multibyte: у цьому випадку скрипт може бути записаний у будь-якому кодуванні (яке вказується ясно або визначається автоматично), а потім конвертуються у певне внутрішнє кодування, яке і буде згодом використано для рядкових літералів. Врахуйте, що на кодування скрипта (або на внутрішнє кодування, якщо включений режим Zend Multibyte) накладаються деякі обмеження: практично завжди це кодування має бути надмножиною ASCII, наприклад, UTF-8 або ISO-8859-1. Врахуйте також, що кодування, що залежать від стану, де ті самі значення байт можуть бути використані в початковому і не початковому стані зсуву, можуть викликати проблеми.

Зрозуміло, щоб приносити користь, рядкові функції повинні зробити деякі припущення кодування рядка. На жаль, серед PHP-функцій досить велика різноманітність підходів до цього питання:

-   Деякі функції передбачають, що рядок закодований в будь-якому однобайтовому кодуванні, однак для коректної роботи їм не потрібно інтерпретувати байти як певні символи. Під цю категорію підпадають, наприклад, [substr()](function.substr.md) [strpos()](function.strpos.md) [strlen()](function.strlen.md) і [strcmp()](function.strcmp.md). Інший спосіб мислення про ці функції є оперування буферами пам'яті, тобто. вони працюють безпосередньо з байтами та їх зміщеннями.
-   Інші функції очікують передачі кодування у вигляді параметра, можливо, припускаючи деяке кодування за замовчуванням, якщо параметр з кодуванням не було вказано. Такою функцією є [htmlentities()](function.htmlentities.md) і більшість функцій із модуля [mbstring](book.mbstring.md)
-   Інші функції використовують поточні установки локалі (див. [setlocale()](function.setlocale.md)), але оперують побайтово). До цієї категорії потрапляють [strcasecmp()](function.strcasecmp.md) [strtoupper()](function.strtoupper.md) і [ucfirst()](function.ucfirst.md). Це означає, що вони можуть бути використані тільки з однобайтовими кодуваннями, якщо кодування збігається з локаллю. Наприклад, `strtoupper("á")` може повернути `"Á"`, якщо локаль встановлена ​​коректно та літера `á` закодована у вигляді одного байта. Якщо вона закодована в UTF-8, буде повернено некоректний результат, і, залежно від поточної локалі, результуючий рядок може (або не бути) зіпсований.
-   Нарешті, є функції, що передбачають, що рядок використовує певне кодування, зазвичай UTF-8. Сюди потрапляють більшість функцій із модулів [intl](book.intl.md) і [PCRE](book.pcre.md) (В останньому випадку, тільки при вказівці модифікатора `u`). Хоча це і зроблено спеціально, функція [utf8decode()](function.utf8-decode.html) передбачає кодування UTF-8, а [utf8encode()](function.utf8-encode.html) – ISO-8859-1.

В кінцевому рахунку, написання коректних програм, що працюють з Unicode, означає обережне уникнення функцій, які не працюють з Unicode і, швидше за все, зіпсують дані, і використання замість них коректних функцій, зазвичай з модулів [intl](book.intl.md) і [mbstring](book.mbstring.md). Однак, використання функцій, здатних працювати з Unicode, є початком. Незалежно від функцій, які надає мову, необхідно знати специфікацію самого Unicode. Наприклад, якщо програма передбачає існування у мові лише малих і великих букв, вона робить велику помилку.