---
navigation:
  - function.stream-resolve-include-path.html: « streamresolveincludepath
  - function.stream-set-blocking.html: streamsetblocking »
  - index.html: PHP Manual
  - ref.stream.html: Функції для роботи з потоками
title: streamselect
---
# streamselect

(PHP 4> = 4.3.0, PHP 5, PHP 7, PHP 8)

streamselect — Запускає еквівалент системного виклику select() на заданих масивах потоків з часом очікування, вказаним параметрами seconds та microseconds

### Опис

```methodsynopsis
stream_select(    ?array &$read,    ?array &$write,    ?array &$except,    ?int $seconds,    ?int $microseconds = null): int|false
```

Функція **streamselect()** отримує масиви потоків і чекає зміни їхнього статусу. Її робота еквівалентна роботі функції [socketselect()](function.socket-select.html), За винятком того, що вона працює з потоками.

### Список параметрів

`read`

Потоки, перелічені у масиві `read` будуть відстежуватися на предмет появи символів, доступних для читання (точніше, щоб переконатися, що читання не блокуватиметься - зокрема потоковий ресурс також готовий для читання в кінці файлу, але в цьому випадку функція [fread()](function.fread.html) повертатиме рядок нульової довжини).

`write`

Потоки, перелічені у масиві `write`, будуть відстежуватися щодо того, що запис у них не буде блокуватися.

`except`

Потоки, перелічені у масиві `except`, будуть відстежуватися щодо надходження високопріоритетних виняткових (позасмугових або "out-of-band") даних.

> **Зауваження**
> 
> Коли **streamselect()** повертається, масиви `read` `write` і `except` змінюються для того, щоб вказати, які потокові ресурси насправді змінили статус. Вихідні ключі масивів зберігаються.

`seconds`

Параметри `seconds` і `microseconds` разом формують параметр *timeout* `seconds` вказує кількість секунд, а `microseconds` - Число мікросекунд. Параметр `timeout` - це верхня межа часу, яка функція **streamselect()** чекатиме до повернення. Якщо параметри `seconds` і `microseconds` обидва встановлені в `0`, то функція **streamselect()** не чекатиме даних - натомість вона повернеться негайно, вказуючи поточний статус потоків.

Якщо параметр `seconds` дорівнює **`null`**, то функція **streamselect()** може виконуватися невизначений час, повертаючись тільки тоді, коли відбувається подія на одному з потоків, що відстежуються (або якщо системний виклик переривається сигналом).

**Увага**

Використання значення часу очікування `0` дозволяє вам миттєво опитати статус потоків, однак погана ідея використовувати значення часу очікування `0` у циклі, оскільки це змусить ваш скрипт споживати занадто багато процесорного часу.

Набагато краще вказати значення часу очікування в кілька секунд, хоча якщо вам потрібно перевіряти та одночасно запускати інший код, використання часу очікування як мінімум `200000` мікросекунд допоможе зменшити використання процесорного часу вашим скриптом.

Запам'ятайте, що значення часу очікування – це максимальний час, який буде витрачено. Функція **streamselect()** повернеться, як тільки запитані потоки будуть готові до використання.

`microseconds`

Дивіться опис параметра `seconds`

### Значення, що повертаються

У разі успішного виконання функція **streamselect()** повертає кількість потокових ресурсів, що міститься в змінених масивах, яка може дорівнювати нулю, якщо перевищено час очікування до того, як сталося щось цікаве. У разі виникнення помилки повертається **`false`** і виникає попередження (це може статися, якщо системний виклик переривається вхідним сигналом).

### список змін

| Версия | Описание |
| --- | --- |
|  | Параметр `microseconds` тепер припускає значення **`null`** |

### Приклади

**Приклад #1 Приклад використання **streamselect()****

Цей приклад перевіряє, що отримано дані для читання на потоках `$stream1` або `$stream2`. Оскільки значення часу очікування дорівнює `0`, функція повернеться негайно:

```php
<?php
/* Подготовить Масив для чтения */
$read   = array($stream1, $stream2);
$write  = NULL;
$except = NULL;
if (false === ($num_changed_streams = stream_select($read, $write, $except, 0))) {
    /* Обработка ошибок */
} elseif ($num_changed_streams > 0) {
    /* Как минимум на одном из потоков произошло что-то интересное */
}
?>
```

### Примітки

> **Зауваження**
> 
> Через обмеження в поточному Zend Engine неможливо передати постійну **`null`** безпосередньо як параметр у функцію, яка очікує, що цей параметр буде передано за посиланням. Натомість використовуйте тимчасову змінну або вираз, у якому крайній лівий член буде тимчасовою змінною:
> 
> ```php
> <?php
> $e = NULL;
> stream_select($r, $w, $e, 0);
> ?>
> ```

> **Зауваження**
> 
> Переконайтеся, що використовуєте оператор `===` під час перевірки на помилку. Оскільки функція **streamselect()** може повертати 0, порівняння з використанням `==` може повертати **`true`**
> 
> ```php
> <?php
> $e = NULL;
> if (false === stream_select($r, $w, $e, 0)) {
>     echo "Произошла ошибка при вызове stream_select()\n";
> }
> ?>
> ```

> **Зауваження**
> 
> Якщо ви читаєте/пишете в потік, що повертається в масивах, знайте, що вони не обов'язково читають/пишуть повну кількість даних, які ви запросили. Будьте готові до того, щоб мати можливість читати/писати навіть по одному байту.

> **Зауваження**
> 
> Деякі потоки (наприклад, `zlib`) не можуть бути обрані цією функцією.

> **Зауваження** **Сумісність із Windows**
> 
> Використання функції **streamselect()** на файлових дескрипторах, повернутих функцією [procopen()](function.proc-open.html) не вдасться і поверне **`false`** під Windows.
> 
> **`STDIN`** з консолі змінює статус, як тільки стають доступними *будь-які* вхідні події, але читання потоку все ще може блокуватися.

### Дивіться також

-   [streamsetblocking()](function.stream-set-blocking.html) - Встановити блокуючий/неблокуючий режим у потоці
