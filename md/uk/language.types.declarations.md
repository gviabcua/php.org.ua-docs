---
navigation:
  - language.types.callable.md: Функції зворотного виклику (callback-функції)
  - language.types.type-juggling.md: Маніпуляції з типами »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Оголошення типів
---
## Оголошення типів

Оголошення типів можуть бути використані для аргументів функцій, що повертаються значень і, починаючи з PHP 7.4.0, для властивостей класу. Вони використовуються під час виконання для перевірки, що значення має той самий тип, який для них вказаний. В іншому випадку буде викинуто виняток [TypeError](class.typeerror.md)

> **Зауваження**
> 
> При перевизначенні батьківського методу, тип значення дочірнього методу, що повертається, повинен відповідати будь-якому оголошення типу типу батьківського, що повертається. Якщо в батьківському методі тип значення, що повертається, не оголошено, то це можна зробити в дочірньому.

### Поодинокі типи

| Тип | Описание | Версия |
| --- | --- | --- |
| Ім'я класу/інтерфейсу | Значення має бути [`instanceof`](language.operators.type.md) заданого класу чи інтерфейсу. |  |
| self | Значення має бути [`instanceof`](language.operators.type.md) того ж класу, у якому використовується оголошення типу. Може використовуватись лише у класах. |  |
| parent | Значення має бути [`instanceof`](language.operators.type.md) батьківського класу, у якому використовується оголошення типу. Може використовуватись лише у класах. |  |
| array | Значення має бути типу array. |  |
| [callable](language.types.callable.md) | Значення має бути коректним [callable](language.types.callable.md). Не можна використовувати як оголошення для властивостей класу. |  |
| bool | Значення має бути логічного типу. |  |
| float | Значення має бути числом із плаваючою точкою. |  |
| int | Значення має бути цілим числом. |  |
| string | Значення має бути рядком (тип string). |  |
| [iterable](language.types.iterable.md) | Значення може бути або масивом (тип array), або являти собою [`instanceof`](language.operators.type.md) [Traversable](class.traversable.md) | PHP 7.1.0 |
| object | Значення має бути об'єктом (тип об'єкта). | PHP 7.2.0 |
| [mixed](language.types.declarations.md#language.types.declarations.mixed) | Значення може мати будь-який тип. | PHP 8.0.0 |

**Увага**

Псевдоніми для зазначених вище скалярних типів не підтримуються. У разі використання вони будуть рахуватися за ім'я класу або інтерфейсу. Наприклад, при використанні як тип `boolean`, він буде очікувати, що значення являє собою [`instanceof`](language.operators.type.md) класу чи інтерфейсу `boolean`, а не значення типу bool:

```php
<?php
    function test(boolean $param) {}
    test(true);
?>
```

Результат виконання цього прикладу в PHP 8:

```
Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write "\boolean" to suppress this warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
  thrown in - on line 2
```

#### mixed

[mixed](language.types.declarations.md#language.types.declarations.mixed) еквівалентний [об'єднанню типів](language.types.declarations.md#language.types.declarations.composite.union) object|resource|array|string|int|float|bool|null. Доступно з PHP 8.0.0.

#### Приклади

**Приклад #1 Оголошення типу класу**

```php
<?php
class C {}
class D extends C {}

// Не является наследником C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
```

Результат виконання цього прикладу в PHP 8:

```
C
D

Fatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
```

**Приклад #2 Оголошення типу для інтерфейсу**

```php
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Не реализует интерфейс I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
```

Результат виконання цього прикладу в PHP 8:

```
C

Fatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
```

**Приклад #3 Оголошення типу значення, що повертається**

```php
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Обратите внимание, что будет возвращено число с плавающей точкой.
var_dump(sum(1, 2));
?>
```

Результат виконання цього прикладу:

```
float(3)
```

**Приклад #4 Повернення об'єкта**

```php
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
```

Результат виконання цього прикладу:

```
object(C)#1 (0) {
}
```

### Типи, що обнулюються

Оголошення типів можуть бути позначені як обнулювані шляхом додавання префікса у вигляді знака питання(`?`). Це означає, що значення може бути як оголошеного типу, так і бути рівним **`null`**

**Приклад #5 Оголошення типів, що обнулюються**

```php
<?php
class C {}

function f(?C $c) {
    var_dump($c);
}

f(new C);
f(null);
?>
```

Результат виконання цього прикладу:

```
object(C)#1 (0) {
}
NULL
```

**Приклад #6 Типи, що обнулюються для значення, що повертається**

```php
<?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
```

> **Зауваження**
> 
> До PHP 7.1.0, можна було задавати обнулювані типи аргументів функцій шляхом завдання значення за умовчанням рівного `null`. Так робити не рекомендується, оскільки це може поламати спадкування.
> 
> **Приклад #7 Старий спосіб задавати типи, що обнулюються, для аргументів**
> 
> ```php
> <?php
> class C {}
> 
> function f(C $c = null) {
>     var_dump($c);
> }
> 
> f(new C);
> f(null);
> ?>
> ```
> 
> Результат виконання цього прикладу:
> 
> ```
> object(C)#1 (0) {
> }
> NULL
> ```

### Складові типи

Можна комбінувати прості типи у складові типи. PHP дозволяє комбінувати типи такими способами:

-   Об'єднання найпростіших типів. Починаючи з PHP 8.0.0.
-   Перетин типів класів (інтерфейси та імена класів). Починаючи з PHP 8.1.0.

**Застереження**

Неможливо комбінувати перетин типів з об'єднанням типів.

#### Об'єднання типів

Об'єднання типів дозволяє використовувати кілька типів, а не лише один. Для їхнього оголошення використовується наступний синтаксис: `T1|T2|...`. Об'єднання типів доступне, починаючи з PHP 8.0.0.

##### Об'єднання типів, що припускає значення null

Тип `null` можна використовувати як частину об'єднання так: `T1|T2|null`. Існуюча нотація `?T` розглядається як скорочення для `T|null`

**Застереження**

`null` не може використовуватись як окремий тип.

##### Псевдотип false

Псевдотип `false` підтримується як частина об'єднання типів. Він доданий з історичних причин, оскільки багато вбудованих функцій повертають `false` замість `null` у разі виникнення помилки. Класичний приклад – функція [strpos()](function.strpos.md)

**Застереження**

`false` не можна використовувати як самостійний тип (включаючи варіант, що обнулюється). Таким чином, всі оголошення такого типу неприпустимі: `false` `false|null` і `?false`

**Застереження**

Зверніть увагу, що псевдотип `true` *не* існує.

#### Перетин типів

Оголошення перетину типів приймає значення, які задовольняють кільком оголошенням типу класу, а чи не одному. Перетин типів вказується з використанням синтаксису `T1&T2&...`. Перетин типів доступний, починаючи з PHP 8.1.0.

#### Типи, що дублюються і повторюються

Для вилову простих помилок у складових оголошеннях, типи, що повторюються, які можна відстежити без завантаження класу, призведуть до помилки компіляції. В тому числі:

-   Кожен тип, що розпізнається на ім'я, повинен зустрічатися лише один раз. Типи виду `int|string|INT` або `Countable&Traversable&COUNTABLE` приведуть до помилки.
-   Використання типу [mixed](language.types.declarations.md#language.types.declarations.mixed) призводить до помилки.
-   Для об'єднання типів:
    -   Якщо використовується bool, використовувати додатково false не можна.
    -   Якщо використовується тип об'єкта, то додаткове використання типів класів неприпустимо.
    -   Якщо використовується [iterable](language.types.iterable.md), то до нього не можна додати array або [Traversable](class.traversable.md)
-   Для перетину типів:
    -   Використання типу, який не є типом класу, призводить до помилки.
    -   Використання self, parent чи static призводить до помилки.

> **Зауваження**: Це не гарантує, що всі об'єднані типи оголошені коректно, оскільки така перевірка вимагатиме завантаження всіх використовуваних класів.

Наприклад, якщо `A` і `B` є псевдонімами того самого класу, то `A|B` виглядає як коректний об'єднаний тип, навіть якщо фактично оголошення може бути скорочено до `A` або `B`. Аналогічно, якщо `B extends A {}`, то `A|B` теж виглядає коректним типом, незважаючи на те, що він може бути скорочений до `A`

```php
<?php
function foo(): int|INT {} // Запрещено
function foo(): bool|false {} // Запрещено
function foo(): int&Traversable {} // Запрещено
function foo(): self&Traversable {} // Запрещено
use A as B;
function foo(): A|B {} // Запрещено ("use" является частью разрешения имён)
function foo(): A&B {} // Запрещено ("use" является частью разрешения имён)
class_alias('X', 'Y');
function foo(): X|Y {} // Допустимо (повторение будет определено только во время выполнения)
function foo(): X&Y {} // Допустимо (повторение будет определено только во время выполнения)
?>
```

### Типи, придатні тільки для значення, що повертається

#### void

Тип `void` означає, що функція нічого не повертає. Відповідно, він може бути частиною об'єднання. Доступно з PHP 7.1.0.

> **Зауваження**
> 
> Повернення за посиланням з функції з типом void, що повертається, застаріло з PHP 8.1.0, тому що така функція суперечлива. Раніше під час виклику видавалася наступна помилка рівня **`E_NOTICE`** `Only variable references should be returned by reference`
> 
> ```php
> <?php
> function &test(): void {}
> ?>
> ```

#### never

`never` - тип значення, що повертається, що вказує, що функція нічого не повертає. Це означає, що вона або викликає [exit()](function.exit.md), або викидає виняток, або є нескінченним циклом. Отже, вона не може бути частиною оголошення union-типу. Доступно з PHP 8.1.0.

never, говорячи мовою теорії типів, є нижчим типом. Це означає, що це підтип будь-якого іншого типу і може замінити будь-який інший тип значення, що повертається при успадкування.

#### static

Значення має бути [`instanceof`](language.operators.type.md) того ж класу, в якому було викликано метод. Доступно з PHP 8.0.0.

### Сувора типізація

За промовчанням PHP буде перетворювати значення неправильного типу в очікувані. Наприклад, якщо у функцію передати параметр типу int аргумент, оголошений як string, він перетворюється на string.

Можна увімкнути режим суворої типізації на рівні файлу. У цьому режимі тип значення повинен суворо відповідати оголошеному, інакше буде викинуто виняток [TypeError](class.typeerror.md). Єдиним винятком цього правила є передача значення типу int туди, де очікується float.

**Увага**

На дзвінки з внутрішніх функцій, дія `strict_types` не розповсюджується.

Для увімкнення суворої типізації використовується оператор [`declare`](control-structures.declare.md) з оголошенням `strict_types`

> **Зауваження**
> 
> Сувора типізація застосовується до викликів функцій, зроблених *зсередини* файла з увімкненою строгою типізацією, а не до функцій, оголошених у цьому файлі. Якщо з файлу без увімкненої суворої типізації викликається функція, що була визначена у файлі зі суворою типізацією, будуть використані його переваги по типізації - тобто. правила суворої типізації будуть проігноровані і для значень застосовуватиметься приведення типів.

> **Зауваження**
> 
> Сувора типізація визначається лише для оголошень скалярних типів.

**Приклад #8 Сувора типізація для значень аргументів**

```php
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
```

Результат виконання цього прикладу в PHP 8:

```
int(3)

Fatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
```

**Приклад #9 Приведення типів для значень аргументів**

```php
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Переданные значения будут приведены к целым числам: обратите внимание на вывод ниже!
var_dump(sum(1.5, 2.5));
?>
```

Результат виконання цього прикладу:

```
int(3)
int(3)
```

**Приклад #10 Сувора типізація для значень, що повертаються**

```php
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
```

Результат виконання цього прикладу:

```
int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
```

### Приведення для об'єднаних типів

Якщо `strict_types` заборонено, то оголошення скалярних типів підлягають обмеженому неявному приведению. Якщо фактичний тип не є частиною об'єднання, використовується такий порядок приведення типів:

1.  int
2.  float
3.  string
4.  bool

Якщо тип присутня в об'єднанні, і значення може бути приведено до нього, ґрунтуючись на існуючій семантиці приведення типів PHP, буде приведення до нього. Якщо ні, перевіриться наступний тип у списку.

**Застереження**

Єдиним винятком є ​​приведення рядка у разі, якщо в об'єднанні одночасно присутні і int, і float. У такому разі буде обрано найбільш відповідний тип за правилом приведення "числових рядків". Наприклад, для `"42"` буде вибрано тип int, а для `"42.0"` - Тип float.

> **Зауваження**
> 
> Типи, що не входять до цього списку, не підходять для неявного приведення. Зокрема, для `null` і `false` неявного приведення не станеться.

**Приклад #11 Приклад для об'єднаних типів**

```php
<?php
// int|string
42    --> 42          // явный тип
"42"  --> "42"        // явный тип
new ObjectWithToString --> строка с результатом выполнения __toString()
                      // Объекты никогда не будут приведены к целому числу, даже если вернут "числовую строку"
42.0  --> 42          // float совместим с int
42.1  --> 42          // float совместим с int
1e100 --> "1.0E+100"  // float слишком большой для типа int, преобразуется в строку
INF   --> "INF"       // float слишком большой для типа int, преобразуется в строку
true  --> 1           // bool совместим с int
[]    --> TypeError   // array несовместим ни с int, ни со string

// int|float|bool
"45"    --> 45        // целочисленная "числовая строка"
"45.0"  --> 45.0      // "числовая строка" с плавающей точкой

"45X"   --> true      // не "числовая строка", приведётся к bool
""      --> false     // не "числовая строка", приведётся к bool
"X"     --> true      // не "числовая строка", приведётся к bool
[]      --> TypeError // array несовместим ни с int, ни с float, ни с bool
?>
```

### Додатково

**Приклад #12 Типизовані параметри, що передаються за посиланням**

Оголошення типів для параметрів, що надсилаються за посиланням, перевіряється лише на етапі виклику функції. Немає гарантії, що після виходу з функції тип змінної залишиться незмінним.

```php
<?php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
```

Результат виконання цього прикладу в PHP 8:

```
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
  thrown in - on line 2
```

**Приклад #13 [TypeError](class.typeerror.md)**

```php
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Ошибка: ', $e->getMessage();
}
?>
```

Результат виконання цього прикладу в PHP 8:

```
int(3)
Ошибка: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 10
```
