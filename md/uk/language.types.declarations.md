---
navigation:
  - language.types.iterable.md: « Ітеровані
  - language.types.type-juggling.md: Маніпуляції з типами »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Оголошення типів
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Оголошення типів

Оголошення типів дозволено додавати до аргументів функції, значенням, що повертаються, і властивостям класу (останнє починаючи з PHP 7.4.0). Оголошені типи гарантують, що під час виклику значення належить тому типу, який для нього вказано, інакше буде викинуто виняток [TypeError](class.typeerror.md)

Кожен тип, який підтримує PHP, за винятком ресурсів (resource), дозволено вказувати при об'явленні користувача типу. На цій сторінці наведено журнал змін доступності окремих типів та документацію про те, як їх застосовувати в оголошеннях типів.

> **Зауваження** :
> 
> Коли клас реалізує метод інтерфейсу або перевизначає метод, який вже був визначений батьківським класом, метод, що знову визначається, повинен бути сумісний з визначенням, яке було зроблено раніше. Метод сумісний, якщо він дотримується [правила варіантності](language.oop5.variance.md)

### список змін

| Версия | Опис |
| --- | --- |
| 8.3.0 | Додано підтримку типізації констант класів, інтерфейсів, трейтів та перерахувань. |
| 8.2.0 | Додано підтримку типів DNF. |
| 8.2.0 | Додано підтримку типу true. |
| 8.2.0 | Типи null та false тепер можна використовувати автономно. |
| 8.1.0 | Додано підтримку перетинів типів. |
| 8.1.0 | Повернення за посиланням з функції з типом значення, що повертається void застарів. |
| 8.1.0 | Додано підтримку типу повертаного значення never. |
| 8.0.0 | Додана підтримка типу значення, що повертається [mixed](language.types.declarations.md#language.types.declarations.mixed) |
| 8.0.0 | Додано підтримку типу повертаного значення static. |
| 8.0.0 | Додано підтримку об'єднання типів. |
| 7.4.0 | Додано підтримку типізації властивостей класів. |
| 7.2.0 | Додана підтримка типу значення object, що повертається. |
| 7.1.0 | Додана підтримка типу значення, що повертається [iterable](language.types.iterable.md) |
| 7.1.0 | Додано підтримку типу повертаного значення void. |
| 7.1.0 | Додана підтримка типу значення nullable. |

### Примітка щодо використання атомарних типів

Атомарні типи мають прямолінійну поведінку з незначними застереженнями, які описані в цьому розділі.

#### Скалярні типи

**Увага**

Псевдоніми імен для скалярних типів (bool, int, float, string) не підтримуються. Натомість вони розглядаються як імена класів або інтерфейсів. Наример, коли в якості типу вказано `boolean`очікується, що значення виконує умова [`instanceof`](language.operators.type.md) щодо класу чи інтерфейсу `boolean`, а не значення типу bool:

```php
<?php
    function test(boolean $param) {}
    test(true);
?>
```

Результат виконання наведеного прикладу в PHP 8:

```
Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write "\boolean" to suppress this warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
  thrown in - on line 2
```

#### void

> **Зауваження** :
> 
> Повернення за посиланням з void-функції застарілий починаючи з PHP 8.1.0, оскільки така функція суперечлива. Раніше під час її виклику видавалася помилка рівня **`E_NOTICE`**: Тільки посилання на змінні повинні повертатися за посиланням
> 
> ```php
> <?php
> function &test(): void {}
> ?>
> ```

#### Тип Callable

Цей тип не можна оголошувати як тип якості класу.

> **Зауваження**: Цей тип неможливо вказати як назву функції.

#### Оголошення типів у параметрах передачі за посиланнями

Якщо у параметрі, що передається за посиланням, оголошується тип значення, що повертається, тип змінної перевіряється *тільки* при вході в функцію, на початку дзвінка, але не при поверненні функції. Тобто функція може змінити тип посилання змінну.

**Приклад #1 Типизовані параметри, що передаються за посиланням**

```php
<?php

function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
```

Висновок наведеного прикладу буде схожим на:

```
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
  thrown in - on line 2
```

### Примітка щодо складових типів

На оголошення складових типів поширюється низка обмежень і під час компіляції PHP виконає перевірку оголошених типів на надмірність, щоб запобігти простим помилкам.

**Застереження**

До PHP 8.2.0 та появи DNF-типів, було неможливо комбінувати пересічені та об'єднані типи.

#### Об'єднання типів

**Увага**

Неможливо поєднувати два типи значень false та true. Натомість вказують bool.

**Застереження**

Оскільки до PHP 8.2.0 не можна було визначати false і null як окремі типи, об'єднання типів, що складалося лише з цих типів, було неприпустимим. Сюди входять типи: false, `false|null`и`?false`

##### Синтаксичний цукор типу Nullable

Оголошення одного базового типу може бути позначене як nullable шляхом додавання до типу префікса у вигляді знака питання (`?` ). Тому `?T`и`T|null` ідентичні.

> **Зауваження**: Цей синтаксис підтримується з PHP 7.1.0 та передує підтримці об'єднання типів.

> **Зауваження** :
> 
> Ще один спосіб досягти nullable-аргументів - вказати `null` значенням за промовчанням. Такий спосіб не рекомендований, оскільки якщо значення за замовчуванням буде змінено в дочірньому класі, виникне порушення сумісності типів, так як в оголошення типу потрібно буде додати тип null.
> 
> **Приклад #2 Старий спосіб вказівки nullable-аргументів**
> 
> ```php
> <?php
> 
> class C {}
> 
> function f(C $c = null) {
>     var_dump($c);
> }
> 
> f(new C);
> f(null);
> ?>
> ```
> 
> Результат виконання наведеного прикладу:
> 
> ```
> object(C)#1 (0) {
> }
> NULL
> ```

#### Повторювані та надлишкові типи

Надлишкові типи, які можна знайти без виконання завантаження класу, призведуть до помилки під час компіляції, щоб відловити неточності в оголошеннях складових типів. У них включено:

-   Кожне ім'я після дозволу внутрішніми засобами мови може зустрічатися лише один раз. Наприклад, типи`int|string|INT`или`Countable&Traversable&COUNTABLE`приведуть до помилки.
-   Вказівка ​​типу[mixed](language.types.declarations.md#language.types.declarations.mixed)(з іншими типами) призведе до помилки.
-   Для об'єднаних типів:
    -   Якщо вказано тип bool, то false чи true не може бути вказано додатково.
    -   Якщо вказано тип об'єкта, типи класів не можна вказувати додатково.
    -   Якщо вказано тип[iterable](language.types.iterable.md), то array і[Traversable](class.traversable.md)не можна вказувати додатково.
-   Для перетятих типів:
    -   Вказівка ​​типу, що не відноситься до типу класу, призведе до помилки.
    -   Вказівка ​​self, parent або static призведе до помилки.
-   Для DNF-типів:
    -   Якщо вказано більш загальний тип, то суворіший тип буде надлишковим.
    -   Дублювання членів у пересічених типах.

> **Зауваження**: Це не гарантує, що тип мінімальний, оскільки для цього довелося б завантажити всі зазначені типи класів.

Наприклад, якщо `A`и`B` - це псевдоніми класів, то `A|B` залишається коректним об'єднанням типів, навіть якщо його можна звести або до `A`, либо к`B`. Аналогічно, якщо клас `B extends A {}`, то`A|B` також є коректним поєднанням типів, навіть якщо його можна звести до просто `A`

```php
<?php

function foo(): int|INT {} // Запрещено
function foo(): bool|false {} // Запрещено
function foo(): int&Traversable {} // Запрещено
function foo(): self&Traversable {} // Запрещено

use A as B;
function foo(): A|B {} // Запрещено («use» — часть разрешения имён)
function foo(): A&B {} // Запрещено («use» — часть разрешения имён)

class_alias('X', 'Y');
function foo(): X|Y {} // Разрешено (избыточность известна только во время выполнения)
function foo(): X&Y {} // Разрешено (избыточность известна только во время выполнения)
?>
```

### Приклади

**Приклад #3 Приклад оголошення типу класу**

```php
<?php

class C {}
class D extends C {}

// Не наследует C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
```

Результат виконання наведеного прикладу в PHP 8:

```
C
D

Fatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
```

**Приклад #4 Приклад оголошення типу інтерфейсу**

```php
<?php

interface I { public function f(); }
class C implements I { public function f() {} }

// Не реализует I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
```

Результат виконання наведеного прикладу в PHP 8:

```
C

Fatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
```

**Приклад #5 Приклад оголошення типу значення, що повертається**

```php
<?php

function sum($a, $b): float {
    return $a + $b;
}

// Обратите внимание, что будет возвращено значение float.
var_dump(sum(1, 2));
?>
```

Результат виконання наведеного прикладу:

```
float(3)
```

**Приклад #6 Повернення об'єкта**

```php
<?php

class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
```

Результат виконання наведеного прикладу:

```
object(C)#1 (0) {
}
```

**Приклад #7 Оголошення аргументу типу Nullable**

```php
<?php

class C {}

function f(?C $c) {
    var_dump($c);
}

f(new C);
f(null);
?>
```

Результат виконання наведеного прикладу:

```
object(C)#1 (0) {
}
NULL
```

**Приклад #8 Оголошення типу значення, що повертається Nullable**

```php
<?php

function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
```

**Приклад #9 Оголошення типу якості класу**

```php
<?php

class User {
    public static string $foo = 'foo';

    public int $id;
    public string $username;

    public function __construct(int $id, string $username) {
        $this->id = $id;
        $this->username = $username;
    }
}
?>
```

### Сувора типізація

За промовчанням PHP перетворюватиме значення неправильного типу на очікувані. Наприклад, якщо рядковий (string) параметр функції передати ціле число (int), воно перетворюється на рядок (string).

Можна увімкнути режим суворої типізації на рівні файлу. У цьому режимі тип значення повинен суворо відповідати оголошеному, інакше буде викинуто виняток [TypeError](class.typeerror.md). Єдиний виняток із цього правила — передача цілого значення (int) туди, де очікується число з плаваючою точкою (float).

**Увага**

На дзвінки з внутрішніх функцій дія `strict_types` не розповсюджується.

Для включення суворої типізації вказують оператор [`declare`](control-structures.declare.md) з оголошенням `strict_types` :

> **Зауваження** :
> 
> Сувора типізація поширюється на виклики функцій, зроблених *зсередини* файла з увімкненою строгою типізацією, а не до функцій, оголошених у цьому файлі. Якщо з файлу без увімкненої суворої типізації викликається функція, яка була визначена у файлі зі суворою типізацією, то будуть використані установки по типізації зухвалої сторони - тобто правила суворої типізації будуть проігноровані і для значень застосовуватиметься приведення типів.

> **Зауваження** :
> 
> Сувора типізація визначається лише для оголошень скалярних типів.

**Приклад #10 Сувора типізація для значень аргументів**

```php
<?php

declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
```

Результат виконання наведеного прикладу в PHP 8:

```
int(3)

Fatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
```

**Приклад #11 Приведення типів для значень аргументів**

```php
<?php

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Переданные значения будут приведены к целым числам: обратите внимание на вывод ниже!
var_dump(sum(1.5, 2.5));
?>
```

Результат виконання наведеного прикладу:

```
int(3)
int(3)
```

**Приклад #12 Сувора типізація для значень, що повертаються**

```php
<?php

declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
```

Результат виконання наведеного прикладу:

```
int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
```
