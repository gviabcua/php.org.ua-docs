---
navigation:
  - features.gc.refcounting-basics.html: « Основи підрахунку посилань
  - features.gc.performance-considerations.html: Питання продуктивності »
  - index.md: PHP Manual
  - features.gc.md: Сборка мусора
title: Збір циклічних посилань
---
## Збір циклічних посилань

Зазвичай механізми підрахунку посилань у пам'яті, наприклад, використовуваний у PHP раніше, не вирішують проблему витоку пам'яті через циклічні посилання. Починаючи з версії 5.3.0, у PHP реалізовано синхронний механізм із дослідження "[» Concurrent Cycle Collection in Reference Counted Systems](https://pages.cs.wisc.edu/~cymen/misc/interests/Bacon01Concurrent.pdf)", У якому розглядається це питання.

Повний опис роботи алгоритму виходить за межі даного розділу, тому наведено лише основи. Насамперед ми маємо задати кілька основних правил. Якщо лічильник посилань збільшується, контейнер все ще використовується і не є сміттям. Якщо лічильник зменшується до нуля, zval може бути видалений. Виходячи з цих правил витоку пам'яті з циклічними посиланнями можуть вийти тільки при зменшенні лічильника посилань до ненульового значення. Потім, у виділених контейнерах можна знайти сміття, перевіривши можливість зменшення всіх лічильників посилань на одиницю і визначивши ті контейнери, у яких лічильник стане рівним нулю.

![Алгоритм складання сміття](images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png)

Щоб уникнути постійної перевірки на сміття з циклічними посиланнями при кожному зменшенні лічильника посилань, алгоритм додає всі можливі корені (zval контейнери) в "кореневий буфер" (позначаючи їх як "фіолетові"). Це також гарантує попадання будь-якого кореня в буфер лише один раз. Механізм складання сміття стартує лише тоді, коли наповнюється буфер (дивіться крок A на малюнку вище).

На кроці B алгоритм шукає в глибину по всіх можливих коренях для одноразового зменшення лічильника посилань на одиницю у всіх контейнерів (позначаючи їх як "сірі"). На кроці C алгоритм знову здійснює пошук у глибину для перевірки лічильників посилань. Якщо він знаходить лічильник з нульовим значенням, контейнер позначається як "білий" (на малюнку відображено синім). Якщо ж лічильник більший за нуль, то відбувається пошук у глибину від цього контейнера зі зворотним збільшенням лічильників на одиницю і повторною позначкою як "чорний" на їх контейнерах. На останньому кроці D алгоритм проходить кореневим буфером і видаляє з нього коріння контейнерів, заодно перевіряючи які контейнери позначені як "білі". Ці контейнери буде звільнено з пам'яті.

Тепер, коли ви маєте уявлення про роботу алгоритму, розглянемо його інтеграцію до PHP. За замовчуванням збирач сміття завжди включений. Для зміни цієї опції використовується параметр [zend.enableгк](info.configuration.html#ini.zend.enable-gc) у php.ini.

Якщо збирач сміття включений, алгоритм пошуку циклічних посилань виконується щоразу, коли кореневий буфер наповнюється 10,000 корінням (можна змінити це значення, змінивши константу `GC_ROOT_BUFFER_MAX_ENTRIES` у файлі `Zend/zend_gc.c` у вихідному коді PHP і перебравши PHP). Якщо сміття вимкнено, алгоритм ніколи не буде запущений. Тим не менш, буфер завжди заповнюється корінням.

Якщо буфер заповнився при вимкненому механізмі складання сміття, то інше коріння не буде в нього записано. Таким чином, якщо вони виявляться сміттям із циклічними посиланнями, то ніколи не будуть очищені та створять витік пам'яті.

Причиною постійного запису коріння в буфер навіть при вимкненому механізмі складання сміття є те, що це набагато швидше, ніж постійно перевіряти, чи увімкнений механізм складання сміття. Проте, саме складання сміття та алгоритм її аналізу можуть займати значний час.

Крім зміни параметра [zend.enableгк](info.configuration.html#ini.zend.enable-gc), механізм складання сміття також можна запустити і зупинити викликавши функції [гкenable()](function.gc-enable.html) і [гкdisable()](function.gc-disable.html) відповідно. Виклик цих функцій має той самий ефект, що й увімкнення/вимкнення механізму за допомогою налаштувань конфігурації. Крім того, можна запустити складання сміття, навіть якщо кореневий буфер ще не заповнений. Для цього ви можете викликати функцію [гкcollectcycles()](function.gc-collect-cycles.html), яка також повертає кількість циклічних посилань, зібраних алгоритмом.

Причиною включення та вимикання механізму складання, а також його ручного запуску може стати те, що деякі частини вашої програми можуть бути вимогливими до часу. У цих випадках ви, можливо, не захочете стороннього втручання збирача сміття. Зрозуміло, виключаючи збирач сміття у певних місцях вашого додатка ви ризикуєте отримати витік пам'яті, т.к. потенційно деякі коріння можуть не поміститися в обмежений кореневий буфер. Доцільніше буде викликати [гкcollectcycles()](function.gc-collect-cycles.html) безпосередньо перед викликом [гкdisable()](function.gc-disable.html) для звільнення пам'яті та вже записаних коренів у буфері. Це очистить буфер і дозволить використовувати більше місця для зберігання коріння, доки механізм буде вимкнено.
