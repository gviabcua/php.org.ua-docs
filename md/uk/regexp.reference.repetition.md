Повторення

-   [« Подмаски](regexp.reference.subpatterns.html)
    
-   [Обратные ссылки »](regexp.reference.back-references.html)
    
-   [PHP Manual](index.html)
    
-   [Описание синтаксиса Perl-совместимых регулярных выражений](reference.pcre.pattern.syntax.html)
    
-   Повторення
    

## Повторення

Повторення задається за допомогою квантифікаторів, наступних за будь-яким із наведених нижче елементів:

-   довільним, можливо екранованим символом
-   метасимволом "точка"
-   символьним класом
-   посиланням на попередній фрагмент шаблону (див. наступний розділ)
-   взятої в круглий дужки підмаскою (якщо це не твердження - дивіться далі)

Загальний квантифікатор повторення вказує мінімальну та максимальну допустиму кількість збігів, згідно з двома числами, укладеними у фігурні дужки та розділеними комою. Числа повинні бути меншими ніж 65536, і перше число не повинно перевищувати друге за значенням. Наприклад: `z{2,4}` відповідає "zz", "zzz" чи "zzzz". Фігурна дужка, що закриває, сама по собі не є спеціальним символом. У разі, якщо друге число опущено, але кома присутня, немає верхньої межі; у випадку, якщо і друге число і кома опущені, потрібна точна кількість повторень. Таким чином `[aeiou]{3,}` відповідає як мінімум трьом послідовним голосним (а також будь-якій їх кількості вище трьох), у той час як `\d{8}` відповідає рівно вісім цифр. Фігурна дужка, що відкриває, розташована в неприпустимій для квантифікатора позиції, або не відповідає синтаксису квантифікатора, інтерпретується як звичайний символьний рядок. Наприклад, {,6} не є квантифікатором, а інтерпретується як символьний рядок із чотирьох символів.

Квантифікатор {0} є допустимим і поводиться таким чином, нібито сам квантифікатор і елемент, що його передує, відсутні.

Для зручності (а також зворотної сумісності) три найбільш поширені квантифікатори мають односимвольні абревіатури:

<table class="doctable table"><caption><strong>Односимвольні квантифікатори</strong></caption><tbody class="tbody"><tr><td><code class="literal">*</code></td><td>еквівалентний <code class="literal">{0,}</code></td></tr><tr><td><code class="literal">+&lt; /code&gt;</code></td><td>еквівалентний <code class="literal">{1,}</code></td></tr><tr><td><code class="literal">?</code></td><td>еквівалентний <code class="literal">{0,1}</code></td></tr></tbody></table>

Можна конструювати нескінченні цикли, вказавши після шаблону, що збігається з порожнім рядком, квантифікатор, який не має верхньої межі, наприклад: `(a?)*`

Ранні версії Perl та PCRE видавали помилку під час компіляції для таких шаблонів. Однак, оскільки бувають випадки, коли подібні шаблони могли б бути корисними, було додано підтримку таких шаблонів. Але якщо будь-яке повторення такої підмаски практично не збігається з жодними символами, цикл примусово переривається.

За замовчуванням, всі квантифікатори є "жадібними", це означає, що вони збігаються максимально можливу кількість разів (але не більше ніж максимально допустиму кількість разів), не призводячи до неможливості зіставлення інших частин шаблону. Класичний приклад проблем, які можуть виникнути у зв'язку з такою особливістю квантифікаторів – знаходження коментарів у C-програмах. Коментар вважається довільний текст, що знаходиться всередині символьних комбінацій / і / (при цьому, символи '/' та 'також можуть бути частиною коментаря). Спроба знайти коментарі за допомогою шаблону `/\*.*\*/` у рядку `/* первый комментарий */ не комментарий /* второй комментарий */` закінчиться невдачею, оскільки вказаний шаблон відповідає всьому рядку цілком (через жадібність квантифікатора '

Однак, якщо відразу ж після квантифікатора йде знак питання, він стає "ледачим" і відповідає мінімально допустимій кількості разів. Таким чином, шаблон `/\*.*?\*/` коректно знаходить усі коментарі мови Сі. Використання символу '?' після квантифікатора впливає виключно на його жадібність, і не торкається жодних інших властивостей. Не слід плутати використання символу '?' як, власне, квантифікатора (нуль чи одне відповідність) як і обмежувача жадібності. Також внаслідок його двоїстої функціональності може використовуватися наступний запис: `\d??\d`, яка в першу чергу відповідає одній цифрі, але може відповідати і двом цифрам, якщо це необхідно для відповідності інших частин шаблону.

Якщо встановлено опцію [PCRE\_UNGREEDY](reference.pcre.pattern.modifiers.html) (відсутня в Perl), квантифікатори не є жадібними за умовчанням, але можуть ставати такими, якщо за ними слідує символ '?'. Іншими словами, знак питання інвертує жадібність квантифікаторів.

Квантифікатори, за якими слідує `+`, є "захоплюючими". Вони поглинають стільки символів, скільки можуть і не повертаються для збігу залишку шаблону. Таким чином `.*abc` збігається з "aabc", а `.*+abc` - ні, тому що `.*+` захопить весь рядок цілком. Захоплюючі квантифікатори можна використовувати для прискорення обробки.

Якщо використовується підмаска з квантифікатором, для якого задано мінімальну кількість повторень (більше одного), або задано максимальну кількість повторень, то для відкомпілюваного шаблону потрібно більше пам'яті (пропорційно мінімуму або максимуму відповідно).

Якщо шаблон починається з . або .{0,}, і встановлено модифікатор [PCRE\_DOTALL](reference.pcre.pattern.modifiers.html) (є аналогом Perl-опції /s), який дозволяє метасимволу "точка" відповідати перекладам рядків, шаблон неявно заякорюється. Це відбувається оскільки всі наступні конструкції будуть зіставлятися з кожною символьною позицією в тексті, що обробляється, і, як наслідок, початок рядка - єдина позиція, що дає найбільш повний збіг. PCRE розглядає кожен такий шаблон, якби йому передувала послідовність A. Якщо відомо, що дані не містять перекладів рядків, а сам шаблон починається на ., рекомендується використовувати [PCRE\_DOTALL](reference.pcre.pattern.modifiers.html) для оптимізації шаблону або використовувати метасимвол '^' для вказівки явного заякорювання.

Якщо захоплива підмаска повторюється, результуючим значенням підмаски буде підрядок, що збігається з результатом останньої ітерації. Наприклад, після того, як `(tweedle[dume]{3}\s*)+` збігається з "tweedledum tweedledee", результуючим значенням підмаски буде "tweedledee". Однак, якщо є вкладені захоплюючі підмаски, відповідні значення можуть бути встановлені в попередніх ітераціях. Наприклад, після того, як `/(a|(b))+/` збігається з "aba", значенням другого захопленого підрядка буде "b".