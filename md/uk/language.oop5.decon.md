Конструктори та деструктори

-   [« Автоматичне завантаження класів](language.oop5.autoload.md)
    
-   [Область видимості "](language.oop5.visibility.md)
    
-   [PHP Manual](index.md)
    
-   [Класи та об'єкти](language.oop5.md)
    
-   Конструктори та деструктори
    

## Конструктори та деструктори

### Конструктор

```methodsynopsis
__construct(mixed ...$values = ""): void
```

PHP дозволяє оголошувати методи-конструктори. Класи, в яких оголошено метод-конструктор, викликатимуть цей метод при кожному створенні нового об'єкта, так що це може бути корисним, наприклад, для ініціалізації будь-якого стану об'єкта перед його використанням.

> **Зауваження**: Конструктори, визначені у класах-батьках, не викликаються автоматично, якщо дочірній клас визначає власний конструктор. Щоб викликати конструктор, оголошений у батьківському класі, потрібно викликати **parent::construct()** усередині конструктора дочірнього класу. Якщо в дочірньому класі не визначено конструктора, то він може бути успадкований від батьківського класу як звичайний метод (якщо він не був визначений як приватний).

**Приклад #1 Конструктори при наслідуванні**

```php
<?php
class BaseClass {
   function __construct() {
       print "Конструктор класса BaseClass\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "Конструктор класса SubClass\n";
   }
}

class OtherSubClass extends BaseClass {
    // наследует конструктор BaseClass
}

// Конструктор класса BaseClass
$obj = new BaseClass();

// Конструктор класса BaseClass
// Конструктор класса SubClass
$obj = new SubClass();

// Конструктор класса BaseClass
$obj = new OtherSubClass();
?>
```

На відміну від інших методів, [construct()](language.oop5.decon.html#object.construct) звільняється від звичайних [правил сумісності сигнатури](language.oop5.basic.html#language.oop.lsp) при наслідуванні.

Конструктори - це звичайні методи, що викликаються під час інстанціювання відповідних об'єктів. Отже, вони можуть мати довільну кількість аргументів, які можуть бути обов'язковими, можуть бути типізованими та можуть мати значення за умовчанням. Аргументи конструктора вказуються у круглих дужках після імені класу.

**Приклад #2 Використання аргументів у конструкторах**

```php
<?php
class Point {
    protected int $x;
    protected int $y;

    public function __construct(int $x, int $y = 0) {
        $this->x = $x;
        $this->y = $y;
    }
}

// Передаём оба параметра.
$p1 = new Point(4, 5);
// Передаём только обязательные параметры. Для $y используется значеие по умолчанию 0.
$p2 = new Point(4);
// Вызываем с именованными параметрами (начиная с PHP 8.0):
$p3 = new Point(y: 5, x: 4);
?>
```

Якщо клас не має конструктора, або його конструктор не має обов'язкових параметрів, дужки після імені класу можна не писати.

#### Конструктори у старому стилі

До PHP 8.0.0, класи в глобальному просторі імен інтерпретуватимуть метод, названий так само, як клас, як конструктор старого стилю. Цей синтаксис вважається застарілим і викликатиме помилку рівня \*\*`E_DEPRECATED`\*\*Але все одно ці методи будуть викликатися як конструктор. Якщо в класі присутні і [construct()](language.oop5.decon.html#object.construct), і метод з ім'ям класу, то як конструктор буде викликаний [construct()](language.oop5.decon.html#object.construct)

Для класів, що знаходяться у власному просторі імен та для всіх класів, починаючи з PHP 8.0.0, метод, названий на ім'я класу, ігноруватиметься.

У новому коді завжди використовуйте [construct()](language.oop5.decon.html#object.construct)

#### Визначення властивостей об'єкта у конструкторі

Починаючи з PHP 8.0.0, параметри конструктора можна використовуватиме завдання відповідних властивостей об'єкта. Це досить поширена практика — надавати властивостям об'єкта параметри, передані в конструктор, не роблячи жодних додаткових перетворень. Визначення властивостей класу в конструкторі дозволяє значно скоротити кількість шаблонного коду такого випадку. Приклад вище можна буде переписати так:

**Приклад #3 Використання визначення властивостей конструктора**

```php
<?php
class Point {
    public function __construct(protected int $x, protected int $y = 0) {
    }
}
```

Якщо декларація аргументу конструктора включає модифікатор видимості, PHP інтерпретує його одночасно і як аргумент конструктора, і як властивість об'єкта і автоматично надасть властивості значення, передане в конструктор. При цьому, якщо не передбачається якоїсь додаткової логіки, тіло конструктора можна залишити порожнім. Код конструктора виконається після того, як усі аргументи нададуться всім відповідним властивостям.

Не всі аргументи, що передаються в конструктор, повинні бути властивостями об'єкта. У конструкторі можна ставити як звичайні, і є властивостями об'єкта аргументи у порядку. Аргументи-властивості ніяк не впливають на код, що виконується на конструкторі.

> **Зауваження**
> 
> Властивості об'єктів не можуть бути типу [callable](language.types.callable.md) у зв'язку з неоднозначністю, яку вони представляють для двигуна PHP. Відповідно і властивості, що визначаються в конструкторі, також не можуть бути типу [callable](language.types.callable.md). Будь-які інші [декларации типов](language.types.declarations.md) допустимі.

> **Зауваження**
> 
> [Атрибути](language.attributes.md), Задані для таких аргументів, будуть застосовані як для них самих, так і для відповідних властивостей.

#### New в ініціалізації класу

Починаючи з PHP 8.1.0, об'єкти можна використовувати як значення параметрів за промовчанням, статичних змінних і глобальних констант, а також в аргументах атрибутів. Об'єкти також тепер можна передавати в [define()](function.define.md)

> **Зауваження**
> 
> Використання динамічного або строкового імені класу або анонімного класу не допускається. Використання розпакування аргументів не допускається. Використання непідтримуваних виразів як аргументи не допускається.

**Приклад #4 Приклад використання new в ініціалізації класу**

```php
<?php
// Всё допустимо:
static $x = new Foo;
const C = new Foo;

function test($param = new Foo) {}

#[AnAttribute(new Foo)]
class Test {
    public function __construct(
        public $prop = new Foo,
    ) {}
}
// Всё не допустимо (ошибка во времени компиляции):
function test(
    $a = new (CLASS_NAME_CONSTANT)(), // динамическое имя класса
    $b = new class {}, // анонимний класс
    $c = new A(...[]), // распаковка аргументов
    $d = new B($abc), // неподдерживаемое постоянное выражение
) {}
?>
```

#### Статичні методи створення об'єкту

PHP підтримує лише один конструктор для класу. Однак у деяких випадках є потреба створювати об'єкт різними шляхами залежно від різних вхідних даних. Рекомендований спосіб – використовувати статичні методи як обгортки над конструктором.

**Приклад #5 Використання статичних методів створення об'єктів**

```php
<?php
class Product {

    private ?int $id;
    private ?string $name;

    private function __construct(?int $id = null, ?string $name = null) {
        $this->id = $id;
        $this->name = $name;
    }

    public static function fromBasicData(int $id, string $name): static {
        $new = new static($id, $name);
        return $new;
    }

    public static function fromJson(string $json): static {
        $data = json_decode($json);
        return new static($data['id'], $data['name']);
    }

    public static function fromXml(string $xml): static {
        // Пользовательская логика.
        $data = convert_xml_to_array($xml);
        $new = new static();
        $new->id = $data['id'];
        $new->name = $data['name'];
        return $new;
    }
}

$p1 = Product::fromBasicData(5, 'Widget');
$p2 = Product::fromJson($some_json_string);
$p3 = Product::fromXml($some_xml_string);
```

Конструктор можна зробити прихованим або захищеним для запобігання прямому виклику. У такому разі об'єкт класу можна буде створити лише за допомогою статичних методів. Так як це методи того ж класу, вони мають доступ до всіх його прихованих методів, навіть якщо вони належать до різних екземплярів класу. Прихований конструктор є опціональним і може бути присутнім або відсутнім за потребою.

У прикладі вище три публічні статичні методи демонструють різні способи створення екземпляра об'єкта.

-   `fromBasicData()` приймає явні параметри, створює екземпляр класу через конструктор та повертає об'єкт.
-   `fromJson()` приймає JSON рядок, здійснює над нею деякі перетворення, витягує дані необхідні для створення об'єкта і, як і попередній метод, викликає конструктор і повертає створений об'єкт.
-   `fromXml()` приймає XML рядок, витягує потрібні дані і, оскільки у конструкторі немає обов'язкових параметрів, викликає його без них. Після цього, оскільки йому доступні приховані властивості, він надає їм значення безпосередньо. Після цього повертає готовий об'єкт.

У всіх трьох випадках, ключове слово `static` транслюється в ім'я класу, в якому код викликається. У нашому випадку `Product`

### Деструктори

```methodsynopsis
__destruct(): void
```

PHP надає концепцію деструктора, аналогічну до тієї, яка застосовується в інших ГО-мовах, таких як C++. Деструктор буде викликаний у разі звільнення всіх посилань на певний об'єкт або при завершенні скрипту (порядок виконання деструкторів не гарантується).

**Приклад #6 Приклад використання деструктора**

```php
<?php
class MyDestructableClass
{
   function __construct() {
       print "Конструктор\n";
   }

   function __destruct() {
       print "Уничтожается " . __CLASS__  . "\n";
   }
}

$obj = new MyDestructableClass();
```

Як і у випадку з конструкторами, деструктори, оголошені у батьківському класі, не викликатимуться автоматично. Для виклику деструктора батьківського класу потрібно викликати **parent::destruct()** у тілі деструктора дочірнього класу. Подібно до конструкторів, дочірній клас може успадкувати деструктор з батьківського класу, якщо він не визначений у ньому.

Деструктор буде викликатись навіть у тому випадку, якщо скрипт був зупинений за допомогою функції [exit()](function.exit.md). Виклик [exit()](function.exit.md) у деструкторі запобігає запуску всіх наступних функцій завершення.

> **Зауваження**
> 
> Деструктори, що викликаються при завершенні скрипта, викликаються після надсилання заголовків HTTP. Робоча директорія під час фази завершення скрипта може відрізнятися у деяких SAPI (наприклад, Apache).

> **Зауваження**
> 
> Спроба викинути виняток із деструктора (що викликається під час завершення скрипта) викликає фатальну помилку.