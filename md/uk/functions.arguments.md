Аргументи функції

-   [« Функції, визначені користувачем](functions.user-defined.html)
    
-   [Возврат значений »](functions.returning-values.html)
    
-   [PHP Manual](index.md)
    
-   [Функції](language.functions.md)
    
-   Аргументи функції
    

## Аргументи функції

Функція може приймати інформацію у вигляді списку аргументів, який є списком розділених комами виразів. Аргументи обчислюються ліворуч праворуч перед фактичним викликом функції (*енергійне* обчислення).

PHP підтримує передачу аргументів за значенням (за умовчанням), [передачу аргументів за посиланням](functions.arguments.html#functions.arguments.by-reference), і [значения по умолчанию](functions.arguments.html#functions.arguments.default). . [Списки аргументів змінної довжини](functions.arguments.html#functions.variable-arg-list) і [іменовані аргументи](functions.arguments.html#functions.named-arguments) також підтримуються.

**Приклад #1 Передача масиву на функцію**

```php
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
```

Починаючи з PHP 8.0.0, список аргументів функції може містити завершальну кому, яка буде проігнорована. Це корисно у випадку, коли список аргументів дуже довгий, або якщо імена змінних довжини, що підштовхує до їхнього вертикального розташування.

**Приклад #2 Список аргументів функції завершальної коми**

```php
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Эта завершающая запятая допустима только начиная с  8.0.0.
)
{
    // ...
}
?>
```

### Передача аргументів за посиланням

За замовчуванням аргументи в функцію передаються за значенням (це означає, що якщо ви зміните значення аргументу всередині функції, то поза її значенням все одно залишиться колишнім). Якщо ви хочете дозволити функції модифікувати свої аргументи, ви повинні надсилати їх за посиланням.

Якщо ви хочете, щоб аргумент завжди передавався за посиланням, ви можете вказати амперсанд (&) перед ім'ям аргументу в описі функції:

**Приклад #3 Передача аргументів за посиланням**

```php
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что ещё.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что ещё.'
?>
```

Передача значення як аргумент, який має передаватися за посиланням, є помилкою.

### Значення аргументів за умовчанням

Функція може визначати значення за промовчанням для аргументів, використовуючи синтаксис, подібний до присвоєння змінної. Значення за промовчанням використовується лише в тому випадку, якщо параметр не вказано; зокрема, зверніть увагу, що передача **`null`** *не* надає значення за замовчуванням.

**Приклад #4 Використання стандартних значень у визначенні функції**

```php
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
```

Результат виконання цього прикладу:

```
Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
```

Значення параметрів за замовчуванням можуть бути скалярні значення, масиви (array), спеціальний тип **`null`**, і, починаючи з версії PHP 8.1.0, об'єкти, які використовують синтаксис [new ClassName()](language.oop5.basic.html#language.oop5.basic.new)

**Приклад #5 Використання нескалярних типів як значень за замовчуванням**

```php
<?php
function makecoffee($types = array("капучино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капучино", "лавацца"), "в чайнике");
?>
```

**Приклад #6 Використання об'єктів як значень за замовчуванням (починаючи з PHP 8.1.0)**

```php
<?php
class DefaultCoffeeMaker {
    public function brew() {
        return 'Приготовление кофе.';
    }
}
class FancyCoffeeMaker {
    public function brew() {
        return 'Приготовление прекрасного кофе специально для вас.';
    }
}
function makecoffee($coffeeMaker = new DefaultCoffeeMaker)
{
    return $coffeeMaker->brew();
}
echo makecoffee();
echo makecoffee(new FancyCoffeeMaker);
?>
```

Значення за умовчанням має бути константним виразом, а чи не (наприклад) змінної чи викликом функції/методу класу.

Зверніть увагу, що будь-які необов'язкові аргументи мають бути вказані після будь-яких обов'язкових аргументів, інакше вони не можуть бути опущені під час виклику. Розглянемо наступний приклад:

**Приклад #7 Некоректне використання значень за замовчуванням**

```php
<?php
function makeyogurt($container = "миску", $flavour)
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $container, не $flavour
?>
```

Результат виконання цього прикладу:

```
Fatal error: Uncaught ArgumentCountError: Too few arguments
to function makeyogurt(), 1 passed in example.php on line 42
```

Тепер порівняємо його з наступним прикладом:

**Приклад #8 Коректне використання значень за замовчуванням**

```php
<?php
function makeyogurt($flavour, $container = "миску")
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $flavour
?>
```

Результат виконання цього прикладу:

```
Делаем миску с малиновым йогуртом.
```

Починаючи з PHP 8.0.0, [іменовані аргументи](functions.arguments.html#functions.named-arguments) можна використовувати для пропуску кількох необов'язкових параметрів.

**Приклад #9 Правильне використання аргументів за замовчуванням функцій**

```php
<?php
function makeyogurt($container = "миску", $flavour = "малиновым", $style = "греческим")
{
    return "Делаем $container с $flavour $style йогуртом.\n";
}
echo makeyogurt(style: "натуральным");
?>
```

Результат виконання цього прикладу:

```
Делаем миску с малиновым натуральным йогуртом.
```

Починаючи з PHP 8.0.0, оголошення обов'язкових аргументів після необов'язкових аргументів є *застарілим*. Зазвичай це можна вирішити, відмовившись від значення за замовчуванням, оскільки воно ніколи не буде використовуватися. Винятком із цього правила є аргументи виду `Type $param = null`, де **`null`** за замовчуванням робить тип, що неявно обнулюється. Таке використання залишається допустимим, хоча рекомендується використовувати явний [тип nullable](language.types.declarations.html#language.types.declarations.nullable)

**Приклад #10 Оголошення необов'язкових аргументів після обов'язкових аргументів**

```php
<?php
function foo($a = [], $b) {} // По умолчанию не используется; устарел, начиная с версии PHP 8.0.0
function foo($a, $b) {}      // Функционально эквивалентны, без уведомления об устаревании
function bar(A $a = null, $b) {} // Все еще разрешено; $a является обязательным, но допускающим значение null
function bar(?A $a, $b) {}       // Рекомендуется
?>
```

> **Зауваження**: Починаючи з PHP 7.1.0, опущення параметра, не заданого за умовчанням, викидає виняток [ArgumentCountError](class.argumentcounterror.md); у попередніх версіях це викликало попередження.

> **Зауваження**: Значення за промовчанням можна надіслати за посиланням.

### Списки аргументів змінної довжини

PHP підтримує списки аргументів змінної довжини для функцій, що визначаються користувачем за допомогою додавання крапки (`...`

> **Зауваження**: Також можна досягти аргументів змінної довжини, використовуючи функції [funcnumargs()](function.func-num-args.html) [funcgetarg()](function.func-get-arg.html) і [funcgetargs()](function.func-get-args.html). Цей метод не рекомендується, оскільки він використовувався до введення крапки (`...`

Список аргументів може містити багатокрапку (`...`), щоб показати, що функція приймає змінну кількість аргументів. Аргументи у разі будуть передані як масиву. Наприклад:

**Приклад #11 Використання `...` для доступу до аргументів**

```php
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
```

Результат виконання цього прикладу:

```
10
```

Багатокрапка (`...`) можна використовувати під час виклику функції, щоб розпакувати масив (array) або [Traversable](class.traversable.md) змінну до списку аргументів:

**Приклад #12 Використання `...` для передачі аргументів**

```php
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
```

Результат виконання цього прикладу:

```
3
3
```

Можна задати кілька аргументів у звичному вигляді, а потім додати `...`. В цьому випадку `...` помістить у масив лише аргументи, які знайшли відповідності зазначеним у оголошенні функції.

Також можна додати [оголошення типу](language.types.declarations.md) перед `...`. У цьому випадку всі аргументи, оброблені трьома крапками (`...`), повинні відповідати цьому типу параметра.

**Приклад #13 Аргументи з підказкою типу**

```php
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Это не сработает, т.к. null не является объектом DateInterval.
echo total_intervals('d', null);
?>
```

Результат виконання цього прикладу:

```
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
```

Зрештою, можна передавати аргументи [за посиланням](functions.arguments.html#functions.arguments.by-reference). Для цього перед `...` потрібно поставити амперсанд (`&`

#### Попередні версії PHP

Для вказівки того, що функція приймає змінну кількість аргументів, спеціальний синтаксис не використовується. Для доступу до аргументів необхідно використовувати функції [funcnumargs()](function.func-num-args.html) [funcgetarg()](function.func-get-arg.html) і [funcgetargs()](function.func-get-args.html)

У першому прикладі вище було показано, як встановити список аргументів змінної довжини для попередніх версій PHP:

**Приклад #14 Доступ до аргументів у попередніх версіях PHP**

```php
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
```

Результат виконання цього прикладу:

```
10
```

### Іменовані аргументи

У PHP 8.0.0 як продовження позиційних параметрів з'явилися іменовані аргументи. З їхньою допомогою аргументи функції можна передавати на ім'я параметра, а чи не з його позиції. Таким чином аргумент стає самодокументованим, незалежним від порядку та зазначеного значення за умовчанням.

Іменовані аргументи передаються шляхом додавання через двокрапки імені параметра перед його значенням. Як імена параметрів можна використовувати зарезервовані ключові слова. Ім'я параметра має бути ідентифікатором, тобто. він не може бути створений динамічно.

**Приклад #15 Синтаксис іменованого аргументу**

```php
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// НЕ поддерживается.
function_name($variableStoringParamName: $value);
?>
```

**Приклад #16 Позиційні аргументи проти іменованими аргументами**

```php
<?php
// Использование позиционных аргументов:
array_fill(0, 100, 50);

// Использование именованных аргументов:
array_fill(start_index: 0, count: 100, value: 50);
?>
```

Порядок, у якому передаються іменовані аргументи, немає значення.

**Приклад #17 Той самий приклад, як і вище, але з іншим порядком параметрів**

```php
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
```

Іменовані аргументи можна поєднувати з позиційними. У цьому випадку іменовані аргументи мають слідувати після позиційних аргументів. Також можна передати лише частину необов'язкових аргументів функції, незалежно від їх порядку.

**Приклад #18 Об'єднання іменованих аргументів із позиційними аргументами**

```php
<?php
htmlspecialchars($string, double_encode: false);
// То же самое
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
```

Передача одного і того ж параметра кілька разів призводить до викидання винятку Error.

**Приклад #19 Помилка, що виникає при передачі одного і того ж параметра кілька разів**

```php
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
```

Починаючи з PHP 8.1.0 можна використовувати іменовані аргументи після розпакування аргументів. Іменований аргумент *не повинен* перевизначати вже розпаковані аргументи.

**Приклад #20 Приклад використання іменованих аргументів після розпакування**

```php
<?php
function foo($a, $b, $c = 3, $d = 4) {
  return $a + $b + $c + $d;
}
var_dump(foo(...[1, 2], d: 40)); // 46
var_dump(foo(...['b' => 2, 'a' => 1], d: 40)); // 46
var_dump(foo(...[1, 2], b: 20)); // Фатальная ошибка. Именованный аргумент $b переопределяет предыдущий аргумент
?>
```