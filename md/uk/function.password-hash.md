---
navigation:
  - function.password-get-info.md: « password\_get\_info
  - function.password-needs-rehash.md: password\_needs\_rehash »
  - index.md: PHP Manual
  - ref.password.md: Функції хешування паролів
title: password\_hash
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# password\_hash

(PHP 5 >= 5.5.0, PHP 7, PHP 8)

password\_hash — Створює хеш пароля

### Опис

```methodsynopsis
password_hash(string $password, string|int|null $algo, array $options = []): string
```

Функция**password\_hash()** створює хеш пароля, використовуючи сильний незворотний алгоритм хешування.

Підтримуються такі алгоритми:

-   \*\*`PASSWORD_DEFAULT`\*\*- буде обрано алгоритм bcrypt (за замовчуванням з PHP 5.5.0). Зверніть увагу, алгоритм може змінитися на сильніший, коли такий додасться до PHP. При зміні алгоритму та довжина результату також може змінитися. Тому довжину поля для зберігання бази даних краще встановлювати більше 60 символів (255 символів буде хорошим значенням).
-   **`PASSWORD_BCRYPT`**— буде обрано алгоритм**`CRYPT_BLOWFISH`**. . Генерує стандартний хеш з ідентифікатором "$2y$", сумісний з тим, що генерує функція [crypt()](function.crypt.md). В результаті буде згенеровано рядок довжиною 60 символів або\*\*`false`\*\*в случае возникновения ошибки.
-   \*\*`PASSWORD_ARGON2I`\*\*- буде обрано алгоритм хешування Argon2i. Цей алгоритм буде доступний, тільки якщо PHP зібраний за допомогою Argon2.
-   \*\*`PASSWORD_ARGON2ID`\*\*- буде обрано алгоритм хешування Argon2id. Цей алгоритм буде доступний, тільки якщо PHP зібраний за допомогою Argon2.

Опції, що підтримуються для **`PASSWORD_BCRYPT`** :

-   `salt`(string) – для самостійного завдання солі для хешування. Зверніть увагу, що це призведе до перевизначення і запобігатиме автоматичному створенню солі.
    
    Якщо не поставлено, то функція\*\*password\_hash()\*\*буде генерувати випадкову сіль для кожного пароля, що хешується. Це кращий режим роботи.
    
    **Увага**
    
    Ця опція оголошена застарілою. Рекомендується використовувати сіль, що автоматично генерується. Починаючи з PHP 8.0.0, явно задана сіль ігнорується.
    
-   `cost`(int) - задає алгоритмічну складність. Приклад з цією опцією можна переглянути на сторінці, присвяченій функції[crypt()](function.crypt.md)
    
    Якщо не встановлено, то буде вибрано значення за замовчуванням:`10`. Це хороша базова вартість, але її можна збільшити, якщо дозволяє продуктивність устаткування.
    

Опції, що підтримуються для **`PASSWORD_ARGON2I`** і **`PASSWORD_ARGON2ID`** :

-   `memory_cost`(int) – максимальний розмір пам'яті (у кілобайтах), яка буде використана для обчислення хешу Argon2. За промовчанням буде вибрано значення константи\*\*`PASSWORD_ARGON2_DEFAULT_MEMORY_COST`\*\*
    
-   `time_cost`(int) – максимально можливий час, який можна витратити на обчислення хешу Argon2. За промовчанням буде вибрано значення константи\*\*`PASSWORD_ARGON2_DEFAULT_TIME_COST`\*\*
    
-   `threads`(int) — кількість потоків, які можна використовувати для обчислення хешу Argon2. За промовчанням буде вибрано значення константи\*\*`PASSWORD_ARGON2_DEFAULT_THREADS`\*\*
    
    **Увага**
    
    Доступно лише тоді, коли в PHP доступний модуль libargon2, але не при реалізації libsodium.
    

### Список параметрів

`password`

Користувальницький пароль.

**Застереження**

Использование алгоритма\*\*`PASSWORD_BCRYPT`\*\* призведе до обрізання поля `password` до максимальної довжини - 72 байти.

`algo`

[Константа](password.constants.md), Що позначає алгоритм хешування пароля, що використовується.

`options`

Асоціативний масив із опціями. За документацією щодо підтримуваних опцій для кожного алгоритму зверніться до розділу [Константи алгоритмів хешування паролів](password.constants.md)

Якщо не задано, то буде використано стандартну вартість, і сіль буде згенерована автоматично.

### Значення, що повертаються

Повертає пароль хешування.

Вибраний алгоритм, вартість та сіль буде повернуто як частину хешу. Таким чином, інформація, необхідна для перевірки хеша, буде включена. Це дозволить функції [password\_verify()](function.password-verify.md) перевіряти хеш без окремого зберігання інформації про солі та алгоритм.

### список змін

| Версия | Опис |
| --- | --- |
| 8.0.0 | **password\_hash()** більше не повертає значення **`false`** у разі виникнення помилки. Натомість буде викинуто виняток [ValueError](class.valueerror.md)якщо алгоритм хешування пароля недійсний, або [Error](class.error.md), якщо хешування пароля не вдалося через невідому помилку. |
| 8.0.0 | Параметр`algo` тепер припускає значення **`null`** |
| 7.4.0 | Параметр`algo` тепер чекає рядок (string), але все ще приймає число (int) зворотної сумісності. |
| 7.4.0 | Модуль sodium забезпечує альтернативну реалізацію паролів Argon2. |
| 7.3.0 | Додано підтримку алгоритму хешування паролів Argon2id за допомогою **`PASSWORD_ARGON2ID`** |
| 7.2.0 | Додано підтримку хешуючого алгоритму Argon2i за допомогою **`PASSWORD_ARGON2I`** |

### Приклади

**Приклад #1 Приклад використання** password\_hash()\*\*\*\*

```php
<?php
/**
 * Мы просто хотим захешировать пароль с настройками по умолчанию.
 * Значит, будет выбран алгоритм BCRYPT и результат будет длиной 60 символов.
 *
 * Помните, что алгоритм по умолчанию может измениться в будущем, так что
 * имеет смысл заранее позаботиться о том, чтобы система хранения хешей
 * смогла хранить более 60 символов (а лучше 255)
 */
echo password_hash("rasmuslerdorf", PASSWORD_DEFAULT);
?>
```

Висновок наведеного прикладу буде схожим на:

```
$2y$10$.vGA1O9wmRjrwAVXD98HNOgsNpDczlqm3Jq7KnEd1rVAGv3Fykk1a
```

**Приклад #2 Приклад використання** password\_hash()\*\* з ручним завданням вартості\*\*

```php
<?php
/**
 * Тут мы увеличиваем алгоритмическую стоимость BCRYPT до 12.
 * Но это никак не скажется на длине полученного результата, она останется 60 символов
 */
$options = [
    'cost' => 12,
];
echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options);
?>
```

Висновок наведеного прикладу буде схожим на:

```
$2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K
```

**Приклад #3 Приклад пошуку хорошого значення вартості функції **password\_hash()****

```php
<?php
/**
 * Данный код замерит скорость выполнения операции с разными значениями алгоритмической сложности хеширования
 * на вашем сервере и определит
 * его максимальное значение, не приводящее к деградации производительности. Хорошее базовое
 * значение — 10, но если ваш сервер достаточно мощный, то можно
 * задать и больше. Данный скрипт ищет максимальное значение, при котором
 * хеширование уложится в значение ≤ 350 миллисекундам, что считается приемлемой задержкой
 * для систем, которые обрабатывают интерактивные входы.
 */
$timeTarget = 0.350; // 350 миллисекунд

$cost = 8;
do {
    $cost++;
    $start = microtime(true);
    password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
    $end = microtime(true);
} while (($end - $start) < $timeTarget);

echo "Оптимальная стоимость: " . $cost;
?>
```

Висновок наведеного прикладу буде схожим на:

```
Оптимальная стоимость: 12
```

**Приклад #4 Приклад использования функции**password\_hash()**с Argon2i**

```php
<?php
echo 'Хеш Argon2i: ' . password_hash('rasmuslerdorf', PASSWORD_ARGON2I);
?>
```

Висновок наведеного прикладу буде схожим на:

```
Хеш Argon2i: $argon2i$v=19$m=1024,t=2,p=2$YzJBSzV4TUhkMzc3d3laeg$zqU/1IN0/AogfP4cmSJI1vc8lpXRW9/S0sYY2i2jHT0
```

### Примітки

**Застереження**

Рекомендується використовувати автоматичну генерацію солі. Дана функція самостійно створить хорошу сіль, якщо ви не заважатимете їй підсовуючи свою.

Як було зазначено вище, опція `salt` була оголошена застарілою в PHP 7.0 і викликатиме відповідне попередження. Підтримка ручного завдання солі була видалена у PHP 8.0.

> **Зауваження** :
> 
> Рекомендується протестувати цю функцію на обладнанні для визначення оптимального значення алгоритмічної складності. Переконайтеся, що з вибраною складністю функція виконується швидше за 350 мілісекунд для інтерактивних систем. Скрипт у наведеному вище прикладі допоможе вибрати оптимальне значення.

> **Зауваження**: Оновлення підтримуваних алгоритмів для цієї функції (або зміна значення за замовчуванням) повинні дотримуватися правил:
> 
> -   Будь-який новий алгоритм повинен бути присутнім у ядрі як мінімум 1 повний реліз PHP для того, щоб його можна було встановити за замовчуванням. Таким чином, якщо, наприклад, новий алгоритм був доданий в 7.5.5, то задати за замовчуванням його можна буде тільки в 7.7 (7.6 буде тим самим повним релізом, протягом якого він має бути присутнім, від 7.6.0 до 7.7.0 ). Але якщо новий алгоритм додано до 7.6.0, його також можна буде задати за замовчуванням у версії 7.7.0.
> -   Алгоритм за замовчуванням може бути змінений тільки в повному релізі (7.3.0, 8.0.0 і т. д.), але не в проміжних. Єдиним винятком є ​​критична вразливість, знайдена в поточному алгоритмі.

### Дивіться також

-   [password\_verify()](function.password-verify.md) \- Перевіряє, чи пароль хешу відповідає
-   [password\_needs\_rehash()](function.password-needs-rehash.md) \- Перевіряє, що зазначений хеш відповідає заданим опціям
-   [crypt()](function.crypt.md) \- Необоротне хешування рядка
-   [sodium\_crypto\_pwhash\_str()](function.sodium-crypto-pwhash-str.md) \- Отримати ASCII-кодований хеш
