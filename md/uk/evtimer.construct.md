---
navigation:
  - evtimer.again.html: '« EvTimer::again'
  - evtimer.createstopped.html: 'EvTimer::createStopped »'
  - index.html: PHP Manual
  - class.evtimer.html: EvTimer
title: 'EvTimer::construct'
---
# EvTimer::construct

(PECL ev >= 0.2.0)

EvTimer::construct - Конструктор об'єкта спостерігача EvTimer

### Опис

public **EvTimer::construct**  
float `$after`  
float `$repeat`  
[callable](language.types.callable.html) `$callback`  
[mixed](language.types.declarations.html#language.types.declarations.mixed) `$data` **`null`**  
int `$priority`

Конструктор об'єкта спостерігача EvTimer.

### Список параметрів

`after`

Налаштовує таймер для запуску через `after` секунд.

`repeat`

Якщо час повтору дорівнює **`0.0`**, то він буде автоматично зупинено після закінчення часу очікування. Якщо позитивне, таймер буде автоматично налаштований на повторний запуск кожні повторювані секунди, доки не буде зупинено вручну.

`callback`

Дивіться [Спостерігачі callback-функцій](ev.watcher-callbacks.html)

`data`

Дані користувача, пов'язані зі спостерігачем.

`priority`

[Приоритет наблюдателя](class.ev.html#ev.constants.watcher-pri)

### Приклади

**Приклад #1 Прості таймери**

```php
<?php
// Создаёт и запускает таймер через 2 секунды
$w1 = new EvTimer(2, 0, function () {
    echo "2 секунды прошло\n";
});

// Создаёт и запускает таймер через 2 секунды, повторяя каждую секунду
// пока мы не остановим его вручную
$w2 = new EvTimer(2, 1, function ($w) {
    echo "вызывается каждую секунду, запускается через 2 секунды\n";
    echo "итерация = ", Ev::iteration(), PHP_EOL;

    // Останавливаем наблюдателя после 5 итераций
    Ev::iteration() == 5 and $w->stop();
    // Останавливаем наблюдателя, если дальнейшие вызовы вызовут более 10 итераций
    Ev::iteration() >= 10 and $w->stop();
});

// Создаём остановленный таймер. Он будет неактивным, пока мы не запустим его сами
$w_stopped = EvTimer::createStopped(10, 5, function($w) {
    echo "Callback-функция таймера, созданного как остановленный\n";

    // Останавливаем наблюдателя после 2 итераций
    Ev::iteration() >= 2 and $w->stop();
});

// Цикл до вызова Ev::stop() или остановки всех наблюдателей
Ev::run();

// Запускаем и смотрим, работает ли он
$w_stopped->start();
echo "Запустили одну итерацию\n";
Ev::run(Ev::RUN_ONCE);

echo "Перезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем\n";
$w2->again();
Ev::run(Ev::RUN_NOWAIT);

$w = new EvTimer(10, 0, function() {});
echo "Запуск заблокированного цикла\n";
Ev::run();
echo "END\n";
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
2 секунды прошло
вызывается каждую секунду, запускается через 2 секунды
итерация = 1
вызывается каждую секунду, запускается через 2 секунды
итерация = 2
вызывается каждую секунду, запускается через 2 секунды
итерация = 3
вызывается каждую секунду, запускается через 2 секунды
итерация = 4
вызывается каждую секунду, запускается через 2 секунды
итерация = 5
Запустили одну итерацию
Callback-функция таймера, созданного как остановленный
Перезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем
Запуск заблокированного цикла
вызывается каждую секунду, запускается через 2 секунды
итерация = 8
вызывается каждую секунду, запускается через 2 секунды
итерация = 9
итерация каждую секунду, запускается через 2 секунды
итерация = 10
END
```

### Дивіться також

-   [EvTimer::createStopped()](evtimer.createstopped.html) - створює зупинений спостерігач EvTimer
-   [EvPeriodic](class.evperiodic.html)
-   [» evtimer - відносний і необов'язково повторюваний час очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti)
-   [» Будьте обережні з часом очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts)
