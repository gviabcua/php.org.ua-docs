---
navigation:
  - evtimer.again.md: '« EvTimer::again'
  - evtimer.createstopped.md: 'EvTimer::createStopped »'
  - index.md: PHP Manual
  - class.evtimer.md: EvTimer
title: 'EvTimer::\_\_construct'
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# EvTimer::\_\_construct

(PECL ev >= 0.2.0)

EvTimer::\_\_construct - Конструктор об'єкта спостерігача EvTimer

### Опис

public**EvTimer::\_\_construct**  
float`$after`  
float`$repeat`  
[callable](language.types.callable.md) `$callback`  
[mixed](language.types.declarations.md#language.types.declarations.mixed) `$data` = **`null`**  
int`$priority` =  
) .

Конструктор об'єкта спостерігача EvTimer.

### Список параметрів

`after`

Налаштовує таймер для запуску через `after`секунд.

`repeat`

Якщо час повтору дорівнює **`0.0`**, то він буде автоматично зупинено після закінчення часу очікування. Якщо позитивне, таймер буде автоматично налаштований на повторний запуск кожні повторювані секунди, доки не буде зупинено вручну.

`callback`

Смотрите[Спостерігачі callback-функцій](ev.watcher-callbacks.md)

`data`

Ці дані, пов'язані зі спостерігачем.

`priority`

[Пріоритет спостерігача](class.ev.md#ev.constants.watcher-pri)

### Приклади

**Приклад #1 Прості таймери**

```php
<?php
// Создаёт и запускает таймер через 2 секунды
$w1 = new EvTimer(2, 0, function () {
    echo "2 секунды прошло\n";
});

// Создаёт и запускает таймер через 2 секунды, повторяя каждую секунду
// пока мы не остановим его вручную
$w2 = new EvTimer(2, 1, function ($w) {
    echo "вызывается каждую секунду, запускается через 2 секунды\n";
    echo "итерация = ", Ev::iteration(), PHP_EOL;

    // Останавливаем наблюдателя после 5 итераций
    Ev::iteration() == 5 and $w->stop();
    // Останавливаем наблюдателя, если дальнейшие вызовы вызовут более 10 итераций
    Ev::iteration() >= 10 and $w->stop();
});

// Создаём остановленный таймер. Он будет неактивным, пока мы не запустим его сами
$w_stopped = EvTimer::createStopped(10, 5, function($w) {
    echo "Callback-функция таймера, созданного как остановленный\n";

    // Останавливаем наблюдателя после 2 итераций
    Ev::iteration() >= 2 and $w->stop();
});

// Цикл до вызова Ev::stop() или остановки всех наблюдателей
Ev::run();

// Запускаем и смотрим, работает ли он
$w_stopped->start();
echo "Запустили одну итерацию\n";
Ev::run(Ev::RUN_ONCE);

echo "Перезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем\n";
$w2->again();
Ev::run(Ev::RUN_NOWAIT);

$w = new EvTimer(10, 0, function() {});
echo "Запуск заблокированного цикла\n";
Ev::run();
echo "END\n";
?>
```

Висновок наведеного прикладу буде схожим на:

```
2 секунды прошло
вызывается каждую секунду, запускается через 2 секунды
итерация = 1
вызывается каждую секунду, запускается через 2 секунды
итерация = 2
вызывается каждую секунду, запускается через 2 секунды
итерация = 3
вызывается каждую секунду, запускается через 2 секунды
итерация = 4
вызывается каждую секунду, запускается через 2 секунды
итерация = 5
Запустили одну итерацию
Callback-функция таймера, созданного как остановленный
Перезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем
Запуск заблокированного цикла
вызывается каждую секунду, запускается через 2 секунды
итерация = 8
вызывается каждую секунду, запускается через 2 секунды
итерация = 9
итерация каждую секунду, запускается через 2 секунды
итерация = 10
END
```

### Дивіться також

-   [EvTimer::createStopped()](evtimer.createstopped.md) \- створює зупинений спостерігач EvTimer
-   [EvPeriodic](class.evperiodic.md)
-   [» ev\_timer - відносний і необов'язково повторюваний час очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti)
-   [» Будьте обережні з часом очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts)
