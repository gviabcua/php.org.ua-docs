- [«EvTimer::again](evtimer.again.md)
- [EvTimer::createStopped »](evtimer.createstopped.md)

- [PHP Manual](index.md)
- [EvTimer](class.evtimer.md)
- Конструктор об'єкта спостерігача EvTimer

# EvTimer::\_\_construct

(PECL ev \>= 0.2.0)

EvTimer::\_\_construct - Конструктор об'єкта спостерігача EvTimer

### Опис

public **EvTimer::\_\_construct**(
float `$after`,
float `$repeat`,
[callable](language.types.callable.md) `$callback` ,

[mixed](language.types.declarations.md#language.types.declarations.mixed)
`$data` = **`null`** ,
int `$priority` = 0
)

Конструктор об'єкта спостерігача EvTimer.

### Список параметрів

`after`
Налаштовує таймер для запуску через секунди.

`repeat`
Якщо час повтору дорівнює **`0.0`**, то він буде автоматично зупинено
після закінчення часу очікування. Якщо позитивне, таймер буде
автоматично налаштований на повторний запуск кожні повторювані секунди,
доки не буде зупинено вручну.

`callback`
Дивіться [Наблюдатели callback-функцій](ev.watcher-callbacks.md) .

`data`
Користувальницькі дані, пов'язані зі спостерігачем.

`priority`
[Пріоритет спостерігача](class.ev.md#ev.constants.watcher-pri)

### Приклади

**Приклад #1 Прості таймери**

` <?php// Створює і запускає таймер через 2 секунди$w1 = new EvTimer(2, 0, function () {    echo "2 секунди пройшло
";});// Создаёт и запускает таймер через 2 секунды, повторяя каждую секунду// пока мы не остановим его вручную$w2 = new EvTimer(2, 1, function ($w) {    echo "вызывается каждую секунду, запускается через 2 секунди
";    echo "итерация = ", Ev::iteration(), PHP_EOL;    // Останавливаем наблюдателя после 5 итераций    Ev::iteration() == 5 and $w->stop();    // Останавливаем наблюдателя, если дальнейшие вызовы викличуть більше 10 ітерацій    Ev::iteration() >= 10 and $w->stop();});// Створюємо зупинений таймер. Він буде неактивним, по , 5, function($w) {    echo "Callback-функція таймера, створеного як зупинений
";    // Зупиняємо спостерігача після 2 ітерацій    Ev::iteration() >= 2 and $w->stop();});// Цикл до викликів| ;// Запускаємо і дивимось, працює ли он$w_stopped->start();echo "Запустили одну ітерацію
";Ev::run(Ev::RUN_ONCE);echo "Перезапустили другий спостерігач і пробуємо обробити ті те ж події, але не блокуємо
";$w2->again();Ev::run(Ev::RUN_NOWAIT);$w = new EvTimer(10, 0, function() {});echo "Запуск заблокованого цикла
";Ev::run();echo "END
";?> `

Результатом виконання цього прикладу буде щось подібне:

2 секунди пройшло
викликається кожну секунду, запускається через 2 секунди
ітерація = 1
викликається кожну секунду, запускається через 2 секунди
ітерація = 2
викликається кожну секунду, запускається через 2 секунди
ітерація = 3
викликається кожну секунду, запускається через 2 секунди
ітерація = 4
викликається кожну секунду, запускається через 2 секунди
ітерація = 5
Запустили одну ітерацію
Callback-функція таймера, створеного як зупинений
Перезапустили другий спостерігач і пробуємо обробити ті самі події, але не блокуємо
Запуск заблокованого циклу
викликається кожну секунду, запускається через 2 секунди
ітерація = 8
викликається кожну секунду, запускається через 2 секунди
ітерація = 9
ітерація кожну секунду, запускається через 2 секунди
ітерація = 10
END

### Дивіться також

- [EvTimer::createStopped()](evtimer.createstopped.md) - Створює
зупинений спостерігач EvTimer
- [EvPeriodic](class.evperiodic.md)
- [» ev_timer - відносний і необов'язково повторюваний час очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti)
- [» Будьте обережні з часом ожидания](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts)
