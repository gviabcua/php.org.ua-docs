Виводить рядкову виставу внутрішньої структури zval

-   [« boolval](function.boolval.html)
    
-   [doubleval »](function.doubleval.html)
    
-   [PHP Manual](index.html)
    
-   [Функції для роботи зі змінними](ref.var.html)
    
-   Виводить рядкову виставу внутрішньої структури zval
    

# debugкликавdump

(PHP 4> = 4.2.0, PHP 5, PHP 7, PHP 8)

debugкликавdump — Виводить рядкову виставу внутрішньої структури zval

### Опис

```methodsynopsis
debug_zval_dump(mixed $value, mixed ...$values): void
```

Виводить на висновок рядкове уявлення внутрішньої структури zval (значення Zend). Це переважно корисно для розуміння або налагодження деталей реалізації Zend Engine або модулів PHP.

### Список параметрів

`value`

Оброблювана змінна.

`values`

Наступні змінні або значення обробки.

### Значення, що повертаються

Функція не повертає значення після виконання.

### Приклади

**Приклад #1 Приклад використання **debugкликавdump()****

```php
<?php
$var1 = 'Hello';
$var1 .= ' World';
$var2 = $var1;

debug_zval_dump($var1);
?>
```

Результат виконання цього прикладу:

```
string(11) "Hello World" refcount(3)
```

> **Зауваження** **Розуміння `refcount`**
> 
> Значення `refcount`, що показується цією функцією, може бути несподіваним без детального розуміння реалізації двигуна.
> 
> Zend Engine використовує підрахунок посилань для двох різних цілей:
> 
> -   Оптимізація використання пам'яті за допомогою методу, званого "копіювання при записі", коли кілька змінних, що містять одне й те саме значення, вказують на ту саму копію в пам'яті. Коли кожна змінна змінюється, вона вказує на нову копію в пам'яті, а лічильник посилань на оригінал зменшується на 1.
> -   Відстеження змінних, які були призначені або передані за посиланням (див. [Объяснение ссылок](language.references.html)). Цей лічильник посилань зберігається в окремому посиланні zval, що вказує на zval для поточного значення. Цей додатковий zval в даний час не відображається у **debugкликавdump()**
> 
> Оскільки **debugкликавdump()** приймає свої вхідні дані як звичайні параметри, що передаються за значенням, для їх передачі буде використовуватися метод копіювання під час запису: замість копіювання даних лічильник посилань буде збільшено на одиницю на час існування виклику функції. Якщо функція змінила параметр після його отримання, буде зроблено копію; оскільки це не так, покаже лічильник посилань на один вище, ніж у зухвалій області.
> 
> Передача параметрів також запобігає відображенню змінних **debugкликавdump()**, які були призначені на засланні. Для ілюстрації розглянемо трохи змінену версію наведеного вище прикладу:
> 
> ```php
> <?php
> $var1 = 'Hello';
> $var1 .= ' World';
> // Укажите три переменные как ссылки на одно и то же значение
> $var2 =& $var1;
> $var3 =& $var1;
> 
> debug_zval_dump($var1);
> ?>
> ```
> 
> Результат виконання цього прикладу:
> 
> ```
> string(11) "Hello World" refcount(2)
> ```
> 
> Хоча $var1, $var2 і $var3 пов'язані як посилання, тільки *value* передається в **debugкликавdump()**. Це значення використовується один раз набором посилань і один раз всередині функції \*\*debugкликавdump()\*\*тому лічильник посилань дорівнює 2.
> 
> Подальші складності виникають через оптимізацію, зроблену в двигуні для різних типів даних. Деякі типи, такі як цілі числа, не використовують копіювання при записі, тому не показують лічильник посилань взагалі. В інших випадках refcount показує додаткові копії, які використовуються всередині, наприклад, коли літерний рядок або масив зберігається як частина інструкції коду.

### Дивіться також

-   [vardump()](function.var-dump.html) - Виводить інформацію про змінну
-   [debugbacktrace()](function.debug-backtrace.html) - Виводить стек викликів функцій у масив
-   "[Ссылки. Разъяснения](language.references.html)"
-   "[» Ссылки. Разъяснения (от Derick Rethans)](http://derickrethans.nl/php_references_article.php)"