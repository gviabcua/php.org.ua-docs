---
navigation:
  - function.boolval.md: « boolval
  - function.doubleval.md: doubleval »
  - index.md: PHP Manual
  - ref.var.md: Функції для роботи зі змінними
title: debug\_zval\_dump
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# debug\_zval\_dump

(PHP 4 >= 4.2.0, PHP 5, PHP 7, PHP 8)

debug\_zval\_dump — Виводить рядкову виставу внутрішньої структури zval

### Опис

```methodsynopsis
debug_zval_dump(mixed $value, mixed ...$values): void
```

Виводить на висновок рядкове уявлення внутрішньої структури zval (значення Zend). Це переважно корисно для розуміння або налагодження деталей реалізації Zend Engine або модулів PHP.

### Список параметрів

`value`

Оброблювана змінна.

`values`

Наступні змінні або значення обробки.

### Значення, що повертаються

Функція не повертає значення після виконання.

### Приклади

**Приклад #1 Приклад використання** debug\_zval\_dump()\*\*\*\*

```php
<?php
$var1 = 'Hello';
$var1 .= ' World';
$var2 = $var1;

debug_zval_dump($var1);
?>
```

Результат виконання наведеного прикладу:

```
string(11) "Hello World" refcount(3)
```

> **Зауваження** **Понимание`refcount`**
> 
> Значение`refcount`, що показується цією функцією, може бути несподіваним без детального розуміння реалізації двигуна.
> 
> Zend Engine використовує підрахунок посилань для двох різних цілей:
> 
> -   Оптимізація використання пам'яті за допомогою методу, званого "копіювання при записі", коли кілька змінних, що містять одне й те саме значення, вказують на ту саму копію в пам'яті. Коли кожна змінна змінюється, вона вказує на нову копію в пам'яті, а лічильник посилань на оригінал зменшується на 1.
> -   Відстеження змінних, які були призначені або передані за посиланням (див.[Пояснення посилань](language.references.md)). Цей лічильник посилань зберігається в окремому посиланні zval, що вказує на zval для поточного значення. Цей додатковий zval в даний час не відображається у**debug\_zval\_dump()**
> 
> Оскільки **debug\_zval\_dump()** приймає свої вхідні дані як звичайні параметри, що передаються за значенням, для їх передачі буде використовуватися метод копіювання під час запису: замість копіювання даних лічильник посилань буде збільшено на одиницю на час існування виклику функції. Якщо функція змінила параметр після його отримання, буде зроблено копію; оскільки це не так, покаже лічильник посилань на один вище, ніж у зухвалій області.
> 
> Передача параметрів також запобігає відображенню змінних **debug\_zval\_dump()**, які були призначені на засланні. Для ілюстрації розглянемо трохи змінену версію наведеного вище прикладу:
> 
> ```php
> <?php
> $ var1 = 'Hello';
> $ var1 .= 'World';
> // Вкажіть три змінні як посилання на те саме значення
> $var2 =& $var1;
> $var3 =& $var1;
> 
> debug_zval_dump($var1);
> ?>
> ```
> 
> Результат виконання наведеного прикладу:
> 
> ```
> string(11) "Hello World" refcount(2)
> ```
> 
> Хоча $var1, $var2 і $var3 пов'язані як посилання, тільки *value* передається в **debug\_zval\_dump()**. Це значення використовується один раз набором посилань і один раз всередині функції **debug\_zval\_dump()**, Тому лічильник посилань дорівнює 2.
> 
> Подальші складності виникають через оптимізацію, зроблену в двигуні для різних типів даних. Деякі типи, такі як цілі числа, не використовують копіювання при записі, тому не показують лічильник посилань взагалі. В інших випадках refcount показує додаткові копії, які використовуються всередині, наприклад, коли літерний рядок або масив зберігається як частина інструкції коду.

### Дивіться також

-   [var\_dump()](function.var-dump.md) \- Виводить інформацію про змінну
-   [debug\_backtrace()](function.debug-backtrace.md) \- Генерує стек викликів функцій
-   "[Посилання. Роз'яснення](language.references.md)"
-   "[» Посилання. Роз'яснення (від Derick Rethans)](http://derickrethans.nl/php_references_article.php)"
