---
navigation:
  - function.require.md: « require
  - function.require-once.md: require\_once »
  - index.md: PHP Manual
  - language.control-structures.md: Керуючі конструкції
title: include
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## include

(PHP 4, PHP 5, PHP 7, PHP 8)

Вираз `include` включає та виконує зазначений файл.

Документація нижче також відноситься до виразу [require](function.require.md)

Файли включаються виходячи зі шляху зазначеного файлу, або, якщо шлях не вказано, використовується шлях, вказаний у директиві [include\_path](ini.core.md#ini.include-path). Якщо файл не знайдено в [include\_path](ini.core.md#ini.include-path) `include` спробує перевірити директорію, в якій знаходиться поточний скрипт і поточну робочу директорію перед тим, як видати помилку. Конструкція `include` видасть **`E_WARNING`**, если не сможет найти файл; поведение отлично от[require](function.require.md), який видасть **`E_ERROR`**

Обратите внимание, что и`include`и`require` видають додаткову помилку рівня **`E_WARNING`**, якщо до файлу неможливо отримати доступ, перед тим, як видати останню помилку рівня \*\*`E_WARNING`**или**`E_ERROR`\*\*соответственно.

Якщо шлях вказаний - абсолютний (починається з літери диска або з `\` у Windows або з в Unix/Linux системах) або щодо поточної директорії (починається з или `.. .` [include\_path](ini.core.md#ini.include-path) буде проігноровано взагалі. Наприклад, якщо ім'я файлу починається з `../`, парсер шукатиме в батьківській директорії запитаний файл.

Для додаткової інформації про те, як PHP обробляє файли та шляхи, що включаються, дивіться документацію для директиви [include\_path](ini.core.md#ini.include-path)

Коли файл вмикається, його код успадковує ту ж [область видимості змінних](language.variables.scope.md), як і рядок, де сталося включення. Всі змінні, доступні на цьому рядку у файлі, що включають, будуть також доступні у файлі, що включається. Проте всі функції та класи, оголошені у файлі, що включається, мають глобальну область видимості.

**Приклад #1 Простий приклад `include`**

```php
vars.php
<?php

$color = 'зелёное';
$fruit = 'яблоко';

?>

test.php
<?php

echo "Одно $color $fruit"; // Одно

include 'vars.php';

echo "Одно $color $fruit"; // Одно зелёное яблоко

?>
```

Якщо включення відбувається всередині функції файлу, тоді весь код, що міститься в файлі, буде поводитися так, ніби він був визначений всередині цієї функції. Тобто він буде в тій же області видимості змінних цієї функції. Винятком до цього правила є [магічні константи](language.constants.predefined.md), які виконуються парсером перед тим, як відбувається увімкнення.

**Приклад #2 Увімкнення функції**

```php
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "Одно $color $fruit";
}

/* vars.php в той же области видимости, что и foo(),  *
* поэтому $fruit НЕ будет доступен за пределами этой области     *
* $color доступен, поскольку мы объявили переменную глобальной */

foo();                    // Одно зелёное яблоко
echo "Одно $color $fruit";   // Одно зелёное

?>
```

Коли файл увімкнеться, парсинг у режимі PHP-коду припиняється і перемикається в режим HTML на початку вказаного файлу і продовжується знову наприкінці. З цієї причини будь-який код всередині файлу, який повинен бути виконаний як код PHP, повинен бути укладений в [коректні теги початку та кінця PHP-коду](language.basic-syntax.phpmode.md)

Якщо "[обгортки URL include](filesystem.configuration.md#ini.allow-url-include)" включені в PHP, ви можете також вказати файл для включення через URL (за допомогою HTTP або інших обробників, що підтримуються - дивіться [Підтримувані протоколи та обгортки](wrappers.md) для списку протоколів замість локального шляху. Якщо цільовий сервер інтерпретує вказаний файл як код PHP, змінні можуть бути передані до файлу, що включається за допомогою рядка URL-запиту при використанні HTTP GET. Це зовсім не те саме, що включення файлу та успадкування батьківської області видимості; скрипт виконується на віддаленому сервері, і результат потім включається до локального скрипту.

**Пример #3 Пример`include`через HTTP**

```php
<?php

/* В этом примере предполагается, что www.example.com настроен на обработку .php
* файлов, но не .txt. Также, 'Сработает' обозначает, что переменные
* $foo и $bar доступны внутри включаемого файла. */

// Не сработает; file.txt не обрабатывается www.example.com как PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Не сработает; будет искать файл 'file.php?foo=1&bar=2' в
// локальной файловой системе.
include 'file.php?foo=1&bar=2';

// Сработает.
include 'http://www.example.com/file.php?foo=1&bar=2';
?>
```

**Увага**

# Попередження безпеки

Видалені файли можуть бути оброблені на віддаленій стороні (залежно від розширення файлу і того, що віддалений сервер виконує скрипти PHP чи ні), але це все одно має робити коректний скрипт PHP, тому що він буде оброблений вже на локальному сервері. Якщо файл з віддаленого сервера має бути оброблений і відображений його результат, набагато ефективно скористатися функцією [readfile()](function.readfile.md) В іншому випадку слід дотримуватися особливої ​​обережності, щоб убезпечити віддалений скрипт для отримання коректного та бажаного коду.

Смотрите также раздел[Видалені файли](features.remote-files.md), функції [fopen()](function.fopen.md) і [file()](function.file.md) для додаткової інформації.

Обробка значень, що повертаються: оператор `include` повертає значення `FALSE` у разі виникнення помилки та видає попередження. Успішні включення, поки це не перевизначено у файлі, повертають значення . Можливо виконати вираз [return](function.return.md) всередині файлу, щоб завершити процес виконання в цьому файлі і повернутися до виконання файлу, що включає. Крім того, можливо повернути значення з файлів, що включаються. Ви можете отримати значення включення, якби викликали звичайну функцію. Хоча це неможливо при включенні видаленого файлу, тільки якщо виведення видаленого файлу не містить [коректні теги початку та кінця PHP коду](language.basic-syntax.phpmode.md) (Так само, як і локальний файл). Ви можете визначити необхідні змінні всередині цих тегів і вони будуть представлені залежно від того, який файл вимкнено.

Так как`include` - це спеціальна мовна конструкція, круглі дужки не є обов'язковими навколо аргументу. Будьте уважні при порівнянні значення, що повертається.

**Приклад #4 Порівняння значення, що повертається при include**

```php
<?php
// не сработает, интерпретируется как include(('vars.php') == TRUE), то есть include('1')
if (include('vars.php') == TRUE) {
    echo 'OK';
}

// сработает
if ((include 'vars.php') == TRUE) {
    echo 'OK';
}
?>
```

**Приклад #5 Вирази `include`и[return](function.return.md)**

```php
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // выведет 'PHP'

$bar = include 'noreturn.php';

echo $bar; // выведет 1

?>
```

`$bar`имеет значение , т.к. Увімкнення файлу відбулося успішно. Зауважте різницю між прикладами зверху. Перший використовує [return](function.return.md) всередині файлу, тоді як другий не використовує. Якщо файл не може бути увімкнений, повертається **`false`** і виникає **`E_WARNING`**

Якщо у файлі, що вмикається, визначені функції, вони можуть бути використані в головному файлі незалежно від того, чи були вони оголошені до [return](function.return.md) чи після. Якщо файл вмикається двічі, PHP видасть фатальну помилку, оскільки функції вже було визначено. Рекомендується використовувати [include\_once](function.include-once.md) замість того, щоб перевіряти, чи був файл вже включений.

Інший шлях "включити" PHP-файл у змінну - це захопити висновок за допомогою [функцій контролю виведення](ref.outcontrol.md)вместе с`include`Например:

**Приклад #6 Використання буферизації виводу для включення файлу PHP у рядок**

```php
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        return ob_get_clean();
    }
    return false;
}

?>
```

Для того, щоб включати файли автоматично в скрипти, зверніть увагу на конфігураційні директиви [auto\_prepend\_file](ini.core.md#ini.auto-prepend-file) і [auto\_append\_file](ini.core.md#ini.auto-append-file)в php.ini.

> **Зауваження**: Оскільки це мовна конструкція, а не функція, її не можна викликати як [змінну функцію](functions.variable-functions.md) або передавати як [іменований аргумент](functions.arguments.md#functions.named-arguments)

Смотрите также[require](function.require.md) [require\_once](function.require-once.md) [include\_once](function.include-once.md) [get\_included\_files()](function.get-included-files.md) [readfile()](function.readfile.md) [virtual()](function.virtual.md) і [include\_path](ini.core.md#ini.include-path)
