---
navigation:
  - function.require.html: « require
  - function.require-once.html: requireonce »
  - index.html: PHP Manual
  - language.control-structures.html: Управляющие конструкции
title: include
---
## include

(PHP 4, PHP 5, PHP 7, PHP 8)

Вираз `include` включає та виконує зазначений файл.

Документація нижче також відноситься до виразу [require](function.require.md)

Файли включаються виходячи зі шляху зазначеного файлу, або, якщо шлях не вказаний, використовується шлях, вказаний у директиві [includepath](ini.core.html#ini.include-path). Якщо файл не знайдено в [includepath](ini.core.html#ini.include-path) `include` спробує перевірити директорію, в якій знаходиться поточний скрипт і поточну робочу директорію перед тим, як видати помилку. Конструкція `include` видасть \*\*`E_WARNING`\*\*якщо не зможе знайти файл; поведінка відмінно від [require](function.require.md), який видасть **`E_ERROR`**

Зверніть увагу, що і `include` і `require` видають додаткову помилку рівня **`E_WARNING`**, якщо до файлу неможливо отримати доступ, перед тим, як видати останню помилку рівня **`E_WARNING`** або **`E_ERROR`** відповідно.

Якщо шлях вказаний - абсолютний (починається з літери диска або з `\` у Windows або з `/` в Unix/Linux системах) або щодо поточної директорії (починається з `.` або `..` [includepath](ini.core.html#ini.include-path) буде проігноровано взагалі. Наприклад, якщо ім'я файлу починається з `../`, парсер шукатиме в батьківській директорії запитаний файл.

Для додаткової інформації про те, як PHP обробляє файли та шляхи, що включаються, дивіться документацію для директиви [includepath](ini.core.html#ini.include-path)

Коли файл вмикається, його код успадковує ту ж [область видимості змінних](language.variables.scope.md), як і рядок, де сталося включення. Всі змінні, доступні на цьому рядку у файлі, що включають, будуть також доступні у файлі, що включається. Проте всі функції та класи, оголошені у файлі, що включається, мають глобальну область видимості.

**Приклад #1 Простий приклад `include`**

```php
vars.php
<?php

$color = 'зелёное';
$fruit = 'яблоко';

?>

test.php
<?php

echo "Одно $color $fruit"; // Одно

include 'vars.php';

echo "Одно $color $fruit"; // Одно зелёное яблоко

?>
```

Якщо включення відбувається всередині функції файлу, що містить, тоді весь код, що міститься в файлі, буде поводитися так, ніби він був визначений всередині цієї функції. Тобто він буде в тій же області видимості змінних цієї функції. Винятком до цього правила є [магічні константи](language.constants.predefined.md), які виконуються парсером перед тим, як відбувається увімкнення.

**Приклад #2 Увімкнення функції**

```php
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "Одно $color $fruit";
}

/* vars.php в той же области видимости, что и foo(),  *
* поэтому $fruit НЕ будет доступен за пределами этой области     *
* $color доступен, поскольку мы объявили переменную глобальной */

foo();                    // Одно зелёное яблоко
echo "Одно $color $fruit";   // Одно зелёное

?>
```

Коли файл увімкнеться, парсинг у режимі PHP-коду припиняється і перемикається в режим HTML на початку зазначеного файлу і продовжується знову наприкінці. З цієї причини будь-який код всередині файлу, який повинен бути виконаний як код PHP, повинен бути укладений в [коректні теги початку та кінця PHP-коду](language.basic-syntax.phpmode.md)

Якщо "[обёртки URL include](filesystem.configuration.html#ini.allow-url-include)" включені в PHP, ви можете також вказати файл для включення через URL (за допомогою HTTP або інших обробників, що підтримуються - дивіться [Підтримувані протоколи та обгортки](wrappers.md) для списку протоколів замість локального шляху. Якщо цільовий сервер інтерпретує вказаний файл як код PHP, змінні можуть бути передані до файлу, що включається за допомогою рядка URL-запиту при використанні HTTP GET. Це зовсім не те саме, що включення файлу та успадкування батьківської області видимості; скрипт виконується на віддаленому сервері, і результат потім включається до локального скрипту.

**Приклад #3 Приклад `include` через HTTP**

```php
<?php

/* В этом примере предполагается, что www.example.com настроен на обработку .php
* файлов, но не .txt. Также, 'Сработает' обозначает, что переменные
* $foo и $bar доступны внутри включаемого файла. */

// Не сработает; file.txt не обрабатывается www.example.com как PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Не сработает; будет искать файл 'file.php?foo=1&bar=2' в
// локальной файловой системе.
include 'file.php?foo=1&bar=2';

// Сработает.
include 'http://www.example.com/file.php?foo=1&bar=2';
?>
```

**Увага**

# Попередження безпеки

Видалені файли можуть бути оброблені на віддаленій стороні (залежно від розширення файлу і того, що віддалений сервер виконує скрипти PHP чи ні), але це все одно має робити коректний скрипт PHP, тому що потім буде оброблений вже на локальному сервері. Якщо файл з віддаленого сервера повинен бути оброблений і відображений його результат, набагато ефективно скористатися функцією [readfile()](function.readfile.md) В іншому випадку слід дотримуватися особливої ​​обережності, щоб убезпечити віддалений скрипт для отримання коректного та бажаного коду.

Дивіться також розділ [Видалені файли](features.remote-files.html), функції [fopen()](function.fopen.html) і [file()](function.file.md) для додаткової інформації.

Обробка значень, що повертаються: оператор `include` повертає значення `FALSE` у разі виникнення помилки та видає попередження. Успішні включення, поки це не перевизначено у файлі, повертають значення `1`. Можливо виконати вираз [return](function.return.html) всередині файлу, щоб завершити процес виконання в цьому файлі і повернутися до виконання файлу, що включає. Крім того, можливо повернути значення з файлів, що включаються. Ви можете отримати значення включення, якби викликали звичайну функцію. Хоча це неможливо при включенні видаленого файлу, тільки якщо виведення видаленого файлу не містить [коректні теги початку та кінця PHP коду](language.basic-syntax.phpmode.md) (Так само, як і локальний файл). Ви можете визначити необхідні змінні всередині цих тегів і вони будуть представлені залежно від того, який файл вимкнено.

Так як `include` - це спеціальна мовна конструкція, круглі дужки не є обов'язковими навколо аргументу. Будьте уважні при порівнянні значення, що повертається.

**Приклад #4 Порівняння значення, що повертається при include**

```php
<?php
// не сработает, интерпретируется как include(('vars.php') == TRUE), то есть include('1')
if (include('vars.php') == TRUE) {
    echo 'OK';
}

// сработает
if ((include 'vars.php') == TRUE) {
    echo 'OK';
}
?>
```

**Приклад #5 Вирази `include` і [return](function.return.md)**

```php
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // выведет 'PHP'

$bar = include 'noreturn.php';

echo $bar; // выведет 1

?>
```

`$bar` має значення `1`, т.к. Увімкнення файлу відбулося успішно. Зауважте різницю між прикладами зверху. Перший використовує [return](function.return.md) всередині файлу, тоді як другий не використовує. Якщо файл не може бути увімкнений, повертається **`false`** і виникає **`E_WARNING`**

Якщо у файлі, що вмикається, визначені функції, вони можуть бути використані в головному файлі незалежно від того, чи були вони оголошені до [return](function.return.html) чи після. Якщо файл вмикається двічі, PHP видасть фатальну помилку, оскільки функції вже було визначено. Рекомендується використовувати [includeonce](function.include-once.md) замість того, щоб перевіряти, чи був файл вже включений.

Інший шлях "включити" PHP-файл у змінну - це захопити висновок за допомогою [функцій контролю виведення](ref.outcontrol.md) разом з `include`. Наприклад:

**Приклад #6 Використання буферизації виводу для включення файлу PHP у рядок**

```php
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        return ob_get_clean();
    }
    return false;
}

?>
```

Для того, щоб включати файли автоматично в скрипти, зверніть увагу на конфігураційні директиви [autoprependfile](ini.core.html#ini.auto-prepend-file) і [autoappendfile](ini.core.html#ini.auto-append-file) у php.ini.

> **Зауваження**: Оскільки це мовна конструкція, а не функція, вона не може викликатися за допомогою [змінних функцій](functions.variable-functions.md) або [іменованих аргументів](functions.arguments.html#functions.named-arguments)

Дивіться також [require](function.require.html) [requireonce](function.require-once.html) [includeonce](function.include-once.html) [getincludedfiles()](function.get-included-files.html) [readfile()](function.readfile.html) [virtual()](function.virtual.md) і [includepath](ini.core.html#ini.include-path)
