Рекурсивні шаблони

-   [« Комментарии](regexp.reference.comments.html)
    
-   [Производительность »](regexp.reference.performance.html)
    
-   [PHP Manual](index.html)
    
-   [Описание синтаксиса Perl-совместимых регулярных выражений](reference.pcre.pattern.syntax.html)
    
-   Рекурсивні шаблони
    

## Рекурсивні шаблони

Розглянемо задачу пошуку відповідності з рядком, що знаходяться усередині необмеженої кількості круглих дужок. Без використання рекурсії найкраще, що можна зробити - написати шаблон, який вирішуватиме задачу для деякої обмеженої глибини вкладеності, тому що обробити необмежену глибину не надається можливим. У Perl 5.6 представлені деякі експериментальні можливості, які дозволяють реалізувати рекурсію в шаблонах. Спеціально позначення (?R) використовується для вказівки на рекурсивну підмаску. Таким чином, наведемо PCRE шаблон, що вирішує поставлене завдання (маю на увазі, що використовується модифікатор [PCRE\_EXTENDED](reference.pcre.pattern.modifiers.html), незначні прогалини ігноруються): `\( ( (?>[^()]+) | (?R) )* \)`

Спочатку він відповідає круглій дужці, що відкриває. Далі він відповідає будь-якій кількості підрядків, кожна з яких може бути послідовністю не-дужок, або рядком, що рекурсивно відповідає шаблону (тобто рядком, коректно укладеним у круглі дужки). І, наприкінці, йде закриваюча кругла дужка.

Наведений приклад шаблону використовує вкладені необмежені повторення, тому використання одноразових шаблонів значно прискорює процес зіставлення, особливо у випадках, коли рядок відповідає заданій масці. Наприклад, якщо його застосувати до рядка: `(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()`, то невідповідність буде виявлено досить швидко. Але якщо одноразові шаблони не використовуються, зіставлення буде затягуватися на тривалий час, оскільки існує безліч способів поділу рядка між квантифікаторами + і , і всі вони повинні бути перевірені, перш ніж буде видано повідомлення про невдачу.

Значення, яке встановлюється для захоплюючої підмаски, буде відповідати значенню, захопленому на найглибшому рівні рекурсії. У випадку, якщо наведений вище шаблон зіставляється з рядком `(ab(cd)ef)`Захопленим значенням буде 'ef', яке є останнім значенням, прийнятим на верхньому рівні. Якщо додати додаткові дужки `\( ( ( (?>[^()]+) | (?R) )* ) \)`Захопленим значенням буде "ab(cd)ef". У випадку, якщо в шаблоні зустрічається більш ніж 15 захоплюючих дужок, PCRE потрібно більше пам'яті для обробки рекурсії, ніж зазвичай. Пам'ять виділяється за допомогою функції pcremalloc і звільняється відповідно функцією pcrefree. Якщо пам'ять може бути виділено, зберігаються дані лише перших 15 захоплюючих дужок, оскільки немає способу видати помилку out-of-memory зсередини рекурсії.

`(?1)` `(?2)` і так далі можуть бути використані для рекурсивних підмасок. Також можна використовувати іменовані підмаски: `(?P>name)` або `(?&name)`

Якщо синтаксис посилання на рекурсивну підмаску (як на ім'я, так і за числовим індексом) використовується поза дужками, до яких він відноситься, він відпрацьовує аналогічно підпрограмі в мові програмування. Візьмемо раніше приклад, що вказує що шаблон `(sens|respons)e and \1ibility` відповідає "sense and sensibility" та "response and responsibility", але не "sense and responsibility". Якщо замість цього використовувати шаблон `(sens|respons)e and (?1)ibility`Він збігається з "sense and responsibility" так само, як і з іншими двома рядками. Однак такі посилання повинні бути вказані після підмаски, на яку вони посилаються.

Максимальний рядок рядка, що обробляється, не повинен перевищувати максимально доступного цілого числа. Однак, оскільки для обробки підмасок і нескінченного повторення PCRE використовує рекурсію, це означає, що розмір рядків, що обробляються, в деяких шаблонах також може бути обмежений доступним розміром стека.