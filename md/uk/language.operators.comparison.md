---
navigation:
  - language.operators.bitwise.md: « Побітові оператори
  - language.operators.errorcontrol.md: Управління помилками »
  - index.md: PHP Manual
  - language.operators.md: Оператори
title: Оператори порівняння
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Оператори порівняння

Оператори порівняння, як це видно з їхньої назви, дозволяють порівнювати між собою два значення. Можуть також виявитися цікавими для знайомства [таблиці порівняння типів](types.comparisons.md), оскільки в них показані приклади порівнянь, пов'язаних із різними типами.

**Оператори порівняння**

| Приклад | Название | Результат |
| --- | --- | --- |
| $a == $b | Рівно | Повертається **`true`**, якщо значення змінної $a після перетворення типів дорівнює значенням змінної $b. |
| $a === $b | Тотожно | Повертається \*\*`true`\*\*якщо значення змінної $a дорівнює значенню змінної $b і має той самий тип. |
| $a != $b | Не дорівнює | Повертається **`true`**, якщо значення змінної $a після перетворення типів не дорівнює значенню змінної $b. |
| $a <> $b | Не дорівнює | Повертається **`true`**, якщо значення змінної $a після перетворення типів не дорівнює значенню змінної $b. |
| $a !== $b | Тотожно не одно | Повертається \*\*`true`\*\*якщо значення змінної $a не дорівнює значенню змінної $b або вони різних типів. |
| $a < $b | Менше | Повертається \*\*`true`\*\*якщо значення змінної $a строго менше значення змінної $b. |
| $a > $b | Більше | Повертається \*\*`true`\*\*якщо значення змінної $a строго більше значення змінної $b. |
| $a <= $b | Менше або дорівнює | Повертається \*\*`true`\*\*якщо значення змінної $a менше або дорівнює значенням змінної $b. |
| $a >= $b | Більше або дорівнює | Повертається \*\*`true`\*\*якщо значення змінної $a більше або дорівнює значенням змінної $b. |
| $a <=> $b | Космічний корабель (spaceship) | Ціле число (int) менше, більше або дорівнює нулю, коли значення змінної $a менше, більше або дорівнює значенню змінної $b. |

Если оба операнда —[рядки, що містять числа](language.types.numeric-strings.md), або один операнд - число, а інший - [рядок, що містить числа](language.types.numeric-strings.md), то порівняння виконується чисельно. Ці правила також справедливі для оператора [switch](control-structures.switch.md). Тип не перетворюється при порівняннях виду `===`или`!==`оскільки це включає порівняння типу, а також значення.

**Увага**

До PHP 8.0.0, якщо рядок (string) порівнювався з числом або рядком, що містить число, то рядок (string) перетворювався на число перед виконанням порівняння. Це могло призвести до несподіваних результатів, які можна побачити на наступному прикладі:

```php
<?php

var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
```

Результат виконання наведеного прикладу в PHP 7:

```
bool(true)
bool(true)
bool(true)
bool(true)
0
```

Результат виконання наведеного прикладу в PHP 8:

```
bool(false)
bool(true)
bool(true)
bool(true)
a
```

```php
<?php
// Целые числа
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Числа с плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Объекты
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0
$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1
$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// сравниваются не только значения; ключи также должны совпадать
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1
?>
```

Для різних типів порівняння відбувається відповідно до наступної таблиці (по порядку).

**Порівняння типів**

| Тип операнда 1 | Тип операнда 2 | Результат |
| --- | --- | --- |
| null або string | string | **`null`** перетворюється на порожній рядок (""), числове чи лексичне порівняння |
| bool або null | що завгодно | Перетворюється на bool, **`false`** < **`true`** |
| object | object | Вбудовані класи можуть визначати свої правила порівняння, об'єкти різних класів не порівнюються, порівняння об'єктів одного класу розказано в розділі «[Порівняння об'єкта](language.oop5.object-comparison.md)» |
| string, resource, int або float | string, resource, int або float | Рядки та ресурси переводяться в числа, звичайна математика |
| array | array | Масив з меншим числом елементів менший, якщо ключ з першого масиву не знайдено у другому масиві — масиви не можуть порівнюватися, інакше йде порівняння значень (див. приклад нижче) |
| array | що завгодно | Тип array завжди більший |
| object | що завгодно | Тип object завжди більший |

**Приклад #1 Порівняння boolean/null**

```php
<?php

// Логические значения и null всегда сравниваются как логические
var_dump(1 == TRUE); // TRUE  — то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE  — то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE  — то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE); // FALSE  — то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL  — (bool)NULL < (bool)-100 это FALSE < TRUE
```

**Приклад #2 Алгоритм порівняння звичайних масивів**

```php
<?php

// Массивы сравниваются как в этом Прикладе — со стандартными операторами сравнения, а также оператором «космический корабль» (spaceship).
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }

    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return 1;
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }

    return 0; // $op1 == $op2
}
```

**Увага**

# Порівняння чисел з плаваючою точкою

З причин, пов'язаних зі способом внутрішнього представлення чисел з плаваючою точкою (float), не потрібно перевіряти два числа з плаваючою точкою (float) на рівність.

Докладніше про це можна дізнатися в документації типу float.

> **Зауваження**: Коли пишуть код, пам'ятають, що жонглювання типами PHP не завжди дає передбачуваний результат при порівнянні значень різних типів, особливо при порівнянні цілих чисел (int) з логічними значеннями (bool) або цілих чисел (int) з рядками (string). Тому краще користуватись операторами `===`и`!==`, а не`==`и`!=`

### Незрівнянне значення

Хоча тотожні порівняння (`===`и`!==`) можна застосовувати до довільних значень, інші оператори порівняння краще застосовувати лише до порівнянних значень. Результат порівняння незрівнянних значень не визначено і не потрібно покладатися.

### Дивіться також

-   [strcasecmp()](function.strcasecmp.md)
-   [strcmp()](function.strcmp.md)
-   [Оператори, що працюють із масивами](language.operators.array.md)
-   [Типи](language.types.md)

### Тернарний оператор

Ще один умовний оператор – тернарний оператор «?:».

**Приклад #3 Призначення за промовчанням**

```php
<?php

// Приклад выражения с тернарным оператором
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Код выше аналогичен блоку с конструкциями if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
```

Вираз `(expr1) ? (expr2) : (expr3)` інтерпретується як expr2, якщо expr1 дорівнює **`true`**, або як expr3, якщо expr1 дорівнює **`false`**

Можна не писати середню частину тернарного оператора. Вираз `expr1 ?: expr3` оцінюється як результат виразу expr1, якщо воно оцінюється як **`true`**, інакше як результат виразу expr3. Вираз expr1 оцінюється лише один раз.

> **Зауваження**: Зверніть увагу, що тернарний оператор - це вираз, і він оцінюється не як змінна, а як результат виразу Це важливо, якщо потрібно повернути змінну за посиланням. Вираз `return $var == 42 ? $a : $b;` не працюватиме у функції, що повертає значення за посиланням, а в пізніших версіях PHP також буде видано попередження.

> **Зауваження** :
> 
> Рекомендовано уникати «нагромадження» тернарних виразів. Поведінка PHP при вказівці більш ніж одного тернарного оператора без дужок в одному виразі не очевидна порівняно з іншими мовами. Справді, до PHP 8.0.0 троїчні висловлювання оцінювалися як лівоасоціативні, а чи не правоасоціативні, як у більшості інших мов програмування. Опора на ліву асоціативність застаріла з PHP 7.4.0. Починаючи з PHP 8.0.0, тернарний оператор неасоціативний.
> 
> **Приклад #4 Неочевидна поведінка тернарного оператора**
> 
> ```php
> <?php
> 
> // здається, що наступний код виведе «true»
> echo (true ? 'true' : false ? 't' : 'f');
> 
> // проте він виводить "t" до PHP 8.0.0
> // Це тому, що тернарні вирази лівоасоціативні
> 
> // наступний запис — більш очевидна версія того ж коду, який показаний вище
> echo ((true ? 'true' : false) ? 't' : 'f');
> 
> // Тут видно, що перший вираз оцінюється як рядкове "true", яке
> // оцінюється як логічне (bool) true, тому повертає справжню гілку
> / / Другого тернарного виразу.
> ```

> **Зауваження** :
> 
> Ланцюжок коротких тернарних операторів (`?:`), однак, стабільна і поводиться обґрунтовано. Вона оцінюватиме перший аргумент, який оцінюється як помилкове значення. Зверніть увагу, що невизначені значення однаково викликатимуть попередження.
> 
> **Приклад #5 Ланцюжок коротких тернарних операторів**
> 
> ```php
> <?php
> echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; // 1
> echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; // 2
> echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; // 3
> ?>
> ```

### Оператор об'єднання з null

Інший корисний скорочений оператор – це оператор об'єднання з NULL – «??» (Null coalescing).

**Приклад #6 Призначення за промовчанням**

```php
<?php

// Приклад работы с оператором нулевого слияния
$action = $_POST['action'] ?? 'default';

// Приклад выше аналогичен этому выражению с if/else
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}
```

Вираз `(expr1) ?? (expr2)` обчислюється так: expr2, якщо expr1 дорівнює \*\*`null`\*\*інакше expr1.

Цей оператор не викликає попередження або помилки, якщо лівий операнд не існує, як мовна конструкція [isset()](function.isset.md). Це дуже корисно для ключів масиву.

> **Зауваження**: Зверніть увагу, оператор об'єднання з NULL - це вираз, і він оцінюється не як змінна, а як результат обчислення виразу. Це важливо, якщо потрібно повернути значення за посиланням. Вираз `return $foo ?? $bar;` у функції, що повертає посилання, не працюватиме, а виводитиме попередження.

> **Зауваження** :
> 
> Оператор об'єднання з NULL має низький пріоритет. Тобто при змішуванні його з іншими операторами (наприклад, з операторами конкатенації рядків або арифметичними операторами), швидше за все, будуть потрібні круглі дужки.
> 
> ```php
> <?php
> 
> // Викликає попередження, що $name не визначено.
> print 'Mr. '. $name ?? 'Anonymous';
> 
> // Виведе "Mr. Anonymous"
> print 'Mr. '. ($name ?? 'Anonymous');
> ```

> **Зауваження** :
> 
> Зверніть увагу, оператор об'єднання з NULL дозволяє просту вкладеність:
> 
> **Приклад #7 Вкладений оператор null coalescing**
> 
> ```php
> <?php
> 
> $ foo = null;
> $bar = null;
> $ Baz = 1;
> $ Qux = 2;
> 
> echo $foo ?? $bar ?? $baz ?? $qux; // виведе 1
> ```
