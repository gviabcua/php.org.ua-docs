---
navigation:
  - language.operators.bitwise.md: « Побітові оператори
  - language.operators.errorcontrol.md: Оператор управления ошибками »
  - index.md: PHP Manual
  - language.operators.md: Оператори
title: Оператори порівняння
---
## Оператори порівняння

Оператори порівняння, як це видно з їхньої назви, дозволяють порівнювати між собою два значення. Можливо, вам буде цікаво також ознайомитися з розділом [Сравнение типов](types.comparisons.md), в якому наведено велику кількість відповідних прикладів.

**Оператори порівняння**

| Пример | Название | Результат |
| --- | --- | --- |
| $a == $b | Рівно | **`true`** якщо $a дорівнює $b після перетворення типів. |
| $a === $b | Тотожно | **`true`** якщо $a дорівнює $b і має той самий тип. |
| $a != $b | Не дорівнює | **`true`** якщо $a не дорівнює $b після перетворення типів. |
| $a <> $b | Не дорівнює | **`true`** якщо $a не дорівнює $b після перетворення типів. |
| $a !== $b | Тотожно не одно | **`true`** якщо $a не дорівнює $b, або вони різних типів. |
| $a < $b | Менше | **`true`** якщо $a строго менше $b. |
| $a > $b | Більше | **`true`** якщо $a строго більше за $b. |
| $a <= $b | Менше або дорівнює | **`true`** якщо $a менше або дорівнює $b. |
| $a >= $b | Більше або дорівнює | **`true`** якщо $a більше або дорівнює $b. |
| $a <=> $b | Космічний корабель (spaceship) | Число типу int менше, більше або дорівнює нулю, коли $a відповідно менше, більше або дорівнює $b. |

У випадку, якщо обидва операнда є [рядками, що містять числа](language.types.numeric-strings.md) або один операнд є числом, а інший - [рядком, що містить числа](language.types.numeric-strings.md), то порівняння виконується чисельно. Ці правила також застосовуються до оператора [switch](control-structures.switch.md). Перетворення типу не відбувається при порівнянні `===` або `!==`оскільки це включає порівняння типу, а також значення.

**Увага**

До PHP 8.0.0, якщо рядок (string) порівнювався з числом або рядком, що містить число, то рядок (string) перетворювалося на число перед виконанням порівняння. Це могло призвести до несподіваних результатів, які можна побачити на наступному прикладі:

```php
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
```

Результат виконання цього прикладу в PHP 7:

```
bool(true)
bool(true)
bool(true)
bool(true)
0
```

Результат виконання цього прикладу в PHP 8:

```
bool(false)
bool(true)
bool(true)
bool(true)
a
```

```php
<?php
// Целые числа
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Числа с плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Масиви
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Объекты
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// сравниваются не только значения; ключи также должны совпадать
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
```

Для різних типів порівняння відбувається відповідно до наступної таблиці (по порядку).

**Порівняння різних типів**

| Тип операнда 1 | Тип операнда 2 | Результат |
| --- | --- | --- |
| null або string | string | **`null`** перетворюється на "", числове чи лексичне порівняння |
| bool або null | що завгодно | Перетворюється на тип bool, **`false`** < **`true`** |
| object | object | Вбудовані класи можуть визначати власні правила порівняння, об'єкти різних класів не порівнюються, про порівняння об'єктів одного класу дивіться [Порівняння об'єкта](language.oop5.object-comparison.md) |
| string, resource, int або float | string, resource, int або float | Рядки та ресурси переводяться в числа, звичайна математика |
| array | array | Масиви з меншим числом елементів вважаються меншими, якщо ключ з першого операнда не знайдений у другому операнді - масиви не можуть порівнюватися, інакше йде порівняння відповідних значень (див. приклад нижче) |
| array | що завгодно | тип array завжди більше |
| object | що завгодно | тип object завжди більший |

**Приклад #1 Порівняння boolean/null**

```php
<?php
// Логические значения и null всегда сравниваются как логические
var_dump(1 == TRUE);  // TRUE - то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 это FALSE < TRUE
?>
```

**Приклад #2 Алгоритм порівняння звичайних масивів**

```php
<?php
// Масиви сравниваются таким образом с помощью стандартных операторов сравнения, а также оператора spaceship.
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return 1;
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
```

**Увага**

# Порівняння чисел з плаваючою точкою

Через особливе внутрішнє уявлення типу float, не потрібно перевіряти на рівність два числа з плаваючою точкою (float).

Для більш детальної інформації дивіться документацію типу float.

> **Зауваження**: Пам'ятайте, що жонглювання типами в PHP не завжди очевидне при порівнянні значень різних типів, особливо при порівнянні цілих чисел (int) з логічними значеннями (bool) або цілих чисел (int) зі рядками (string). Тому в більшості випадків рекомендується використовувати порівняння `===` і `!==`, а не `==` і `!=`

### Незрівнянне значення

У той час як порівняння тотожності (`===` і `!==`) можна застосовувати до довільних значень, інші оператори порівняння слід застосовувати лише до порівнянних значень. Результат порівняння незрівнянних значень не визначено і не слід покладатися.

### Дивіться також

-   [strcasecmp()](function.strcasecmp.md)
-   [strcmp()](function.strcmp.md)
-   [Оператори, що працюють із масивами](language.operators.array.md)
-   [Типи](language.types.md)

### Тернарний оператор

Ще одним умовним оператором є тернарний оператор "?:".

**Приклад #3 Призначення за промовчанням**

```php
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведённый выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
```

Вираз `(expr1) ? (expr2) : (expr3)` інтерпретується як expr2, якщо expr1 має значення **`true`**, або як expr3, якщо expr1 має значення **`false`**

Також можна було не писати середню частину тернарного оператора. Вираз `expr1 ?: expr3` оцінюється як результат expr1, якщо результат виразу expr1 оцінюється як **`true`** і expr3 інакше. Вираз expr1 у разі оцінюється лише один раз.

> **Зауваження**: Зверніть увагу, що тернарний оператор є виразом і трактується не як змінна, а як результат виразу. Це важливо знати, якщо ви хочете повернути змінну за посиланням. Вираз `return $var == 42 ? $a : $b;` не працюватиме у функції, що повертає значення за посиланням, а в пізніших версіях PHP також буде видано попередження.

> **Зауваження**
> 
> Рекомендується уникати "нагромадження" тернарних виразів. Поведінка PHP неочевидна при використанні більш ніж одного тернарного оператора без дужок в одному виразі порівняно з іншими мовами. Справді, до PHP 8.0.0 трійкові висловлювання оцінювалися ліво-асоціативними, а чи не право-асоціативними, як у більшості інших мов програмування. Використання ліво-асоціативності застаріло у PHP 7.4.0. Починаючи з PHP 8.0.0, тернарний оператор неасоціативний.
> 
> **Приклад #4 Неочевидна поведінка тернарного оператора**
> 
> ```php
> <?php
> // на первый взгляд, следующий код должен вывести 'true'
> echo (true ? 'true' : false ? 't' : 'f');
> 
> // однако, он выводит 't' до PHP 8.0.0
> // это потому, что тернарные выражения левоассоциативны
> 
> // это намного более очевидная версия вышеприведённого кода
> echo ((true ? 'true' : false) ? 't' : 'f');
> 
> // здесь видно, что первое выражение вычисляется в 'true', которое
> // в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
> // второго тернарного выражения.
> ?>
> ```

> **Зауваження**
> 
> Ланцюжок коротких тернарних операторів (`?:`) стабільна і поводиться розумно. Вона оцінюватиме перший аргумент, який оцінюється як помилкове значення. Зверніть увагу, що невизначені значення однаково викликатимуть попередження.
> 
> **Приклад #5 Ланцюжок коротких тернарних операторів**
> 
> ```php
> <?php
> echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; //1
> echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; //2
> echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; //3
> ?>
> ```

### Оператор об'єднання з null

Іншим корисним скороченим оператором є оператор "??" (Null coalescing).

**Приклад #6 Призначення за промовчанням**

```php
<?php
// Пример использования оператора
$action = $_POST['action'] ?? 'default';

// Пример выше аналогичен следующему коду
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}
?>
```

Вираз `(expr1) ?? (expr2)` обчислюється так: expr2, якщо expr1 дорівнює **`null`** і expr1 інакше.

На практиці цей оператор не викликає попередження або помилки, якщо лівий операнд не існує, як і [isset()](function.isset.md). Це дуже корисно для ключів масиву.

> **Зауваження**: Будь ласка, пам'ятайте, що цей оператор є виразом, і він прирівнюється до виразу, а не значення змінної. Це може бути важливим, якщо ви хочете повернути значення за посиланням. Вираз `return $foo ?? $bar;` у функції повертає посилання не працюватиме, а виводитиме попередження.

> **Зауваження**
> 
> У оператора null coalescing низький пріоритет. Це означає, що при змішуванні його з іншими операторами (такими як конкатенація рядків або арифметичні оператори), швидше за все, будуть потрібні круглі дужки.
> 
> ```php
> <?php
> // Вызывает предупреждение о том, что $name не определено.
> print 'Mr. ' . $name ?? 'Anonymous';
> // Выведет "Mr. Anonymous"
> print 'Mr. ' . ($name ?? 'Anonymous');
> ?>
> ```

> **Зауваження**
> 
> Зверніть увагу, що цей оператор дозволяє використовувати просту вкладеність:
> 
> **Приклад #7 Вкладений оператор null coalescing**
> 
> ```php
> <?php
> 
> $foo = null;
> $bar = null;
> $baz = 1;
> $qux = 2;
> 
> echo $foo ?? $bar ?? $baz ?? $qux; // выведет 1
> 
> ?>
> ```
