---
navigation:
  - function.preg-replace-callback.md: « pregreplacecallback
  - function.preg-split.md: pregsplit »
  - index.md: PHP Manual
  - ref.pcre.md: Функции PCRE
title: pregreplace
---
# pregreplace

(PHP 4, PHP 5, PHP 7, PHP 8)

pregreplace — Здійснює пошук та заміну за регулярним виразом.

### Опис

```methodsynopsis
preg_replace(    string|array $pattern,    string|array $replacement,    string|array $subject,    int $limit = -1,    int &$count = null): string|array|null
```

Виконує пошук збігів у рядку `subject` із шаблоном `pattern` і замінює їх на `replacement`

### Список параметрів

`pattern`

Шуканий шаблон. Можливо як рядком, і масивом рядків.

Також доступні деякі [модифікатори PCRE](reference.pcre.pattern.modifiers.md)

`replacement`

Рядок або масив рядків для заміни. Якщо цей параметр є рядком, а `pattern` є масивом, всі шаблони будуть замінені цим рядком. Якщо і `pattern` і `replacement` є масивами, кожен елемент `pattern` буде замінений відповідним елементом з `replacement`. Якщо масив `replacement` містить менше елементів, ніж масив `pattern`, то всі зайві шаблони з `pattern` будуть замінені порожніми рядками.

`replacement` може містити посилання на вид `\n`, або `$n`, причому останній варіант кращий. Кожне таке посилання буде замінено на підрядок, що відповідає nой підмасці. n може набувати значень від 0 до 99, причому посилання `\0` (або `$0`) відповідає входженню всього шаблону. Підмаски нумеруються зліва направо, починаючи з одиниці. Зверніть увагу, що зворотні сліші у рядку (string) літерали можуть вимагати екранування.

При заміні за шаблоном з використанням посилань на підмаски може виникнути ситуація, коли безпосередньо за маскою слідує цифра (наприклад, встановлення цифри відразу після маски, що збіглася). У такому разі не можна використовувати знайому нотацію виду `\1` для посилання на підмаски. Запис, наприклад, `\11`, збентежить **pregreplace()**, так як вона не зможе зрозуміти, чи хочете ви використовувати посилання `\1`, за якою слідує цифра `1` або ж ви хочете просто використовувати посилання `\11`, за якою нічого не слідує. Це непорозуміння можна усунути, якщо скористатися конструкцією `${1}1`, що використовує ізольоване посилання `$1`, і наступну за нею цифру `1`

При використанні застарілого модифікатора `e` ця функція екранує деякі символи (а саме `'` `"` `\` та NULL) у рядках, що заміщають зворотні посилання. Це зроблено для засвідчення коректності синтаксису при використанні зворотних посилань усередині одинарних або подвійних лапок (наприклад, `'strlen(\'$1\')+strlen("$2")'`). Переконайтеся, що ви володієте [синтаксисом обработки строк](language.types.string.md) PHP для того, щоб точно усвідомлювати, як виглядатиме інтерпретований рядок.

`subject`

Рядок або масив рядків для пошуку та заміни.

Якщо `subject` є масивом, то пошук із заміною здійснюється для кожного елемента масиву `subject`, а значення, що повертається, також буде масивом.

Якщо параметр `subject` є асоціативним масивом, ключі будуть збережені у значенні, що повертається.

`limit`

Максимально можлива кількість замін кожного шаблону для кожного рядка `subject`. За замовчуванням одно `-1` (без обмежень).

`count`

Якщо зазначено, то ця змінна буде заповнена кількістю зроблених замін.

### Значення, що повертаються

**pregreplace()** повертає масив, якщо параметр `subject` є масивом, інакше повертається рядок.

Якщо знайдені збіги, повертається нова версія `subject`інакше `subject` повертається недоторканим, у разі помилки повертається **`null`**

### Помилки

Використання модифікатора "e" є помилкою; у цьому випадку видається помилка рівня **`E_WARNING`**

Якщо переданий шаблон регулярного виразу не компілюється в допустимий регулярний вираз, видається помилка рівня **`E_WARNING`**

### Приклади

**Приклад #1 Використання підмасок, за якими слідує цифра**

```php
<?php
$string = 'April 15, 2003';
$pattern = '/(\w+) (\d+), (\d+)/i';
$replacement = '${1}1,$3';
echo preg_replace($pattern, $replacement, $string);
?>
```

Результат виконання цього прикладу:

```
April1,2003
```

**Приклад #2 Використання масивів з числовими індексами як аргументи функції **pregreplace()****

```php
<?php
$string = 'The quick brown fox jumps over the lazy dog.';
$patterns = array();
$patterns[0] = '/quick/';
$patterns[1] = '/brown/';
$patterns[2] = '/fox/';
$replacements = array();
$replacements[2] = 'bear';
$replacements[1] = 'black';
$replacements[0] = 'slow';
echo preg_replace($patterns, $replacements, $string);
?>
```

Результат виконання цього прикладу:

```
The bear black slow jumps over the lazy dog.
```

Відсортувавши за ключами шаблони та заміни, отримуємо бажаний результат:

```php
<?php
ksort($patterns);
ksort($replacements);
echo preg_replace($patterns, $replacements, $string);
?>
```

Результат виконання цього прикладу:

```
The slow black bear jumps over the lazy dog.
```

**Приклад #3 Заміна на декілька шаблонів**

```php
<?php
$patterns = array ('/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/',
                   '/^\s*{(\w+)}\s*=/');
$replace = array ('\3/\4/\1\2', '$\1 =');
echo preg_replace($patterns, $replace, '{startDate} = 1999-5-27');
?>
```

Результат виконання цього прикладу:

```
$startDate = 5/27/1999
```

**Приклад #4 Чищення пробілів**

Цей приклад вичищає зайві прогалини у рядку.

```php
<?php
$str = 'foo   o';
$str = preg_replace('/\s\s+/', ' ', $str);
// Это теперь будет 'foo o'
echo $str;
?>
```

**Приклад #5 Використання параметра `count`**

```php
<?php
$count = 0;

echo preg_replace(array('/\d/', '/\s/'), '*', 'xp 4 to', -1 , $count);
echo $count; //3
?>
```

Результат виконання цього прикладу:

```
xp***to
3
```

### Примітки

> **Зауваження**
> 
> При використанні масивів у `pattern` і `replacement`, ключі обробляються в порядку, в якому вони знаходяться в масиві. Цей порядок *не завжди* збігається з числовим порядком індексів. Якщо ви використовуєте індекси для порівняння один з одним потрібного `pattern` і `replacement`, то вам необхідно прогнати через функцію [ksort()](function.ksort.md) обидва масиви перед використанням **pregreplace()**

> **Зауваження**
> 
> Якщо і `pattern` і `replacement` є масивами, правила відповідності діятимуть послідовно. Тобто друга пара `pattern``replacement` буде працювати з рядком, отриманим у результаті першої пари `pattern``replacement`, а не з вихідним рядком. Якщо ви хочете імітувати заміну, що діє паралельно, наприклад, поміняти місцями два значення, замініть один шаблон проміжним заповнювачем, а потім у наступній парі замініть цей проміжний заповнювач необхідною заміною.
> 
> ```php
> <?php
> $p = array('/a/', '/b/', '/c/');
> $r = array('b', 'c', 'd');
> print_r(preg_replace($p, $r, 'a'));
> // prints d
> ?>
> ```

### Дивіться також

-   [Регулярні вирази PCRE](pcre.pattern.md)
-   [pregquote()](function.preg-quote.md) - Екранує символи у регулярних виразах
-   [pregfilter()](function.preg-filter.md) - Здійснює пошук та заміну за регулярним виразом
-   [pregmatch()](function.preg-match.md) - Виконує перевірку на відповідність регулярному виразу
-   [pregreplacecallback()](function.preg-replace-callback.md) - Виконує пошук за регулярним виразом та заміною з використанням callback-функції
-   [pregsplit()](function.preg-split.md) - Розбиває рядок за регулярним виразом
-   [preglasterror()](function.preg-last-error.md) - Повертає код помилки виконання останнього регулярного вираження PCRE
