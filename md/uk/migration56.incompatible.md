---
navigation:
  - migration56.md: « Міграція з PHP 5.5.x на PHP 5.6.x
  - migration56.new-features.md: Нові можливості "
  - index.md: PHP Manual
  - migration56.md: Міграція з PHP 5.5.x на PHP 5.6.x
title: 'Зміни, що ламають зворотну сумісність'
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Зміни, що ламають зворотну сумісність

Незважаючи на те, що більша частина існуючого коду PHP 5 повинна працювати без змін, все ж таки ознайомтеся з деякими змінами, які можуть позначитися на зворотній сумісності:

### Ключі масиву не будуть перезаписані при визначенні масиву як властивості класу через літерал масиву

Раніше в масивах, задані як властивості класу зі змішаними явними та неявними ключами, елементи із явно заданими ключами могли мовчки перезаписуватись, якщо явний ключ перетинався з послідовним неявним ключем. Наприклад:

```php
<?php
class C {
    const ONE = 1;
    public $array = [
        self::ONE => 'foo',
        'bar',
        'quux',
    ];
}

var_dump((new C)->array);
?>
```

Результат виконання наведеного прикладу в PHP 5.5:

```
array(2) {
  [0]=>
  string(3) "bar"
  [1]=>
  string(4) "quux"
}
```

Результат виконання наведеного прикладу в PHP 5.6:

```
array(3) {
  [1]=>
  string(3) "foo"
  [2]=>
  string(3) "bar"
  [3]=>
  string(4) "quux"
}
```

### Суворість [json\_decode()](function.json-decode.md)

Тепер [json\_decode()](function.json-decode.md) відповідно до специфікації JSON відхиляє JSON літерали `true` `false`и`null`, задані не строго в нижньому регістрі, і відповідно встановлює [json\_last\_error()](function.json-last-error.md). Раніше дані, що передаються в [json\_decode()](function.json-decode.md) і що містять виключно одне з цих значень у верхньому або змішаному регістрі приймалися.

Ця зміна вплине тільки у разі передачі в [json\_decode()](function.json-decode.md) некоректного JSON. У разі коректно сформованого JSON ніякого ефекту не буде.

### Тепер потокові обгортки за промовчанням перевіряють сертифікати точок під час використання SSL/TLS

Всі клієнтські потоки, що шифруються, тепер за замовчуванням включають перевірку бенкетів. За замовчуванням сертифікат бенкету перевіряється пакетом OpenSSL CA. Зазвичай нічого не потрібно робити для з'єднання з серверами з правильним SSL-сертифікатом, оскільки OpenSSL налаштований так, що вже працює з хорошими CA-пакетами.

Стандартний CA пакет може бути перевизначений глобально за допомогою установки або openssl.cafile або openssl.capath рядків конфігурації, або ж на рівні кожного запиту, використовуючи опції контексту [`cafile`](context.ssl.md#context.ssl.cafile) або [`capath`](context.ssl.md#context.ssl.capath)

Хоча це і не рекомендується, але можна вимкнути перевірку сертифіката бенкету для запиту, встановивши [`verify_peer`](context.ssl.md#context.ssl.verify-peer)опцию контекста в\*\*`false`**, і можна вимкнути перевірку імені бенкету, встановивши [`verify_peer_name`](context.ssl.md#context.ssl.verify-peer-name)в**`false`\*\*

### Тепер ресурси [GMP](book.gmp.md) є об'єктами

Тепер ресурси [GMP](book.gmp.md) є об'єктами. Функціональне API, реалізоване у модулі GMP, залишилося без змін. Існуючий код має запрацювати без змін, тільки якщо в ньому явно не використовувалися перевірки на ресурс [is\_resource()](function.is-resource.md) або щось подібне.

### Теперь функция[Mcrypt](book.mcrypt.md) вимагає коректні ключі та IV

[mcrypt\_encrypt()](function.mcrypt-encrypt.md) [mcrypt\_decrypt()](function.mcrypt-decrypt.md) **mcrypt\_cbc()** **mcrypt\_cfb()** **mcrypt\_ecb()** [mcrypt\_generic()](function.mcrypt-generic.md)и**mcrypt\_ofb()** більше не приймають ключі і IV з некоректною довжиною, а режими блокового шифру, що вимагають IV, будуть завершуватися помилкою, якщо його не передати.

### Завантаження файлів за допомогою [cURL](book.curl.md)

Тепер завантаження з використанням синтаксису @file потребує встановлення CURLOPT\_SAFE\_UPLOAD в значение\*\*`false`\*\*. Натомість слід використовувати [CURLFile](class.curlfile.md)
