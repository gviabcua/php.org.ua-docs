Зміни, що ламають зворотну сумісність

-   [« Миграция с PHP 5.5.x на PHP 5.6.x](migration56.html)
    
-   [Новые возможности »](migration56.new-features.html)
    
-   [PHP Manual](index.html)
    
-   [Миграция с PHP 5.5.x на PHP 5.6.x](migration56.html)
    
-   Зміни, що ламають зворотну сумісність
    

## Зміни, що ламають зворотну сумісність

Незважаючи на те, що більша частина існуючого коду PHP 5 повинна працювати без змін, все ж таки ознайомтеся з деякими змінами, які можуть позначитися на зворотній сумісності:

### Ключі масиву не будуть перезаписані при визначенні масиву як властивості класу через літерал масиву

Раніше в масивах, задані як властивості класу зі змішаними явними та неявними ключами, елементи з явно заданими ключами могли мовчки перезаписуватись, якщо явний ключ перетинався з послідовним неявним ключем. Наприклад:

```php
<?php
class C {
    const ONE = 1;
    public $array = [
        self::ONE => 'foo',
        'bar',
        'quux',
    ];
}

var_dump((new C)->array);
?>
```

Результат виконання цього прикладу в PHP 5.5:

```
array(2) {
  [0]=>
  string(3) "bar"
  [1]=>
  string(4) "quux"
}
```

Результат виконання цього прикладу в PHP 5.6:

```
array(3) {
  [1]=>
  string(3) "foo"
  [2]=>
  string(3) "bar"
  [3]=>
  string(4) "quux"
}
```

### Суворість [json\_decode()](function.json-decode.html)

Тепер [json\_decode()](function.json-decode.html) відповідно до специфікації JSON відхиляє JSON літерали `true` `false` і `null`, задані не строго в нижньому регістрі, і відповідно встановлює [json\_last\_error()](function.json-last-error.html). Раніше дані, що передаються в [json\_decode()](function.json-decode.html) і що містять виключно одне з цих значень у верхньому або змішаному регістрі приймалися.

Ця зміна вплине тільки у разі передачі в [json\_decode()](function.json-decode.html) некоректного JSON. У разі коректно сформованого JSON ніякого ефекту не буде.

### Тепер потокові обгортки за промовчанням перевіряють сертифікати точок під час використання SSL/TLS

Всі клієнтські потоки, що шифруються, тепер за замовчуванням включають перевірку бенкетів. За промовчанням використовується OpenSSL CA пакет для перевірки сертифіката бенкету. У більшості випадків нічого не потрібно робити для з'єднання з серверами з правильним SSL сертифікатом, так як зазвичай OpenSSL вже налаштований для використання хороших CA пакетів.

Стандартний CA пакет може бути перевизначений глобально за допомогою установки або openssl.cafile або openssl.capath рядків конфігурації, або ж на рівні кожного запиту, використовуючи опції контексту [`cafile`](context.ssl.html#context.ssl.cafile) або [`capath`](context.ssl.html#context.ssl.capath)

Хоча це й не рекомендується, але можна вимкнути перевірку сертифіката бенкету для запиту, встановивши [`verify_peer`](context.ssl.html#context.ssl.verify-peer) опцію контексту в **`false`**, і можна вимкнути перевірку імені бенкету, встановивши [`verify_peer_name`](context.ssl.html#context.ssl.verify-peer-name) в **`false`**

### Тепер ресурси [GMP](book.gmp.html) є об'єктами

Тепер ресурси [GMP](book.gmp.html) є об'єктами. Функціональне API, реалізоване у модулі GMP, залишилося без змін. Існуючий код має запрацювати без змін, тільки якщо в ньому явно не використовувалися перевірки на ресурс [is\_resource()](function.is-resource.html) або щось подібне.

### Тепер функція [Mcrypt](book.mcrypt.html) вимагає коректні ключі та IV

[mcrypt\_encrypt()](function.mcrypt-encrypt.html) [mcrypt\_decrypt()](function.mcrypt-decrypt.html) **mcryptcbc()** **mcryptcfb()** **mcryptecb()** [mcrypt\_generic()](function.mcrypt-generic.html) і **mcryptofb()** більше не приймають ключі та IV з некоректною довжиною, а режими блокового шифру, що вимагають IV, будуть завершуватися помилково, якщо його не передати.

### Завантаження файлів за допомогою [cURL](book.curl.html)

Тепер завантаження за допомогою синтаксису @file потребує встановлення CURLOPTSAFEUPLOAD у значення **`false`**. Натомість слід використовувати [CURLFile](class.curlfile.html)