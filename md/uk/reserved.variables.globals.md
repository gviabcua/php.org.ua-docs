---
navigation:
  - language.variables.superglobals.md: « Суперглобальні змінні
  - reserved.variables.server.md: $\_SERVER »
  - index.md: PHP Manual
  - reserved.variables.md: Зумовлені змінні
title: $GLOBALS
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# $GLOBALS

(PHP 4, PHP 5, PHP 7, PHP 8)

$GLOBALS — Посилання на всі змінні глобальної області видимості

### Опис

Асоціативний масив (array), що містить посилання на всі змінні, визначені зараз у світовій області видимості скрипта. Імена змінних є ключами масиву.

### Приклади

**Приклад #1 Приклад використання $GLOBALS**

```php
<?php
function test() {
    $foo = "локальная переменная";

    echo '$foo в глобальной области видимости: ' . $GLOBALS["foo"] . "\n";
    echo '$foo в текущей области видимости: ' . $foo . "\n";
}

$foo = "Пример содержимого";
test();
?>
```

Висновок наведеного прикладу буде схожим на:

```
$foo в глобальной области видимости: Пример содержимого
$foo в текущей области видимости: локальная переменная
```

**Увага**

Починаючи з PHP 8.1.0, доступ до запису до всього масиву $GLOBALS більше не підтримується:

**Приклад #2 запис всього $GLOBALS призведе до помилки**

```php
<?php
 // Генерирует ошибку во время компиляции:
 $GLOBALS = [];
 $GLOBALS += [];
 $GLOBALS =& $x;
 $x =& $GLOBALS;
 unset($GLOBALS);
 array_pop($GLOBALS);
 // ...и любые другие операции записи/чтения-записи в $GLOBALS
 ?>
```

### Примітки

> **Зауваження** :
> 
> Це «суперглобальна» чи автоматична глобальна змінна. Це просто означає, що вона доступна у всіх контекстах скрипту. Немає необхідності виконувати **global $variable;** для доступу до неї всередині методу чи функції.

> **Зауваження** **Доступність змінної**
> 
> На відміну від решти [суперглобальних](language.variables.superglobals.md) змінних, $GLOBALS завжди доступна в PHP.

> **Зауваження** :
> 
> Починаючи з PHP 8.1.0, масив $GLOBALS є доступною тільки для читання копією глобальної таблиці символів. Тобто, глобальні змінні не можуть бути змінені за допомогою його копії. Раніше масив $GLOBALS виключався зі звичайної поведінки масивів PHP за значенням і глобальні змінні можна змінити за допомогою його копії.
> 
> ```php
> <?php
> // До PHP 8.1.0
> $a = 1;
> $globals = $GLOBALS; // Ніби за значенням копії
> $globals['a'] = 2;
> var_dump($a); // int(2)
> 
> // Починаючи з PHP 8.1.0
> // Більше не змінює значення $a. Попередня поведінка порушувала семантику за значенням
> $globals = $GLOBALS;
> $globals['a'] = 1;
> 
> // Щоб відновити попередню поведінку, повторіть її копію і надайте кожній властивості значення $GLOBALS.
> foreach ($globals as $key => $value) {
>     $GLOBALS[$key] = $value;
> }
> ?>
> ```
