Безпека файлової системи

-   [« Безпека сесій](security.sessions.md)
    
-   [Проблеми безпеки, пов'язані з нульовим байтом.](security.filesystem.nullbytes.md)
    
-   [PHP Manual](index.md)
    
-   [Безпека](security.md)
    
-   Безпека файлової системи
    

# Безпека файлової системи

## Зміст

-   [Проблеми безпеки, пов'язані з нульовим байтом](security.filesystem.nullbytes.md)

PHP є одним із важливих моментів у питанні безпеки сервера, оскільки PHP-скрипти можуть маніпулювати файлами та каталогами на диску. У зв'язку з цим існують конфігураційні установки, які вказують, які файли можуть бути доступні і які операції можна виконувати. Необхідно виявляти обережність, оскільки будь-який із файлів, з повними правами читання ("world readable") може бути прочитаний кожним, хто має доступ до файлової системи.

Оскільки в PHP спочатку передбачався повноправний доступ до файлової системи, можна написати PHPскрипт, який дозволить читати системні файли, такі як /etc/passwd, керувати мережевими з'єднаннями, надсилати завдання принтеру тощо. Як наслідок, ви завжди повинні бути впевнені в тому, що файли, які ви читаєте або модифікуєте, є тими, які ви мали на увазі.

Розглянемо наступний приклад, у якому користувач створив скрипт, який видаляє файл із його домашньої директорії. Передбачається ситуація, коли веб-інтерфейс, написаний на PHP, регулярно використовується для роботи з файлами і налаштування безпеки дозволяють видаляти файли в домашньому каталозі.

**Приклад #1 Недостатня перевірка зовнішніх даних веде до...**

```php
<?php
// Удаление файла из домашней директории пользователя
$username = $_POST['user_submitted_name'];
$userfile = $_POST['user_submitted_filename'];
$homedir  = "/home/$username";

unlink("$homedir/$userfile");

echo "Файл был удалён!";
?>
```

Оскільки змінні вводяться в формі користувача, існує можливість видалити файли, що належать комусь іншому, ввівши відповідні значення. І тут може знадобитися авторизація. Подивимося, що станеться, якщо буде відправлено значення "../etc/" і "passwd". Скрипт виконає такі дії:

**Приклад #2 ... атаці на файлову систему**

```php
<?php
// Удаление любого файла, доступного из PHP-скрипта.
// В случае, если PHP работает с правами пользователя root:
$username = $_POST['user_submitted_name']; // "../etc"
$userfile = $_POST['user_submitted_filename']; // "passwd"
$homedir  = "/home/$username"; // "/home/../etc"

unlink("$homedir/$userfile"); // "/home/../etc/passwd"

echo "Файл был удалён!";
?>
```

Існують два важливі заходи, які можна вжити для запобігання описаній проблемі.

-   Обмежити доступ користувача, з правами якого працює веб-сервер із PHP.
-   Перевіряти всі дані, які користувач вводить.

Ось покращений варіант коду:

**Приклад #3 Безпечніша перевірка імені файлу**

```php
<?php
// Удаление любого файла, к которому имеет доступ пользователь,
// под которым запущен PHP.
$username = $_SERVER['REMOTE_USER']; // использование авторизации
$userfile = basename($_POST['user_submitted_filename']);
$homedir  = "/home/$username";

$filepath = "$homedir/$userfile";

if (file_exists($filepath) && unlink($filepath)) {
    $logstring = "$filepath удалён\n";
} else {
    $logstring = "Не удалось удалить $filepath\n";
}
$fp = fopen("/home/logging/filedelete.log", "a");
fwrite($fp, $logstring);
fclose($fp);

echo htmlentities($logstring, ENT_QUOTES);

?>
```

Однак і така перевірка не враховує всіх можливих ситуацій. Якщо система авторизації дозволяє користувачам вибирати довільні логіни, зломщик може створити обліковий запис виду "../etc/" і система знову виявиться вразливою. Виходячи з цього, вам може знадобитися суворіша перевірка:

**Приклад #4 Суворіша перевірка імені файлу**

```php
<?php
$username     = $_SERVER['REMOTE_USER']; // использование авторизации
$userfile     = $_POST['user_submitted_filename'];
$homedir      = "/home/$username";

$filepath     = "$homedir/$userfile";

if (!ctype_alnum($username) || !preg_match('/^(?:[a-z0-9_-]|\.(?!\.))+$/iD', $userfile)) {
    die("Неправильное имя пользователя или файл");
}

//etc...
?>
```

Залежно від операційної системи, що ви використовуєте, необхідно передбачати можливість атаки на різноманітні файли, включаючи системні файли пристроїв (/dev/ або COM1), конфігураційні файли (наприклад /etc/ або файли з розширенням .ini), добре відомі області зберігання даних (/home /, My Documents), і так далі. Виходячи з цього, як правило, легше реалізувати таку безпекову політику, в якій заборонено все, виключаючи те, що явно дозволено.