---
navigation:
  - language.namespaces.fallback.md: '« Використання просторів імен: перехід до глобальної функції/константи'
  - language.namespaces.faq.md: 'Часті питання (FAQ): речі, які вам необхідно знати про простори імен »'
  - index.md: PHP Manual
  - language.namespaces.md: Пространства имён
title: Правила дозволу імен
---
## Правила дозволу імен

(PHP 5> = 5.3.0, PHP 7, PHP 8)

Для цих правил тут наведено кілька важливих визначень:

**Визначення імені простору імен**

Неповне ім'я

Це ідентифікатор без роздільника просторів імен, наприклад, `Foo`

Повне ім'я

Це ідентифікатор з роздільником просторів імен, наприклад, `Foo\Bar`

Абсолютне ім'я

Це ідентифікатор з роздільником просторів імен, який починається з роздільника просторів імен, наприклад, `\Foo\Bar`. Простір імен `\Foo` також є абсолютним ім'ям.

Відносне ім'я

Це ідентифікатор, що починається з `namespace`, такий як `namespace\Foo\Bar`

Імена дозволяються відповідно до таких правил:

1.  Абсолютні імена завжди дозволяються без провідного роздільника простору імен. Наприклад, `\A\B` дозволяється в `A\B`
2.  Відносні імена завжди дозволяються в імена із заміною `namespace` на поточний простір імен. Якщо ім'я зустрічається у глобальному просторі імен, префікс `namespace\` просто видаляється. Наприклад `namespace\A` усередині простору імен `X\Y` дозволяється в `X\Y\A`. Те саме ім'я в глобальному просторі імен дозволяється в `A`
3.  Для повних імен перший сегмент перетворюється відповідно до поточної таблиці імпорту класу чи простору імен. Наприклад, простір імен `A\B\C` імпортовано як `C`тоді ім'я `C\D\E` перетворюється на `A\B\C\D\E`
4.  Для повних імен, якщо не застосовується жодного правила імпорту, поточний простір імен додається до імені. Наприклад, ім'я `C\D\E` усередині простору імен `A\B`, перетворюється на `A\B\C\D\E`
5.  Для неповних імен імена перетворюються на поточну таблицю імпорту залежно від типу елемента. Це означає, що імена класів перетворюються згідно з таблицею імпорту класів, імена функцій - згідно з таблицею імпорту функцій та константи згідно з таблицею імпорту констант. Наприклад, після `use A\B\C;`, використання `new C()` дозволяється як `A\B\C()`. Аналогічно, після `use function A\B\fn;`, використання `fn()` дозволяється як `A\B\fn`
6.  Неповні імена, якщо відсутні обмеження в таблиці імпорту і якщо вони використовуються як клас, вони дозволяються з префіксом поточного простору імен. Наприклад, `new C()` усередині простору імен `A\B` дозволяються як `A\B\C`
7.  Неповні імена, якщо немає обмежень у таблиці імпорту і якщо вони використовуються як функція або константа, а код знаходиться не в глобальному просторі імен, імена дозволяються під час виконання. Наприклад код, у просторі імен `A\B`, що викликає функцію `foo()`, дозволяється так:
    1.  Виконується пошук функції з поточного простору імен: `A\B\foo()`
    2.  PHP намагається знайти та викликати функцію *глобального простору* `foo()`

**Приклад #1 Приклади дозволу імен**

```php
<?php
namespace A;
use B\D, C\E as F;

// вызовы функций

foo();      // сперва пытается вызвать "foo", определённую в пространстве имён "A",
            // затем вызывает глобальную функцию "foo"

\foo();     // вызывает функцию "foo", определённую в глобальном пространстве

my\foo();   // вызывает функцию "foo", определённую в пространстве "A\my"

F();        // сперва пытается вызвать "F", определённую в пространстве имён "A",
            // затем вызывает глобальную функцию "F"

// ссылки на классы

new B();    // создаёт объект класса "B", определённого в пространстве имён "A".
            // если не найден, то пытается сделать автозагрузку класса "A\B"

new D();    // используя правила импорта, создаёт объект класса "D", определённого в пространстве имён "B"
            // если не найден, то пытается сделать автозагрузку класса "B\D"

new F();    // используя правила импорта, создаёт объект класса "E", определённого в пространстве имён "C"
            // если не найден, то пытается сделать автозагрузку класса "C\E"

new \B();   // создаёт объект класса "B", определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "B"

new \D();   // создаёт объект класса "D", определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "D"

new \F();   // создаёт объект класса "F", определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "F"

// статические методы/функции пространства имён из другого пространства имён

B\foo();    // вызывает функцию "foo" из пространства имён "A\B"

B::foo();   // вызывает метод "foo" из класса "B", определённого в пространстве имён "A"
            // если класс "A\B" не найден, то пытается сделать автозагрузку класса "A\B"

D::foo();   // используя правила импорта, вызывает метод "foo" класса "D", определённого в пространстве имён "B"
            // если класс "B\D" не найден, то пытается сделать автозагрузку класса "B\D"

\B\foo();   // вызывает функцию "foo" из пространства имён "B"

\B::foo();  // вызывает метод "foo" класса "B" из глобального пространства
            // если класс "B" не найден, то пытается сделать автозагрузку класса "B"

// статические методы/функции пространства имён из текущего пространства имён

A\B::foo();   // вызывает метод "foo" класса "B" из пространства имён "A\A"
              // если класс "A\A\B" не найден, то пытается сделать автозагрузку класса "A\A\B"

\A\B::foo();  // вызывает метод "foo" класса "B" из пространства имён "A"
              // если класс "A\B" не найден, то пытается сделать автозагрузку класса "A\B"
?>
```
