---
navigation:
  - language.namespaces.fallback.md: « Повернення до глобального простору
  - language.namespaces.faq.md: FAQ »
  - index.md: PHP Manual
  - language.namespaces.md: Простори імен
title: Правила дозволу імен
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Правила дозволу імен

(PHP 5 >= 5.3.0, PHP 7, PHP 8)

Для цілей цих правил дозволу наведемо важливі визначення:

**Визначення імені простору імен**

Неповне ім'я

Ідентифікатор без роздільника просторів імен, наприклад `Foo`

Повне ім'я

Ідентифікатор з роздільником просторів імен, наприклад `Foo\Bar`

Абсолютне ім'я

Ідентифікатор з роздільником просторів імен, який починається з роздільника просторів імен, наприклад `\Foo\Bar`. Простір імен `\Foo`— также абсолютное имя.

Відносне ім'я

Ідентифікатор, який починається з ключового слова `namespace`, наПриклад`namespace\Foo\Bar`

Імена дозволяються за такими правилами:

1.  Абсолютні імена дозволяються без провідного роздільника простору імен. Наприклад,`\A\B`дозволяється в`A\B`
2.  Відносні імена дозволяються в ім'я із заміною ключового слова`namespace`поточним простором імен. Якщо ім'я зустрічається у глобальному просторі імен, префікс`namespace\`видаляється. Наприклад,`namespace\A`усередині простору імен`X\Y`дозволяється в`X\Y\A`. Те ж ім'я в глобальному просторі імен дозволяється в`A`
3.  У повних іменах перший сегмент імені перетворюється з урахуванням поточної таблиці імпорту класу чи простору імен. Наприклад, якщо простір імен`A\B\C`імпортовано як`C`, то ім'я`C\D\E`преобразуется в`A\B\C\D\E`
4.  У повних іменах, якщо не застосовувалося правило імпорту, поточний простір імен додається до імені. Наприклад, ім'я`C\D\E`усередині простору імен`A\B`вирішиться у`A\B\C\D\E`
5.  Неповні імена перетворюються з урахуванням поточної таблиці імпорту та типу елемента. Тобто імена як класів перетворюються з урахуванням таблиці імпорту класів чи просторів імен, імена функцій — з урахуванням таблиці імпорту функцій, а константи — таблиці імпорту констант. Наприклад, під час запису`use A\B\C;`, виклик`new C()`дозволяється в`A\B\C()`. Аналогічно, під час запису`use function A\B\foo;` виклик `foo()`дозволяється в`A\B\foo`
6.  На початок неповних імен, якщо не застосовувалося правило імпорту та ім'я відноситься до елемента з ім'ям як у класу, додається поточний простір імен. Наприклад, ім'я класу у виразі`new C()`усередині простору імен`A\B`дозволиться в ім'я`A\B\C`
7.  У неповних іменах, якщо не застосовувалося правило імпорту та ім'я відноситься до функції або константи, а код лежить за межами глобального простору імен, ім'я дозволяється під час виконання. Ось як дозволиться виклик функції`foo()`у коді у просторі імен`A\B` :
    1.  Виконується пошук функції з поточного простору імен:`A\B\foo()`
    2.  PHP намагається знайти та викликати функцію`foo()`из*глобального простору імен*

**Приклад #1 Приклади дозволу імен**

```php
<?php

namespace A;
use B\D, C\E as F;

// вызовы функций

foo();      // сперва пытается вызвать функцию foo, определённую в пространстве имён A,
            // затем вызывает глобальную функцию foo

\foo();     // вызывает функцию foo, определённую в глобальном пространстве

my\foo();   // вызывает функцию foo, определённую в пространстве имён A\my

F();        // сперва пытается вызвать функцию F, определённую в пространстве имён A,
            // затем вызывает глобальную функцию F

// ссылки на классы

new B();    // создаёт объект класса B, определённого в пространстве имён A.
            // если не найден, то пытается сделать автозагрузку класса A\B

new D();    // используя правила импорта, создаёт объект класса D, определённого в пространстве имён B
            // если не найден, то пытается сделать автозагрузку класса B\D

new F();    // используя правила импорта, создаёт объект класса E, определённого в пространстве имён C
            // если не найден, то пытается сделать автозагрузку класса C\E

new \B();   // создаёт объект класса B, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса B

new \D();   // создаёт объект класса D, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса D

new \F();   // создаёт объект класса F, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса F

// статические методы/функции пространства имён из другого пространства имён

B\foo();    // вызывает функцию foo из пространства имён A\B

B::foo();   // вызывает метод foo из класса B, определённого в пространстве имён A
            // если класс A\B не найден, то пытается сделать автозагрузку класса A\B

D::foo();   // используя правила импорта, вызывает метод foo класса D, определённого в пространстве имён B
            // если класс B\D не найден, то пытается сделать автозагрузку класса B\D

\B\foo();   // вызывает функцию foo из пространства имён B

\B::foo();  // вызывает метод foo класса B из глобального пространства
            // если класс B не найден, то пытается сделать автозагрузку класса B

// статические методы/функции пространства имён из текущего пространства имён

A\B::foo();   // вызывает метод foo класса B из пространства имён A\A
              // если класс A\A\B не найден, то пытается сделать автозагрузку класса A\A\B

\A\B::foo();  // вызывает метод foo класса B из пространства имён A
              // если класс A\B не найден, то пытается сделать автозагрузку класса A\B

?>
```
