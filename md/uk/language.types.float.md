---
navigation:
  - language.types.integer.md: '" Цілі числа'
  - language.types.string.md: Рядки »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Числа з плаваючою точкою
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Числа з плаваючою точкою

Числа з плаваючою точкою або числа з плаваючою комою (відомі також як "float", "double" або "real") можна визначити наступними синтаксисами:

```php
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
$d = 1_234.567; // начиная с PHP 7.4.0
?>
```

Формально починаючи з PHP 7.4.0 (раніше підкреслення не дозволялося):

```
LNUM          [0-9]+(_[0-9]+)*
DNUM          ({LNUM}?"."{LNUM}) | ({LNUM}"."{LNUM}?)
EXPONENT_DNUM (({LNUM} | {DNUM}) [eE][+-]? {LNUM})
```

Розмір числа з плаваючою точкою залежить від платформи, хоча максимум зазвичай становить 1.8e308 з точністю близько 14 десяткових цифр (64-бітний формат IEEE).

**Увага**

# Точність чисел з плаваючою точкою

Числа з плаваючою точкою мають обмежену точність. Хоча це залежить від операційної системи, PHP зазвичай використовується формат подвійної точності IEEE 754, що дає максимальну відносну помилку округлення порядку 1.11e-16. Неелементарні арифметичні операції можуть давати великі помилки, і, зрозуміло, необхідно брати до уваги поширення помилок під час спільного використання кількох операцій.

Крім того, раціональні числа, які можуть бути представлені у вигляді чисел з плаваючою точкою з основою 10, наприклад, `0.1`или`0.7`, не мають точного внутрішнього подання як чисел з плаваючою точкою з основою 2, незалежно від розміру мантиси. Тому вони і не можуть бути перетворені на їхню внутрішню двійкову форму без невеликої втрати точності. Це може призвести до несподіваних результатів: наприклад, `floor((0.1 + 0.7) * 10)` швидше за все поверне `7` замість очікуваного `8`, так как результат внутреннего представления будет чем-то вроде`7.9999999999999991118...`

Так що ніколи не довіряйте точності чисел з плаваючою точкою до останньої цифри і не перевіряйте прямо їхню рівність. Якщо вам дійсно потрібна висока точність, використовуйте [математичні функції довільної точності](ref.bc.md) і [gmp](ref.gmp.md)\-функції.

«Просте» пояснення можна знайти в [»керівництві за числами з плаваючою точкою](http://floating-point-gui.de/), яка також називається «Why don’t my numbers add up?» («Чому мої числа не складаються?» — англ.)

### Перетворення на число з плаваючою точкою

#### З рядків

Якщо рядок [містить число](language.types.numeric-strings.md) або провідну числову послідовність, тоді вона буде перетворена у відповідне значення з плаваючою точкою, в іншому випадку вона перетворюється на нуль (

#### З інших типів

Для значень інших типів перетворення виконується шляхом перетворення значення спочатку ціле число (int), а потім число з плаваючою точкою ( float ). Дивіться [Перетворення на ціле число](language.types.integer.md#language.types.integer.casting) для отримання додаткової інформації.

> **Зауваження** :
> 
> Оскільки певні типи мають невизначену поведінку при перетворенні на ціле число (int), те саме відбувається і при перетворенні на число з плаваючою точкою (float).

### Порівняння чисел з плаваючою точкою

Як зазначено вище, перевіряти числа з плаваючою точкою на рівність проблематично через їх внутрішнє уявлення. Тим не менш, існують способи їх порівняння, які працюють незважаючи на всі ці обмеження.

Для порівняння чисел з плаваючою точкою використовується верхня межа відносної помилки при заокругленні. Ця величина називається машинною епсілон або одиницею округлення (unit roundoff) і є найменшою допустимою різницею при розрахунках.

$a і $b дорівнюють 5 знакам після точки.

```php
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if (abs($a - $b) < $epsilon) {
    echo "true";
}
?>
```

### NaN

Деякі числові операції можуть повертати значення, яке представляє константа **`NAN`**. Цей результат означає невизначене або непредставлене значення в операціях з точкою, що плаває. Будь-яке суворе чи не суворе порівняння цього значення з іншим значенням, крім **`true`**, включаючи його самого, поверне **`false`**

Так как\*\*`NAN`\*\* є необмежену кількість різних значень, то **`NAN`** не слід порівнювати з іншими значеннями, включаючи її саму. Натомість, для визначення її наявності необхідно використовувати функцію [is\_nan()](function.is-nan.md)
