Виконати команду та відкрити покажчик на файл для введення/виводу

-   [« procnice](function.proc-nice.html)
    
-   [procterminate »](function.proc-terminate.html)
    
-   [PHP Manual](index.md)
    
-   [Функции запуска программ](ref.exec.md)
    
-   Виконати команду та відкрити покажчик на файл для введення/виводу
    

# procopen

(PHP 4> = 4.3.0, PHP 5, PHP 7, PHP 8)

procopen — Виконати команду та відкрити покажчик на файл для введення/виводу

### Опис

```methodsynopsis
proc_open(    array|string $command,    array $descriptor_spec,    array &$pipes,    ?string $cwd = null,    ?array $env_vars = null,    ?array $options = null): resource|false
```

**procopen()** аналогічна [popen()](function.popen.md), але надає набагато більше контролю за виконанням програми.

### Список параметрів

`command`

Командна до виконання, зазначена як рядок (string). Спеціальні символи повинні бути належним чином екрановані, і застосовувати правильні лапки.

> **Зауваження**: В *Windows*, якщо для `bypass_shell` не встановлено значення **`true`** в `options` `command` передається в **cmd.exe** (точніше, `%ComSpec%`) з прапором `/c` у вигляді рядка *без лапок* (тобто точно так, як було задано в **procopen()**). Це може призвести до того, що **cmd.exe** видалить укладають з `command` (подробиці дивіться у документації **cmd.exe**), приводячи до несподіваної та потенційно навіть небезпечної поведінки, тому що повідомлення про помилки **cmd.exe** можуть містити (частково) переданий параметр `command` (Дивіться приклад нижче).

Починаючи з PHP 7.4.0, `command` може передаватися як масив параметрів команди. У цьому випадку процес буде відкритий безпосередньо (не проходячи через оболонку) і PHP подбає про екранування будь-якого необхідного аргументу.

> **Зауваження**
> 
> У Windows екранування аргументу масиву (array) елементів передбачає, що синтаксичний аналіз виконаної команди сумісний із синтаксичним аналізом аргументів командного рядка, що виконуються середовищем виконання VC.

`descriptor_spec`

Масив, ключі якого є номером дескриптора, а значення описує, як PHP повинен передати цей дескриптор дочірньому процесу. 0 - stdin, 1 - stdout і 2 - stderr.

Кожен елемент може бути:

-   Масивом, що описує канал (pipe) передачі процесу. Перший елемент – це дескриптор типу, другий – налаштування для обраного типу. Можливі типи: `pipe` (другий елемент або `r` для передачі процесу сторони каналу для читання, або `w` для передачі сторони запису) та `file` (Другий елемент – ім'я файлу). Зверніть увагу, що все, крім `w`, обробляється як `r`
-   Ресурс потоку, що представляє дескриптор файлу (наприклад, відкритий файл, сокет, **`STDIN`**

Номери дескрипторів не обмежені лише 0, 1 та 2 - ви можете призначити будь-який дійсний номер дескриптора і він буде переданий дочірньому процесу. Це дозволяє скрипту взаємодіяти з іншими скриптами, що працюють як паралельні процеси. Зокрема, таким чином можна передавати дані, що потребують захисту, у програми на зразок PGP, GPG та openssl безпечніше. Також це може виявитися корисним для читання статусної інформації, яку надають ці програми на допоміжних файлових дескрипторах.

`pipes`

Буде заданий масивом покажчиків на файли, що відповідають створеним каналам передачі PHP.

`cwd`

Робоча директорія команди. Це має бути *абсолютний* шлях до директорії або **`null`**, якщо потрібно використовувати директорію за замовчуванням (Робоча директорія поточного процесу PHP).

`env_vars`

Масив змінних оточення для команди, що запускається, або **`null`**, якщо потрібно використовувати те саме оточення, що й у поточного PHP-процесу.

`options`

Дозволяє встановити додаткові параметри. На даний момент підтримуються такі налаштування:

-   `suppress_errors` (лише для Windows): під час встановлення в **`true`** не будуть показуватися помилки, що виникають під час роботи функції
-   `bypass_shell` (лише для Windows): під час встановлення в **`true`** процес буде запущений в обхід оболонки `cmd.exe`
-   `blocking_pipes` (лише для Windows): примусово блокувати потік під час значення **`true`**
-   `create_process_group` (тільки для Windows): дозволити дочірньому процесу обробляти `CTRL` події, якщо встановлено значення **`true`**
-   `create_new_console` (лише для Windows): новий процес використовує нову консоль, а не успадковує консоль свого батька

### Значення, що повертаються

Повертає ресурс, який представляє процес. Цей ресурс необхідно звільняти функцією [procclose()](function.proc-close.html) після завершення роботи з ним. У разі виникнення помилки повертає **`false`**

### список змін

| Версия | Описание |
| --- | --- |
|  | Додана опція `create_new_console` у параметр `options` |
|  | **procopen()** тепер також приймає масив (array) у `command` |
|  | Додана опція `create_process_group` у параметр `options` |

### Приклади

**Приклад #1 Приклад використання **procopen()****

```php
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin - канал, из которого дочерний процесс будет читать
   1 => array("pipe", "w"),  // stdout - канал, в который дочерний процесс будет записывать
   2 => array("file", "/tmp/error-output.txt", "a") // stderr - файл для записи
);

$cwd = '/tmp';
$env = array('some_option' => 'aeiou');

$process = proc_open('php', $descriptorspec, $pipes, $cwd, $env);

if (is_resource($process)) {
    // $pipes теперь выглядит так:
    // 0 => записывающий обработчик, подключённый к дочернему stdin
    // 1 => читающий обработчик, подключённый к дочернему stdout
    // Вывод сообщений об ошибках будет добавляться в /tmp/error-output.txt

    fwrite($pipes[0], '<?php print_r($_ENV); ?>');
    fclose($pipes[0]);

    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);

    // Важно закрывать все каналы перед вызовом
    // proc_close во избежание мёртвой блокировки
    $return_value = proc_close($process);

    echo "команда вернула $return_value\n";
}
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
Array
(
    [some_option] => aeiou
    [PWD] => /tmp
    [SHLVL] => 1
    [_] => /usr/local/bin/php
)
команда вернула 0
```

**Приклад #2 **procopen()** примха в Windows**

Хоча можна очікувати, що наступна програма шукатиме у файлі filename.txt текст `search` і виводити результати, вона поводиться трохи інакше.

```php
<?php
$descriptorspec = [STDIN, STDOUT, STDOUT];
$cmd = '"findstr" "search" "filename.txt"';
$proc = proc_open($cmd, $descriptorspec, $pipes);
proc_close($proc);
?>
```

Результат виконання цього прикладу:

```
'findstr" "search" "filename.txt' не распознается как внутренняя или внешняя команда,
работающая программа или пакетный файл.
```

Щоб оминути цю поведінку, зазвичай достатньо передати `command` у додаткових лапках:

```php
$cmd = '""findstr" "search" "filename.txt""';
```

### Примітки

> **Зауваження**
> 
> Сумісність з Windows: Дескриптори далі 2 (stderr) успадковуються дочірніми процесами, однак відколи Windows не асоціює номери файлових дескрипторів з низькорівневими обробниками, дочірні процеси не мають (поки) до них доступу. Це не стосується stdin, stdout і stderr.

> **Зауваження**
> 
> Якщо потрібний односпрямований канал процесу, використовуйте функцію [popen()](function.popen.md), оскільки вона значно простіша у використанні.

### Дивіться також

-   [popen()](function.popen.md) - Відкриває файловий покажчик процесу
-   [exec()](function.exec.md) - Виконати зовнішню програму
-   [system()](function.system.md) - Виконати зовнішню програму та відобразити висновок
-   [passthru()](function.passthru.md) - Виконати зовнішню програму та відобразити необроблений висновок
-   [streamselect()](function.stream-select.html) - Запускає еквівалент системного виклику select() на заданих масивах потоків з часом очікування, вказаним параметрами seconds та microseconds
-   [Оператор зворотний апостроф](language.operators.execution.md)