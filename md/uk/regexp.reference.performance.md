Продуктивність

-   [« Рекурсивные шаблоны](regexp.reference.recursive.html)
    
-   [Описывает возможные модификаторы шаблонов Perl-совместимых регулярных выражений (PCRE) »](reference.pcre.pattern.modifiers.html)
    
-   [PHP Manual](index.html)
    
-   [Описание синтаксиса Perl-совместимых регулярных выражений](reference.pcre.pattern.syntax.html)
    
-   Продуктивність
    

## Продуктивність

Деякі елементи, які можуть зустрічатися в шаблонах, є більш ефективними, ніж інші. Наприклад, набагато ефективніше використовувати символьний клас aeiou замість набору альтернатив (a|e|i|o|u). Як правило, простіша конструкція є більш ефективною. Книга Джеффрі Фрідла містить багато обговорень щодо оптимізації регулярних виразів.

Якщо шаблон починається з . та використовується прапор [PCRE\_DOTALL](reference.pcre.pattern.modifiers.html), шаблон неявно заякорюється, оскільки він може збігатися лише на початку рядка. Але якщо [PCRE\_DOTALL](reference.pcre.pattern.modifiers.html) не використовується, PCRE не може виконати відповідну оптимізацію, тому що в такому випадку метасимвол '.' не відповідає символу початку рядка (якщо дані, що обробляються, містять переклади рядків, такий шаблон може відповідати шаблону не від початку рядка, а від позиції безпосередньо після перекладу рядка). Наприклад, застосовуючи шаблон `(.*) second` до рядка "firstnand second" (де n означає символ перекладу рядка), значення, захоплене першою підмаскою, буде 'and'. Щоб обробити всі можливі точки відповідності, PCRE намагається зіставити шаблон після кожного символу перекладу рядка.

У випадку, якщо ви використовуєте подібні шаблони для обробки даних, що не містять перекладів рядків, для кращої продуктивності використовуйте модифікатор [PCRE\_DOTALL](reference.pcre.pattern.modifiers.html)або починайте шаблон з ^. для вказівки явного заякорювання. Це запобігатиме PCRE від пошуку символів нових рядків і додаткових спроб зіставити шаблон з кожною такою знайденою позицією.

Уникайте шаблонів, які містять вкладені необмежені повторення. Зіставлення їх із рядками, які містять збігів, займає тривалий час. Розглянемо приклад шаблону `(a+)*`

Він може відповідати з "aaaa" 33 різними способами, і ця цифра дуже швидко зростає при збільшенні рядка. (У цьому прикладі, квантифікатор може збігатися 0, 1, 2, 3 або 4 рази, і для кожного такого випадку, крім нуля, квантифікатор + також може збігатися різне число разів.) Якщо залишок шаблону такий, що весь збіг зазнає невдачі, PCRE повинна спробувати всі можливі варіанти збігу що може вимагати величезної кількості часу.

За допомогою оптимізації можна відловити найпростіші випадки, такі як `(a+)*b` де слідом йде літеральний символ. Перш, ніж проводити стандартну процедуру пошуку, PCRE перевіряє у наступному підрядку наявність символу 'b', і, у разі відсутності такого, спроба зіставлення негайно завершується невдачею. Однак, коли наступного літералу немає, оптимізація не може бути застосована. Ви можете відчути різницю, порівнявши поведінку `(a+)*\d` з поведінкою наведеного вище шаблону. Перший визначає неможливість зіставлення практично відразу ж, при зіставленні з рядком, що складається з символів 'a', тоді як другий витрачає тривалий час на пошук у рядках довше 20 символів.