---
navigation:
  - regexp.reference.meta.md: « Метасимволи
  - regexp.reference.unicode.md: Властивості Unicode-символів »
  - index.md: PHP Manual
  - reference.pcre.pattern.syntax.md: Опис синтаксису Perl-сумісних регулярних виразів
title: Екрануючі послідовності
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Екрануючі послідовності

Зворотня коса риса («\\») має кілька призначень. Насамперед, якщо вона передує не буквенно-цифровому символу, вона знімає з нього спеціальне значення, яке міг мати. Застосування зворотної косої риси як символу, що екранує, припустимо як у символьному класі, так і поза ним.

Наприклад, якщо потрібно задати відповідність символу «\*», у шаблоні вказують «\\\*». Це запобігатиме трактуванню наступного символу як метасимволу з особливим значенням. У будь-яких випадках безпечно екранувати не буквено-цифрові символи символом зворотної косої риси.\\», якщо потрібно переконатися, що вони означають у шаблоні себе. В окремому випадку для порівняння з самим символом зворотної косої межі, використовуйте запис «\\\\».

> **Зауваження** :
> 
> [PHP-рядки](language.types.string.md#language.types.string.syntax), Укладені в одинарні і подвійні лапки, по-особливому інтерпретують зворотну косу межу. Таким чином, якщо необхідно порівняти \\ з регулярним виразом \\\\, у PHP-коді потрібно використовувати "\\\\\\\\"або"\\\\\\\\'.

Якщо вказано модифікатор [PCRE\_EXTENDED](reference.pcre.pattern.modifiers.md), пробілові символи шаблону (поза описом символьного класу) ігноруються. Також ігнорується частина рядка, що знаходиться між символом «#» (знову ж таки, що не бере участі в описі символьного класу) і наступним символом перекладу рядка. У цій ситуації зворотний сліш можна застосовувати як екрануючий символ для вказівки входжень пробельних символів або символу # у шаблоні.

Друге застосування зворотного слеша полягає в тому, що він дозволяє використовувати недруковані символи у видимій формі в описі шаблону. При тому, що в PCRE немає обмежень на використання недрукованих символів (за винятком бінарного нуля, який інтерпретується як кінець шаблону), при редагуванні програмного коду в якомусь текстовому редакторі набагато зручніше використовувати такі комбінації, ніж реальні символи, які вони представляють:

*\\a*

символ оповіщення, сигнал (BEL, шістнадцятковий код 07)

*\\cx*

"control+x", де x - довільний символ

*\\e*

escape (шістнадцятковий код 1B)

*\\f*

розрив сторінки (шістнадцятковий код 0C)

*\\n*

переклад рядка (шістнадцятковий код 0A)

*\\p{xx}*

символ із властивістю xx, докладніше про це розказано у розділі «[Властивості Unicode-символів](regexp.reference.unicode.md)»

*\\P{xx}*

символ без властивості xx, докладніше про це розказано у розділі «[Властивості Unicode-символів](regexp.reference.unicode.md)»

*\\r*

повернення каретки (шістнадцятковий код 0D)

*\\R*

розрив рядка: збігається з \\n,\\r и\\r\\n

*\\t*

табуляція (шістнадцятковий код 09)

*\\xhh*

символ з шістнадцятковим кодом hh

*\\ddd*

символ із вісімковим кодом ddd, або посилання на підмаску

Якщо бути точнішим, комбінація «`\cx`» інтерпретується так: якщо «`x`» - символ нижнього регістру, він перетворюється на верхній регістр. Після цього шостий біт символу (шістнадцятковий код 40) інвертується. Таким чином, "`\cz`» інтерпретується як шістнадцяткове значення 1A, тоді як «`\c{`» отримує шістнадцяткове значення 3B, а «`\c;`» — 7B.

Після «`\x`» зчитуються ще дві шістнадцяткові цифри (вони можуть бути записані в нижньому або верхньому регістрі). У *режимі UTF-8*, дозволяється використання «`\x{...}`», де вміст дужок є рядком із шістнадцяткових цифр. Вона інтерпретується як символ UTF-8 character з кодом, що збігається з цим шістнадцятковим числом. Вихідна шістнадцяткова екрануюча послідовність, `\xhh`, збігається з двобайтним UTF-8 символом, якщо його значення перевищує 127.

Після «`\0`» зчитуються дві вісімкові цифри. Якщо в записі менше двох цифр, будуть використані всі цифри, що фактично присутні. Таким чином, послідовність`\0\x\07`» буде інтерпретована як два бінарних нулі, за якими слідує символ оповіщення (дзвінок). Якщо ви використовуєте подання числа у вісімковому коді, переконайтеся, що за початковим нулем йдуть дві цифри.

Обробка зворотного сліша, за яким слідує ненульова цифра, дещо складніше. Поза символьного класу PCRE сприймає зворотний слєш і такі цифри як десяткове число. Якщо отримане значення менше десяти, або якщо шаблон містить щонайменше таку кількість попередніх поточної позиції підмасок, вся конструкція інтерпретується як *посилання на підмаску*. Більш детальний опис буде наведено нижче під час обговорення механізму роботи підмасок.

Всередині символьного класу, або якщо отримане значення більше 9 і відповідна кількість попередніх підмасок відсутня, PCRE зчитує до трьох вісімкових цифр, що йдуть за зворотним слешем, і генерує один байт з останніх 8 значних бітів отриманого значення. Усі наступні цифри позначають себе. Наприклад:

*\\040*

ще один спосіб запису пробілу

*\\40*

те саме, якщо даного запису передує менше сорока підмасок

*\\7*

завжди інтерпретується як посилання на підмаску

*\\11*

може бути як зворотним посиланням, так і альтернативним записом символу табуляції

*\\011*

завжди інтерпретується як символ табуляції

*\\0113*

символ табуляції, за яким слідує цифра «3»

*\\113*

інтерпретується як символ з вісімковим кодом 113 (оскільки посилань на підмаски не може бути більш ніж 99)

*\\377*

байт, що повністю складається з одиничних бітів

*\\81*

або зворотне посилання, або бінарний нуль, за яким йдуть цифри «8» і «1»

Слід пам'ятати, що вісімкові значення, що перевищують 100, слід писати без лідируючого нуля, тому що читається не більше трьох вісімкових цифр.

Усі послідовності, що визначають однобайтне значення, можуть зустрічатися як усередині, так і поза символьними класами. Крім того, всередині символьного класу запис «`\b`» інтерпретується як символ повернення («backspace», шістнадцятковий код 08). Поза символьним класом вона має інше значення (яке саме, описано нижче).

Третє використання зворотного сліша - вказівка ​​загального типу символів:

*\\d*

будь-яка десяткова цифра

*\\D*

будь-який символ, крім десяткової цифри

*\\h*

будь-який горизонтальний символ пробілу

*\\H*

будь-який символ, що не є горизонтальним символом пробілу

*\\s*

будь-який пробіловий символ

*\\S*

будь-який непробільний символ

*\\v*

будь-який вертикальний символ пробілу

*\\V*

будь-який символ, що не є вертикальним символом пробілу

*\\w*

Будь-який символ, що утворює «слово»

*\\W*

Будь-який символ, що не утворює «слово»

Кожна пара таких спеціальних послідовностей ділить повну множину всіх символів на дві множини, що не перетинаються. Будь-який символ відповідає одній і тільки одній множині з пари.

Наступні символи вважаються «пробільні»: HT (9), LF (10), FF (12), CR (13), і пробіл (32). Тим не менш, якщо йде локале-залежний пошук, і відбудеться збіг з символами в діапазоні 128-255, вони також будуть сприйняті як пробільні, наприклад, NBSP (A0).

Символ, що утворює «слово» - це довільна цифра, буква або символ підкреслення, простіше кажучи, будь-який символ, який може бути частиною «*слова*» у Perl. Визначення літер та цифр управляється символьними таблицями, з якими було зібрано PCRE. І, як наслідок, ці набори можуть відрізнятися у різних локалізованих дистрибутивах. Наприклад, у локалі «fr» (Франція) ряд символів із кодом вище 128 застосовують для запису ударних символів і тому вони відповідають масці `\w`

Наведені вище типи символів можуть застосовуватися як усередині, так і поза символьними класами, і відповідають одному символу даного типу. Якщо поточна точка порівняння знаходиться в кінці рядка, жоден з них не зможе збігтися, тому що немає символу, з яким може статися збіг.

Четверте використання зворотного слеша — визначення деяких формальних тверджень, що описують умови щодо розташування особливих позицій у рядку і зовсім не зачіпають самі символи. Використання підмасок як складніших формальних тверджень описано нижче. Такими керуючими послідовностями є:

*\\b*

межа слова

*\\B*

не є межею слова

*\\A*

початок даних (незалежно від багаторядкового режиму)

*\\Z*

кінець даних чи позиція перед останнім перекладом рядка (незалежно від багаторядкового режиму)

*\\z*

кінець даних (незалежно від багаторядкового режиму)

*\\G*

перша позиція, що збігається в рядку

Описані вище послідовності що неспроможні зустрічатися у символьних класах (виключаючи комбінацію «`\b`», що всередині класу означає символ повернення «backspace»).

Кордоном слова вважається така позиція у рядку, в якому з поточного та попереднього символу лише один відповідає `\w`или`\W` (тобто один з них відповідає `\w`, а другой`\W`). Початок або кінець рядка також відповідають межі слова Якщо перший або відповідно останній символ збігається з `\w`

Спеціальні послідовності `\A` `\Z`и`\z` відрізняються від загальновживаних метасимволів початку рядка («^») і кінця рядка («$»), описаних у розділі «[Якоря](regexp.reference.anchors.md)», тим, що вони завжди збігаються або на самому початку або наприкінці рядка. На них ніяк не впливають опції [PCRE\_MULTILINE](reference.pcre.pattern.modifiers.md) і [PCRE\_DOLLAR\_ENDONLY](reference.pcre.pattern.modifiers.md)Разница между`\Z`и`\z` у тому, що `\Z` відповідає позиції перед останнім символом Якщо останній символ — переклад рядка, крім кінця кінця рядка. В той час як `\z` відповідає виключно кінцю даних.

Утверждение`\G` є дійсним тільки в тому випадку, якщо поточна позиція знаходиться на початку збігу, вказаного параметром `offset` функції [preg\_match()](function.preg-match.md)Она отличается от`\A`при ненулевом значении параметра`offset`

`\Q`и`\E` можуть бути використані для ігнорування метасимволів регулярних виразів у шаблоні. Наприклад: `\w+\Q.$.\E$` збігається з одним або більше символів, що становлять «слово», за якими слідують символи `.$.` і якір в кінці рядка. Зауважте, що це не змінює поведінки роздільників; наприклад, шаблон `#\Q#\E#$` некоректний, бо другий `#` відзначає кінець шаблону, а `\E#` інтерпретується як неприпустимі модифікатори.

Послідовність `\K` може бути використана для скидання початку збігу. Наприклад, шаблон `foo\Kbar` збігається з "foobar", але повідомить про те, що збігся тільки з "bar". Використання `\K`не мешает установке подмасок. НаПриклад, если шаблон`(foo)\Kbar` збігається з рядком "foobar", першою підмаскою все одно буде "foo".
