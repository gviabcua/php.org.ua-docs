---
navigation:
  - language.enumerations.basics.html: « Основи перерахувань
  - language.enumerations.methods.html: Методи перерахувань »
  - index.html: PHP Manual
  - language.enumerations.html: Перечисления
title: Типізовані перерахування
---
## Типізовані перерахування

За замовчуванням варіанти перерахувань не мають скалярного еквівалента. Це просто одноелементні об'єкти. Однак існує безліч випадків, коли варіанти перерахувань повинні мати можливість звертатися до бази даних або аналогічного сховища даних і назад, тому корисно мати вбудований скалярний (і отже тривіально серіалізується) еквівалент, визначений внутрішньо.

Щоб визначити скалярний еквівалент для перерахувань, використовуйте наступний синтаксис:

```php
<?php

enum Suit: string
{
    case Hearts = 'H';
    case Diamonds = 'D';
    case Clubs = 'C';
    case Spades = 'S';
}
?>
```

Варіант, що має скалярний еквівалент, називається типізованим, оскільки він "підтримується" більш простим значенням. Перелік, у якого всі варіанти типізовані, називається "типізованим перерахуванням". Типізований перелік може містити лише типізовані варіанти. Чисте перерахування може містити лише чисті варіанти.

Типізований перелік може підтримуватись типами `int` або `string` і цей перелік підтримує лише один тип за раз (тобто не допускається об'єднання `int|string`). Якщо перелік позначений як той, що має скалярний еквівалент, тоді всі варіанти повинні мати певний явно унікальний скалярний еквівалент. Не існує скалярних еквівалентів, що автоматично генеруються (наприклад, послідовних цілих чисел). Типізовані варіанти мають бути унікальними; два варіанти типізованого перерахування не можуть мати одного й того ж скалярного еквівалента. Однак константа може належати до варіанта, фактично створюючи псевдонім. Дивіться [Константи перерахувань](language.enumerations.constants.html)

Еквівалентні значення мають бути рядками або рядковими виразами. Константи та постійні вирази не підтримуються. Тобто `1 + 1` дозволено, а `1 + SOME_CONST` - Ні.

Типизовані варіанти мають додаткову властивість, доступну тільки для читання, `value`що є значенням, зазначеним у визначенні.

```php
<?php
print Suit::Clubs->value;
// Выведет "C"
?>
```

Щоб зробити властивість `value` доступним тільки для читання, не можна призначити змінну як посилання на неї. Тобто наступний код видасть помилку:

```php
<?php
$suit = Suit::Clubs;
$ref = &$suit->value;
// Error: Cannot acquire reference to property Suit::$value
?>
```

Типізовані перерахування реалізують внутрішній інтерфейс [BackedEnum](class.backedenum.html), який надає два додаткові методи:

-   `from(int|string): self` візьме скаляр та поверне відповідний варіант перерахування. Якщо варіант не знайдено, метод видасть [ValueError](class.valueerror.html). Це корисно у випадках, коли вхідний скаляр є довіреним, а відсутність значення перерахування слід як помилку зупинки докладання.
-   `tryFrom(int|string): ?self` візьме скаляр та поверне відповідний варіант перерахування. Якщо варіант не знайдено, метод поверне `null`. Це корисно в тих випадках, коли вхідний скаляр не є довіреним і функція, що викликає, хоче реалізувати свою власну обробку помилок або логіку значення за умовчанням.

Методи `from()` і `tryFrom()` дотримуються стандартних правил слабкої/суворої типізації. У режимі слабкої типізації допустима передача цілого числа або рядка та система відповідним чином перетворює значення. Передача числа з плаваючою точкою також працюватиме з примусовим перетворенням. У режимі суворої типізації передача цілого числа `from()` у перерахунку з рядковою типізацією (або навпаки) призведе до [TypeError](class.typeerror.html), як і передача числа з плаваючою точкою за будь-яких обставин. Всі інші типи параметрів викликають помилку TypeError в обох режимах.

```php
<?php
$record = get_stuff_from_database($id);
print $record['suit'];

$suit =  Suit::from($record['suit']);

// Недопустимые данные выдают ошибку ValueError: "X" не является допустимым скалярным значением для перечисления "Suit"
print $suit->value;

$suit = Suit::tryFrom('A') ?? Suit::Spades;

// Недопустимые данные возвращают значение null, поэтому вместо этого используется Suit::Spades.
print $suit->value;
?>
```

Ручне визначення методу `from()` або `tryFrom()` у типізованих переліках призведе до фатальної помилки.
