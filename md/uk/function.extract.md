---
navigation:
  - function.end.md: « end
  - function.in-array.md: in\_array »
  - index.md: PHP Manual
  - ref.array.md: Функції для роботи з масивами
title: extract
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# extract

(PHP 4, PHP 5, PHP 7, PHP 8)

extract — Імпортує змінні масиву до поточної таблиці символів

### Опис

```methodsynopsis
extract(array &$array, int $flags = EXTR_OVERWRITE, string $prefix = ""): int
```

Імпортує змінні масиву до поточної таблиці символів.

Функція перевіряє кожен ключ масиву, щоб побачити, чи він містить допустиме ім'я змінної. Буде також перевірено збіги (колізії) з існуючими змінними у таблиці символів.

**Увага**

Не викликайте функції **extract()** з ненадійними даними на кшталт введення користувача (наприклад, з суперглобальними змінними [$\_GET](reserved.variables.get.md) [$\_FILES](reserved.variables.files.md)

### Список параметрів

`array`

Асоціативний масив. Функція трактує ключі масиву як імена змінних, а значення як значення змінних. Для кожної пари ключ/значення буде створено змінну в поточній таблиці символів з урахуванням прапорів (`flags`) та параметрів префікса (`prefix`

Без прапорів **`EXTR_PREFIX_ALL`** або **`EXTR_PREFIX_INVALID`** функція працює лише з асоціативними масивами; індексний масив не дасть результатів.

`flags`

Параметр`flags` визначає спосіб трактування неправильних/числових ключів та колізій. Дозволено вказувати одне з наступних значень:

**`EXTR_OVERWRITE`**

Якщо змінна з такою назвою існує, вона буде перезаписана.

**`EXTR_SKIP`**

Якщо змінна з такою назвою існує, її поточне значення не буде перезаписано.

**`EXTR_PREFIX_SAME`**

Якщо змінна з таким ім'ям існує, до її імені буде додано префікс, визначений параметром `prefix`

**`EXTR_PREFIX_ALL`**

Добавить префикс`prefix` до всіх імен змінних.

**`EXTR_PREFIX_INVALID`**

Добавить префикс`prefix` тільки до некоректних/числових імен змінних.

**`EXTR_IF_EXISTS`**

Перезаписати лише ті змінні, які містяться в поточній таблиці символів, інакше нічого не робити. Це корисно для визначення списку допустимих змінних і вилучення тільки тих, які розробник вже визначив, наприклад, з масиву на кшталт [$\_REQUEST](reserved.variables.request.md)

**`EXTR_PREFIX_IF_EXISTS`**

Створити лише префікс-версії змінних, якщо версія змінної без префікса вже міститься у поточній таблиці символів.

**`EXTR_REFS`**

Витягти змінні як посилання. Це фактично означає, що значення імпортованих змінних все ще посилатимуться на значення масиву `array`. Дозволено вказувати цей прапор окремо або комбінувати його з іншими значеннями параметра `flags`через побитовое «ИЛИ».

Якщо параметр `flags` не заданий, він трактується як прапор **`EXTR_OVERWRITE`**

`prefix`

Зверніть увагу, що префікс (`prefix`) потрібен, тільки якщо параметру `flags`установлено значение\*\*`EXTR_PREFIX_SAME`\*\* **`EXTR_PREFIX_ALL`** \*\*`EXTR_PREFIX_INVALID`** або **`EXTR_PREFIX_IF_EXISTS`\*\*Если в результате добавления префикса не будет получено допустимое имя переменной, она не будет импортирована в текущую таблицу символов.

### Значення, що повертаються

Повертає кількість змінних, успішно імпортованих до таблиці символів.

### Приклади

**Приклад #1 Приклад використання функції** extract()\*\*\*\*

Функцию**extract()** також викликають для імпорту в таблицю символів змінних, що містяться в асоціативному масиві, що повертається функцією [wddx\_deserialize()](function.wddx-deserialize.md)

```php
<?php

/* Предположим, что переменная $var_array — это массив, который вернула
   функция wddx_deserialize */

$size = "large";
$var_array = array(
     "color" => "blue",
     "size"  => "medium",
     "shape" => "sphere"
);
extract($var_array, EXTR_PREFIX_SAME, "wddx");

echo "$color, $size, $shape, $wddx_size\n";

?>
```

Результат виконання наведеного прикладу:

```
blue, large, sphere, medium
```

Змінна $size не була перезаписана, тому що було встановлено прапор \*\*`EXTR_PREFIX_SAME`\*\*тому була створена змінна $wddx\_size. Якби був визначений прапор \*\*`EXTR_SKIP`\*\*тоді змінна $wddx\_size не було б створено. Прапор **`EXTR_OVERWRITE`** привів би до того, що змінною $size було б надано значення «medium», а прапор **`EXTR_PREFIX_ALL`** був би причиною того, що були б створені змінні $wddx\_color, $wddx\_size та $wddx\_shape.

### Примітки

**Увага**

Не варто викликати функцію **extract()** з ненадійними даними на кшталт введення користувача (наприклад, з суперглобальними змінними [$\_GET](reserved.variables.get.md) [$\_FILES](reserved.variables.files.md)). Коли це таки роблять, перевіряють, що значення параметра `flags` задано неперезаписуючим прапором на кшталт **`EXTR_SKIP`**, і пам'ятають, що змінні потрібно витягувати в тому самому порядку, який визначений у директиві [variables\_order](ini.core.md#ini.variables-order)файла[php.ini](ini.md)

### Дивіться також

-   [compact()](function.compact.md) \- Створює масив, що містить назви змінних та їх значення
-   [list()](function.list.md) \- надає змінним значення схожим на масиви синтаксисом
