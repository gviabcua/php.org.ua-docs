Імпортує змінні з масиву до поточної таблиці символів

-   [« end](function.end.html)
    
-   [in\_array »](function.in-array.html)
    
-   [PHP Manual](index.html)
    
-   [Функции для работы с массивами](ref.array.html)
    
-   Імпортує змінні з масиву до поточної таблиці символів
    

# extract

(PHP 4, PHP 5, PHP 7, PHP 8)

extract — Імпортує змінні з масиву до поточної таблиці символів

### Опис

```methodsynopsis
extract(array &$array, int $flags = EXTR_OVERWRITE, string $prefix = ""): int
```

Імпортує змінні з масиву до поточної таблиці символів.

Кожен ключ перевіряється щодо коректного імені змінної. Також перевіряються збіги з змінними в символьній таблиці.

**Увага**

Не використовуйте **extract()** на неперевірених даних, таких як введення користувача (наприклад, [$\_GET](reserved.variables.get.html) [$\_FILES](reserved.variables.files.html)

### Список параметрів

`array`

Асоціативний масив. Ця функція розглядає ключі масиву як імена змінних, а їх значення - як значення цих змінних. Для кожної пари ключ/значення буде створено змінну в поточній таблиці символів відповідно до параметрів `flags` і `prefix`

Ви повинні використовувати асоціативний масив, використання числових масивів не призведе до жодних результатів, якщо ви не використовуєте **`EXTR_PREFIX_ALL`** або **`EXTR_PREFIX_INVALID`**

`flags`

Параметр `flags` визначає спосіб трактування неправильних/числових ключів та колізій. Він може приймати такі значення:

**`EXTR_OVERWRITE`**

Якщо змінна з такою назвою існує, вона буде перезаписана.

**`EXTR_SKIP`**

Якщо змінна з такою назвою існує, її поточне значення не буде перезаписано.

**`EXTR_PREFIX_SAME`**

Якщо змінна з таким ім'ям існує, до її імені буде додано префікс, визначений параметром `prefix`

**`EXTR_PREFIX_ALL`**

Додати префікс `prefix` до всіх імен змінних.

**`EXTR_PREFIX_INVALID`**

Додати префікс `prefix` тільки до некоректних/числових імен змінних.

**`EXTR_IF_EXISTS`**

Перезаписати лише змінні, які вже є в поточній таблиці символів, інакше не робити нічого. Дана можливість корисна для визначення списку прийнятних змінних та для вилучення тільки тих змінних, які ви вже визначили з масивів типу [$\_REQUEST](reserved.variables.request.html)наприклад.

**`EXTR_PREFIX_IF_EXISTS`**

Створити лише префікс-версії змінних, якщо версія цієї змінної без префікса вже існує у поточній символьній таблиці.

**`EXTR_REFS`**

Витягти змінні як посилання. Це означає, що значення таких змінних все ще посилатимуться на значення масиву `array`. Ви можете використовувати цей прапор окремо або комбінувати його з іншими значеннями `flags` за допомогою побитового 'або'.

Якщо `flags` не вказано, він трактується як **`EXTR_OVERWRITE`**

`prefix`

Зверніть увагу, що `prefix` має значення тільки якщо `flags` встановлений в **`EXTR_PREFIX_SAME`** **`EXTR_PREFIX_ALL`** **`EXTR_PREFIX_INVALID`** або **`EXTR_PREFIX_IF_EXISTS`**. Якщо в результаті додавання префікса, не буде отримано допустиме ім'я для змінної, вона не буде імпортована до поточної символьної таблиці.

### Значення, що повертаються

Повертає кількість змінних, успішно імпортованих до поточної таблиці символів.

### Приклади

**Приклад #1 Приклад використання **extract()****

функцію **extract()** також можна використовувати для імпорту в поточну таблицю змінних символів, що містяться в асоціативному масиві, що повертається функцією [wddx\_deserialize()](function.wddx-deserialize.html)

```php
<?php

/* Предположим, что $var_array - это массив, полученный в результате
   wddx_deserialize */

$size = "large";
$var_array = array("color" => "blue",
                   "size"  => "medium",
                   "shape" => "sphere");
extract($var_array, EXTR_PREFIX_SAME, "wddx");

echo "$color, $size, $shape, $wddx_size\n";

?>
```

Результат виконання цього прикладу:

```
blue, large, sphere, medium
```

Змінна $size не була перезаписана, тому що ми визначили **`EXTR_PREFIX_SAME`**, внаслідок чого було створено змінну $wddxsize. Якби був визначений прапор **`EXTR_SKIP`**тоді змінна $wddxsize не була б створена . **`EXTR_OVERWRITE`** була б причиною того, що змінною $size було б надано значення "medium", і **`EXTR_PREFIX_ALL`** була б причиною того, що були б також створені нові змінні $wddxcolor, $wddxsize та $wddxshape.

### Примітки

**Увага**

Не використовуйте функцію **extract()** на неперевірених даних, таких як введення користувача ([$\_GET](reserved.variables.get.html) [$\_FILES](reserved.variables.files.html) і т.п.). Якщо ви зробите це, переконайтеся, що використовуєте один із прапорів `flags`, що не перезаписують змінні, такий як **`EXTR_SKIP`** і майте на увазі, що ви повинні витягувати їх у тому порядку, який визначений у директиві [variables\_order](ini.core.html#ini.variables-order) всередині [php.ini](ini.html)

### Дивіться також

-   [compact()](function.compact.html) - Створює масив, що містить назви змінних та їх значення
-   [list()](function.list.html) - Надає змінним зі списку значення подібно до масиву