---
navigation:
  - function.pcntl-signal-get-handler.md: « pcntl\_signal\_get\_handler
  - function.pcntl-sigprocmask.md: pcntl\_sigprocmask »
  - index.md: PHP Manual
  - ref.pcntl.md: Функції PCNTL
title: pcntl\_signal
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# pcntl\_signal

(PHP 4 >= 4.1.0, PHP 5, PHP 7, PHP 8)

pcntl\_signal — Встановлення обробника сигналу

### Опис

```methodsynopsis
pcntl_signal(int $signal, callable|int $handler, bool $restart_syscalls = true): bool
```

Функция**pcntl\_signal()** встановлює новий оброблювач сигналу або замінює поточний оброблювач сигналу, вказаний у аргументі `signal`

### Список параметрів

`signal`

Номер сигналу.

`handler`

Оброблювач сигналу. Це може бути або [callable](language.types.callable.md), покажчик на функцію, яка буде запущена для обробки сигналу, або значення однієї з глобальних констант: **`SIG_IGN`**или**`SIG_DFL`**, які, відповідно, або призведуть до ігнорування сигналу або відновлення оброблювача за замовчуванням.

Если передан тип[callable](language.types.callable.md), він повинен мати таку сигнатуру:

```methodsynopsis
handler(int $signo, mixed $siginfo): void
```

`signal`

Номер сигналу, що обробляється.

`siginfo`

Якщо операційна система підтримує структури siginfo\_t, можна передати масив з інформацією про сигнал відповідної структури.

> **Зауваження** :
> 
> Зверніть увагу, що коли ви задаєте як обробник метод об'єкта, лічильник посилань на цей об'єкт буде збільшений на одиницю, що збереже його в пам'яті доти, поки ви або не зміните обробник на щось інше, або до тих пір, поки скрипт повністю не завершить своєї роботи.

`restart_syscalls`

Визначає, чи потрібно використовувати перезапуск системного виклику під час надходження сигналу.

### Значення, що повертаються

Повертає **`true`** у разі успішного виконання або \*\*`false`\*\*в случае возникновения ошибки.

### список змін

| Версия | Опис |
| --- | --- |
| 7.1.0 | Починаючи з PHP 7.1.0 обробнику callback-функції передається другий аргумент, що містить структуру siginfo певного сигналу. Ці дані будуть передані лише в тому випадку, якщо операційна система підтримує структури siginfo\_t. Якщо в операційній системі не реалізовано підтримку структури siginfo\_t, то як другий аргумент буде переданий NULL. |

### Приклади

**Пример #1 Пример использования**pcntl\_signal()\*\*\*\*

```php
<?php
// Обязательно
declare(ticks = 1);

// функция обработки сигнала
function sig_handler($signo)
{

     switch ($signo) {
         case SIGTERM:
             // Обработка задач остановки
             exit;
             break;
         case SIGHUP:
             // обработка задач перезапуска
             break;
         case SIGUSR1:
             echo "Получен сигнал SIGUSR1...\n";
             break;
         default:
             // Обработка других сигналов
     }

}

echo "Установка обработчиков сигналов...\n";

// Установка обработчиков сигналов
pcntl_signal(SIGTERM, "sig_handler");
pcntl_signal(SIGHUP,  "sig_handler");
pcntl_signal(SIGUSR1, "sig_handler");

// или можете использовать объект
// pcntl_signal(SIGUSR1, array($obj, "do_something"));

echo "Отправка сигнала SIGUSR1 себе...\n";

// Отправка SIGUSR1 процессу с текущим id (т.е. себе)
// для использования функций posix_* требуется модуль posix
posix_kill(posix_getpid(), SIGUSR1);

echo "Завершено\n";

?>
```

### Примітки

**pcntl\_signal()** не збирає обробники сигналів у стек, а замінює їх.

### Дивіться також

-   [pcntl\_fork()](function.pcntl-fork.md) \- Розгалужити (fork) поточний запущений процес
-   [pcntl\_waitpid()](function.pcntl-waitpid.md) \- Очікує чи повертає статус породженого дочірнього процесу
