Встановлення оброблювача сигналу

-   [« pcntl\_signal\_get\_handler](function.pcntl-signal-get-handler.html)
    
-   [pcntl\_sigprocmask »](function.pcntl-sigprocmask.html)
    
-   [PHP Manual](index.html)
    
-   [Функции PCNTL](ref.pcntl.html)
    
-   Встановлення оброблювача сигналу
    

# pcntlsignal

(PHP 4> = 4.1.0, PHP 5, PHP 7, PHP 8)

pcntlsignal — Встановлення обробника сигналу

### Опис

```methodsynopsis
pcntl_signal(int $signal, callable|int $handler, bool $restart_syscalls = true): bool
```

Функція **pcntlsignal()** встановлює новий оброблювач сигналу або замінює поточний оброблювач сигналу, вказаний у аргументі `signal`

### Список параметрів

`signal`

Номер сигналу.

`handler`

Оброблювач сигналу. Це може бути або [callable](language.types.callable.html), вказівник на функцію, яка буде запущена для обробки сигналу, або значення однієї з глобальних констант: **`SIG_IGN`** або **`SIG_DFL`**, які, відповідно, або призведуть до ігнорування сигналу або відновлення оброблювача за замовчуванням.

Якщо передано тип [callable](language.types.callable.html), він повинен мати таку сигнатуру:

```methodsynopsis
handler(int $signo, mixed $siginfo): void
```

`signal`

Номер сигналу, що обробляється.

`siginfo`

Якщо операційна система підтримує структури siginfot, можна передати масив з інформацією про сигнал відповідної структури.

> **Зауваження**
> 
> Зверніть увагу, що коли ви задаєте як обробник метод об'єкта, лічильник посилань на цей об'єкт буде збільшений на одиницю, що збереже його в пам'яті доти, поки ви або не зміните обробник на щось інше, або поки скрипт повністю не завершить своєї роботи.

`restart_syscalls`

Визначає, чи потрібно використовувати перезапуск системного виклику під час надходження сигналу.

### Значення, що повертаються

Повертає **`true`** у разі успішного виконання або **`false`** у разі виникнення помилки.

### список змін

| Версия | Описание |
| --- | --- |
|  | Починаючи з PHP 7.1.0 обробнику callback-функції передається другий аргумент, що містить структуру siginfo певного сигналу. Ці дані будуть передані тільки в тому випадку, якщо операційна система підтримує структури siginfot. Якщо в операційній системі не реалізовано підтримку структури siginfot, то як другий аргумент буде переданий NULL. |

### Приклади

**Приклад #1 Приклад використання **pcntlsignal()****

```php
<?php
// Обязательно
declare(ticks = 1);

// функция обработки сигнала
function sig_handler($signo)
{

     switch ($signo) {
         case SIGTERM:
             // Обработка задач остановки
             exit;
             break;
         case SIGHUP:
             // обработка задач перезапуска
             break;
         case SIGUSR1:
             echo "Получен сигнал SIGUSR1...\n";
             break;
         default:
             // Обработка других сигналов
     }

}

echo "Установка обработчиков сигналов...\n";

// Установка обработчиков сигналов
pcntl_signal(SIGTERM, "sig_handler");
pcntl_signal(SIGHUP,  "sig_handler");
pcntl_signal(SIGUSR1, "sig_handler");

// или можете использовать объект
// pcntl_signal(SIGUSR1, array($obj, "do_something"));

echo "Отправка сигнала SIGUSR1 себе...\n";

// Отправка SIGUSR1 процессу с текущим id (т.е. себе)
// для использования функций posix_* требуется модуль posix
posix_kill(posix_getpid(), SIGUSR1);

echo "Завершено\n";

?>
```

### Примітки

**pcntlsignal()** не збирає обробники сигналів у стек, а замінює їх.

### Дивіться також

-   [pcntl\_fork()](function.pcntl-fork.html) - Розгалужити (fork) поточний запущений процес
-   [pcntl\_waitpid()](function.pcntl-waitpid.html) - Очікує чи повертає статус породженого дочірнього процесу