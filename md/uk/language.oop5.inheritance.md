успадкування

-   [« Область видимости](language.oop5.visibility.html)
    
-   [Оператор разрешения области видимости (::) »](language.oop5.paamayim-nekudotayim.html)
    
-   [PHP Manual](index.html)
    
-   [Классы и объекты](language.oop5.html)
    
-   успадкування
    

## успадкування

Спадкування - це принцип програмування, що добре зарекомендував себе, і PHP використовує цей принцип у своїй об'єктній моделі. Цей принцип вплине на те, як багато класів та об'єктів пов'язані один з одним.

Наприклад, при розширенні класу дочірній клас успадковує всі загальнодоступні та захищені методи, властивості та константи батьківського класу. Доки ці методи не будуть перевизначені, вони зберігатимуть свою вихідну функціональність.

Це корисно для визначення та абстрагування функціональності та дозволяє реалізувати додаткову функціональність у схожих об'єктах без необхідності реалізовувати всю загальну функціональність.

Закриті методи батьківського класу недоступні дочірньому класу. У результаті дочірні класи можуть повторно реалізувати закритий метод без урахування звичайних правил успадкування. Однак до PHP 8.0.0 до закритих методів застосовувалися обмеження `final` і `static`. Починаючи з PHP 8.0.0, єдине обмеження закритого методу, яке застосовується - це конструктори `private final`оскільки це звичайний спосіб "відключити" конструктор при використанні замість нього статичних фабричних методів.

[Видимость](language.oop5.visibility.html) методів, властивостей та констант можна послабити, наприклад, `защищённый` метод може бути позначений як `общедоступный`, але не можна обмежити видимість, наприклад, не можна помітити `общедоступное` властивість як `закрытое`

> **Зауваження**
> 
> Якщо автозавантаження не використовується, класи повинні бути оголошені до того, як вони будуть використовуватися. Якщо клас розширює інший, то батьківський клас може бути оголошено до наступного класу. Це правило застосовується до класів, які успадковують інші класи чи інтерфейси.

> **Зауваження**
> 
> Не дозволяється перевизначати властивість читання-запису за допомогою [readonly-свойства](language.oop5.properties.html#language.oop5.properties.readonly-properties) чи навпаки.
> 
> ```php
> <?php
> class A {
>     public int $prop;
> }
> class B extends A {
>     // Нельзя: read-write -> readonly
>     public readonly int $prop;
> }
> ?>
> ```

**Приклад #1 Приклад наслідування**

```php
<?php

class Foo
{
    public function printItem($string)
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }

    public function printPHP()
    {
        echo 'PHP просто супер.' . PHP_EOL;
    }
}

class Bar extends Foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new Foo();
$bar = new Bar();
$foo->printItem('baz'); // Выведет: 'Foo: baz'
$foo->printPHP();       // Выведет: 'PHP просто супер'
$bar->printItem('baz'); // Выведет: 'Bar: baz'
$bar->printPHP();       // Выведет: 'PHP просто супер'

?>
```

### Сумісність типів значень, що повертаються, з внутрішніми класами

До PHP 8.1.0 більшість внутрішніх класів або методів не оголошували свої типи значень, що повертаються, і при їх розширенні допускався будь-який тип значення, що повертається.

Починаючи з PHP 8.1.0, більшість внутрішніх методів почали "попередньо" оголошувати тип значення, що повертається. У цьому випадку тип значення методів, що повертається, повинен бути сумісний з розширюваним батьком; в іншому випадку видається повідомлення про старіння. Зверніть увагу, що відсутність явного оголошення типу значення, що повертається, також вважається невідповідністю сигнатури і, відповідно, призводить до повідомлення про старіння.

Якщо тип повертаного значення не може бути оголошений для перевизначуваного методу через проблеми сумісності з різними версіями PHP, може бути доданий атрибут `#[ReturnTypeWillChange]`, щоб заглушити повідомлення про старіння.

**Приклад #2 Перевизначальний метод не оголошує жодного типу значення, що повертається**

```php
<?php
class MyDateTime extends DateTime
{
    public function modify(string $modifier) { return false; }
}

// "Deprecated: Return type of MyDateTime::modify(string $modifier) should either be compatible with DateTime::modify(string $modifier): DateTime|false, or the #[\ReturnTypeWillChange] attribute should be used to temporarily suppress the notice", начиная с PHP 8.1.0
?>
```

**Приклад #3 Перевизначальний метод оголошує неправильний тип значення, що повертається**

```php
<?php
class MyDateTime extends DateTime
{
    public function modify(string $modifier): ?DateTime { return null; }
}

// "Deprecated: Return type of MyDateTime::modify(string $modifier): ?DateTime should either be compatible with DateTime::modify(string $modifier): DateTime|false, or the #[\ReturnTypeWillChange] attribute should be used to temporarily suppress the notice", начиная с PHP 8.1.0
?>
```

**Приклад #4 Перевизначальний метод оголошує неправильний тип значення, що повертається без повідомлення про старіння**

```php
<?php
class MyDateTime extends DateTime
{
    /**
     * @return DateTime|false
     */
    #[ReturnTypeWillChange]
    public function modify(string $modifier) { return false; }
}

// Уведомление об устаревании не выводится
?>
```