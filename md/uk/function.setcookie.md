---
navigation:
  - function.pfsockopen.md: « pfsockopen
  - function.setrawcookie.md: setrawcookie »
  - index.md: PHP Manual
  - ref.network.md: Мережеві функції
title: setcookie
---
# setcookie

(PHP 4, PHP 5, PHP 7, PHP 8)

setcookie — Надсилає cookie

### Опис

```methodsynopsis
setcookie(    string $name,    string $value = "",    int $expires_or_options = 0,    string $path = "",    string $domain = "",    bool $secure = false,    bool $httponly = false): bool
```

Альтернативна сигнатура доступна з PHP 7.3.0 (іменовані параметри не підтримуються):

```methodsynopsis
setcookie(string $name, string $value = "", array $options = []): bool
```

**setcookie()** задає cookie, яке буде передано клієнту разом з іншими заголовками HTTP. Як і будь-який інший заголовок, cookie повинні передаватися *до* того, як будуть виведені будь-які інші дані скрипту (це обмеження протоколу). Це означає, що у скрипті виклики цієї функції повинні розташовуватися до решти виводу, включаючи виведення тегів `<html>` і `<head>`, а також порожні рядки та символи пробілів.

Після передачі клієнту cookie стануть доступними через масив [COOKIE](reserved.variables.cookies.md) при наступному завантаженні сторінки. Значення cookie також є в [REQUEST](reserved.variables.request.md)

### Список параметрів

[» RFC 6265](http://www.faqs.org/rfcs/rfc6265) дає конкретні вказівки, як потрібно інтерпретувати кожен із параметрів **setcookie()**

`name`

Назву cookie.

`value`

Значення cookie. Це значення буде збережено на клієнтському комп'ютері; не записуйте секретні дані в cookie. Значення, присвоєне cookie з ім'ям `name`, припустимо, `'cookiename'`, буде доступно через [COOKIE\['cookiename'\]](reserved.variables.cookies.md)

`expires_or_options`

Час, коли термін дії cookie закінчується. Це позначка часу Unix, тобто кількість секунд від початку епохи. Один із способів встановлення значення - додати кількість секунд до закінчення терміну дії cookie до результату виклику функції [time()](function.time.md). Наприклад, `time()+60*60*24*30` встановить, що термін дії cookie закінчується через 30 днів. Інший варіант – використовувати функцію [mktime()](function.mktime.md). Якщо поставити `0` або пропустити аргумент, термін дії cookie закінчиться із закінченням сесії (при закритті браузера).

> **Зауваження**
> 
> Можна помітити, що `expires_or_options` приймає як значення мітку часу Unix, а зберігає її у форматі `Wdy, DD-Mon-YYYY HH:MM:SS GMT`. PHP робить це перетворення автоматично.

`path`

Дорога до директорії на сервері, з якої будуть доступні cookie. Якщо поставити `'/'`, cookie будуть доступні у всьому домені `domain`. Якщо поставити `'/foo/'`, cookie будуть доступні тільки з директорії `/foo/` та всіх її піддиректорій (наприклад, `/foo/bar/`) домену `domain`. За промовчанням значенням є поточна директорія, в якій встановлюється cookie.

`domain`

(Під)домен, якому доступні cookie. Завдання піддомену (наприклад, `'www.example.com'`) зробить cookie доступними в ньому та у всіх його піддоменах (наприклад, w2.[www.example.com](http://www.example.com)). Для того, щоб зробити cookie доступними для всього домену (включно з піддоменами), потрібно просто вказати ім'я домену (тобто `'example.com'`

Старі браузери, що йдуть застарілому документу [» RFC 2109](http://www.faqs.org/rfcs/rfc2109), можуть вимагати `.` перед доменом, щоб умикалися всі піддомени.

`secure`

Вказує на те, що значення cookie має передаватися від клієнта із захищеного з'єднання HTTPS. Якщо поставлено **`true`**, cookie від клієнта буде передано на сервер тільки якщо встановлено захищене з'єднання. Під час передачі cookie від сервера клієнту програміст веб-сервера повинен стежити за тим, щоб cookie цього типу передавалися захищеним каналом (варто звернути увагу на [SERVER\["HTTPS"\]](reserved.variables.server.md)

`httponly`

Якщо поставлено **`true`**, cookie будуть доступні лише через протокол HTTP. Тобто cookie у цьому випадку не будуть доступні скриптовим мовам, на зразок JavaScript. Ця можливість була запропонована як міра, що ефективно знижує кількість крадіжок особистих даних за допомогою XSS-атак (попри те, що підтримується не всіма браузерами). Варто однак відзначити, що навколо цієї можливості часто виникають суперечки щодо її ефективності та доцільності. Може приймати значення **`true`** або **`false`**

`options`

Асоціативний масив (array), який може мати будь-який із ключів: `expires` `path` `domain` `secure` `httponly` і `samesite`. За наявності будь-якого іншого ключа виникне помилка рівня **`E_WARNING`**. Значення мають той самий зміст, як описано у параметрах з відповідним ім'ям. Значення елемента `samesite` повинно бути або `None`, або `Lax`, або `Strict`. Якщо жодна з допустимих опцій не вказана, її значення за умовчанням збігаються зі значеннями за промовчанням для явних параметрів. Якщо елемент `samesite` не вказано, атрибут cookie SameSite не встановлений.

### Значення, що повертаються

Якщо перед викликом функції клієнту вже передавався будь-який висновок (теги, порожні рядки, пробіли, текст тощо), **setcookie()** зазнає невдачі і поверне **`false`**. Якщо **setcookie()** успішно відпрацює, то поверне **`true`**. Це, однак, не означає, що клієнтська програма (браузер) правильно прийняла та обробила cookie.

### список змін

| Версия | Описание |
| --- | --- |
|  | Додано альтернативний підпис, що підтримує масив опцій `options`. Цей підпис також підтримує налаштування cookie-атрибута SameSite. |

### Приклади

Нижче наведено кілька прикладів, як надсилати cookie:

**Приклад #1 Приклад використання **setcookie()****

```php
<?php
$value = 'что-то откуда-то';

setcookie("TestCookie", $value);
setcookie("TestCookie", $value, time()+3600);  /* срок действия 1 час */
setcookie("TestCookie", $value, time()+3600, "/~rasmus/", "example.com", 1);
?>
```

Варто зазначити, що значення cookie перед надсиланням клієнту піддається URL-коду. При зворотному отриманні значення cookie декодується і поміщається в змінну, з тим самим ім'ям, що ім'я cookie. Якщо ви не бажаєте, щоб значення кодувалися, використовуйте функцію [setrawcookie()](function.setrawcookie.md). Подивитися вміст наших тестових cookie можна, запустивши один із таких прикладів:

```php
<?php
// Вывести одно конкретное значение cookie
echo $_COOKIE["TestCookie"];

// В целях тестирования и отладки может пригодиться вывод всех cookie
print_r($_COOKIE);
?>
```

**Приклад #2 Приклад видалення cookie за допомогою **setcookie()****

Щоб видалити cookie, достатньо як термін дії вказати якийсь час у минулому. Це запустить механізм браузера, що видаляє cookie, що минув. У нижченаведених прикладах показано, як видалити cookie, задані в попередніх прикладах:

```php
<?php
// установка даты истечения срока действия на час назад
setcookie("TestCookie", "", time() - 3600);
setcookie("TestCookie", "", time() - 3600, "/~rasmus/", "example.com", 1);
?>
```

**Приклад #3 **setcookie()** та масиви**

Є можливість розміщувати в cookie масиви. Для цього кожному cookie потрібно дати ім'я відповідно до правил іменування масивів. Така можливість дозволяє помістити стільки значень, скільки є елементів у масиві. При зворотному отриманні всі ці значення будуть поміщені в масив з ім'ям цього cookie:

```php
<?php
// отправка cookie
setcookie("cookie[three]", "cookiethree");
setcookie("cookie[two]", "cookietwo");
setcookie("cookie[one]", "cookieone");

// после перезагрузки страницы, выведем cookie
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $name => $value) {
        $name = htmlspecialchars($name);
        $value = htmlspecialchars($value);
        echo "$name : $value <br />\n";
    }
}
?>
```

Результат виконання цього прикладу:

```
three : cookiethree
two : cookietwo
one : cookieone
```

> **Зауваження**: Використання розділових символів, таких як `[` і `]` як частина імені файлу cookie, не відповідає RFC 6265, розділ 4, але передбачається, що воно підтримується користувачами агентами відповідно до RFC 6265, розділ 5.

### Примітки

> **Зауваження**
> 
> Щоб мати змогу надсилати виведення скрипта до виклику цієї функції, можна скористатися буферизацією. У цьому випадку весь висновок скрипта поміщається в буфер на сервері і залишається там, поки ви не відправите його браузеру. Управління буферизацією здійснюється функціями [проstart()](function.ob-start.md) і [проendflush()](function.ob-end-flush.md) у скрипті, або можна задати директиву `output_buffering` у файлі php.ini чи конфігураційних файлах сервера.

Загальні зауваження:

-   Cookie стануть видимими лише після перезавантаження сторінки, для якої вони мають бути помітні. Для перевірки, чи правильно cookie встановилися, перевірте їх при наступному завантаженні сторінки до закінчення терміну їхньої дії. Термін дії cookie задається у параметрі `expires_or_options`. Зручно перевіряти існування cookie простим викликом `print_r($_COOKIE);`
-   При видаленні cookie повинні бути задані самі параметри, що і при установці. Якщо в якості значення задати порожній рядок, а інші параметри встановити відповідно до попереднього виклику, що встановив cookie, тоді cookie з заданим ім'ям буде видалено з клієнтської машини. Внутрішньо це виглядає так: cookie надається значення `'deleted'`, а термін дії переноситься на рік у минуле.
-   Оскільки встановлення значення **`false`** призведе до видалення cookie, не слід задавати cookie значення булевого типу. Натомість можна використовувати для **`false`** і для **`true`**
-   Cookie можна називати, як масиви, і вони будуть доступні в PHP-скрипті, як масиви, але на машині вони будуть зберігатися у вигляді окремих записів. Для завдання cookie з безліччю імен та значень бажано використовувати функцію [explode()](function.explode.md). Не рекомендується для цього використовувати функцію [serialize()](function.serialize.md)тому що це негативно позначається на безпеці скрипта.

При багаторазових викликах **setcookie()** функції виконуються у порядку, у якому викликалися.

### Дивіться також

-   [header()](function.header.md) - Надсилання HTTP-заголовка
-   [setrawcookie()](function.setrawcookie.md) - Надсилає cookie без URL-кодування значення
-   [раздел cookies](features.cookies.md)
-   [» RFC 6265](http://www.faqs.org/rfcs/rfc6265)
-   [» RFC 2109](http://www.faqs.org/rfcs/rfc2109)
