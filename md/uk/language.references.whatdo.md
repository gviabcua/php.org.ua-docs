- [« Що таке посилання](language.references.whatare.md)
- [Чим посилання не є »](language.references.arent.md)

- [PHP Manual](index.md)
- [Пояснення посилань](language.references.md)
- Що роблять посилання

## Що роблять посилання

Є три основні операції з використанням посилань: [присвоєння по ссылке](language.references.whatdo.md#language.references.whatdo.assign),
[передача по ссылке](language.references.whatdo.md#language.references.whatdo.pass)
і [повернення ссылке](language.references.whatdo.md#language.references.whatdo.return).
Цей розділ познайомить вас з цими операціями та надасть посилання на
подальшого вивчення.

### Присвоєння за посиланням

Перша з них - посилання PHP дозволяють створити дві змінні вказівки
на те саме значення. Таким чином, коли виконується таке:

` <?php$a =& $b;?> `

то `$a` вказує на те саме значення що і `$b`.

> **Примітка**:
>
> `$a` та `$b` тут абсолютно еквівалентні, але це не означає, що `$a`
> вказує на $b або навпаки. Це означає, що $a і $b
> вказують на те саме значення.

> **Примітка**:
>
> Під час присвоєння, передачі або повернення неініціалізованої змінної
> за посиланням, відбувається створення.
>
> **Приклад #1 Використання посилань з неініціалізованими змінними**
>
> ` <?phpfunction foo(&$var) { }foo($a); // $a створена і рівна null$b = array();foo($b['b']);var_dump(array_key_exists('b', $b)); //bool(true)$c = new StdClass;foo($c->d);var_dump(property_exists($c, 'd')); //bool(true)?> `

Такий самий синтаксис може використовуватися у функціях, що повертають
посилання, і з оператором `new`:

` <?php$foo =& find_var($bar);?> `

Використання того ж синтаксису з функцією, яка *не* повертає по
посилання, призведе до помилки, як і її використання з результатом
оператора [new](language.oop5.basic.md#language.oop5.basic.new). Хоча
об'єкти передаються як покажчики, це не те саме, що посилання, як
описано в розділі [Об'єкти та посилання](language.oop5.references.md).

**Увага**

Якщо змінною, оголошеною всередині функції як 'global', буде
присвоєне посилання, воно буде видно лише у функції. Щоб уникнути
цього використовуйте масив `$GLOBALS`.

**Приклад #2 Призначення посилань глобальним змінним усередині функції**

` <?php$var1 = "Приклад змінної";$var2 = "";function global_references($use_globals){    global $var1, $var2; if (!$use_globals) {         $var2 =& $var1; // тільки локально    } else {        $GLOBALS["var2"] =& $var1; // глобально    }}global_references(false);echo "значення var2: '$var2'
"; // значення var2: ''global_references(true);echo "значення var2: '$var2'
"; // значення var2: 'Приклад змінної'?> `

Думайте про `global $var;` як про скорочення від `$var =& $GLOBALS['var'];`.
Таким чином, присвоєння `$var` іншого посилання впливає лише на локальну.
змінну.

> **Примітка**:
>
> При використанні змінної-посилання в > [foreach](control-structures.foreach.md), змінюється зміст, на
> яке вона посилається.
>
> **Приклад #3 Посилання та foreach**
>
> ` <?php$ref = 0;$row =& $ref;foreach (array(1, 2, 3) as $row) {    // зробити що-небудь}echo $ref; // 3 - останнє значення, використовується в циклі?> `

Хоча у виразах, створюваних за допомогою конструкції
[`array()`](function.array.md), немає явного присвоєння за посиланням, тим
не менше вони можуть поводитися як такі, якщо вказати префікс `&` для
елементів масиву. Приклад:

` <?php$a = 1;$b = array(2, 3);$arr = array(&$a, &$b[0], &$b[1]);$arr[0]++ ; $arr[1]++; $arr[2]++;/* $a == 2, $b == array(3, 4); */?> `

Однак, слід зазначити, що посилання в масивах є потенційно
небезпечними. При звичайному (не за посиланням) присвоєння масиву, посилання всередині
цього масиву зберігаються. Це також стосується і викликів функцій,
коли масив передається за значенням. Приклад:

` <?php/* Присвоєння скалярних змінних */$a = 1;$b =& $a;$c = $b;$c = 7; //$c не посилання і не змінює значень $a і $b/* Присвоєння масивів */$arr = array(1);$a =& $arr[0]; // $a і $arr[0] посилаються на одно значення$arr2 = $arr; // привласнення не за посиланням!$arr2[0]++;/* $a == 2, $arr == array(2) *//* Вміст $arr змінився, хоч було присвоєно не */?> `

Іншими словами, поведінка окремих елементів масиву не залежить від типу
присвоєння цього масиву.

### Передача за посиланням

Друге, що роблять посилання – передача параметрів за посиланням. При цьому
локальна змінна у функції та змінна у зухвалій області
видимості посилаються на те саме вміст. Приклад:

` <?phpfunction foo(&$var) {    $var++;}$a = 5;foo($a);?> `

Цей код надасть `$a` значення 6. Це відбувається, тому що у функції
`foo` змінна `$var` посилається на той самий вміст, що і змінна
`$a`. Дивіться також детальне пояснення
ссылке](language.references.pass.md).

### Повернення за посиланням

Третє, що можуть робити посилання - це [повернення ссылке](language.references.return.md).
