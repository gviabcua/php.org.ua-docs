---
navigation:
  - language.references.whatare.md: « Що таке посилання
  - language.references.arent.md: Чим посилання не є »
  - index.md: PHP Manual
  - language.references.md: Пояснення посилань
title: Що роблять посилання
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Що роблять посилання

Є три основні операції з використанням посилань: [присвоєння за посиланням](language.references.whatdo.md#language.references.whatdo.assign) [передача за посиланням](language.references.whatdo.md#language.references.whatdo.pass) і [повернення за посиланням](language.references.whatdo.md#language.references.whatdo.return). Цей розділ познайомить вас із цими операціями та надасть посилання для подальшого вивчення.

### Присвоєння за посиланням

Перша з них - посилання PHP дозволяють створити дві змінні, що вказують на те саме значення. Таким чином, коли виконується таке:

```php
<?php
$a =& $b;
?>
```

то $a вказує на те саме значення як і $b.

> **Зауваження** :
> 
> $a та $b тут абсолютно еквівалентні, але це не означає, що $a вказує на $b або навпаки. Це означає, що $a і $b вказують на те саме значення.

> **Зауваження** :
> 
> При присвоєнні, передачі чи поверненні неініціалізованої змінної за посиланням, відбувається її створення.
> 
> **Приклад #1 Використання посилань з неініціалізованими змінними**
> 
> ```php
> <?php
> function foo(&$var) { }
> 
> foo($a); // $a створена і дорівнює null
> 
> $ b = array ();
> foo($b['b']);
> var_dump(array_key_exists('b', $b)); // bool (true)
> 
> $ c = New stdClass;
> foo($c->d);
> var_dump(property_exists($c, 'd')); // bool (true)
> ?>
> ```

Такий самий синтаксис може використовуватися у функціях, що повертають посилання, та з оператором `new` :

```php
<?php
$foo =& find_var($bar);
?>
```

Використання того ж синтаксису з функцією, яка *не* повертає за посиланням, призведе до помилки, як і її використання з результатом оператора [new](language.oop5.basic.md#language.oop5.basic.new). Хоча об'єкти передаються як покажчики, це не те саме, що посилання, як описано в розділі [Об'єкти та посилання](language.oop5.references.md)

**Увага**

Якщо змінної, оголошеної всередині функції як `global`, буде присвоєно посилання, воно буде видно лише у функції. Щоб уникнути цього, використовуйте масив [$GLOBALS](reserved.variables.globals.md)

**Приклад #2 Надання посилань глобальним змінним всередині функції**

```php
<?php
$var1 = "Пример переменной";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // только локально
    } else {
        $GLOBALS["var2"] =& $var1; // глобально
    }
}

global_references(false);
echo "значение var2: '$var2'\n"; // значение var2: ''
global_references(true);
echo "значение var2: '$var2'\n"; // значение var2: 'Пример переменной'
?>
```

Думайте о`global $var;` як про скорочення від `$var =& $GLOBALS['var'];`Таким образом, присвоение`$var` інший посилання впливає лише локальну змінну.

> **Зауваження** :
> 
> При використанні змінної-посилання в [foreach](control-structures.foreach.md), Змінюється зміст, на яке вона посилається.
> 
> **Приклад #3 Посилання та foreach**
> 
> ```php
> <?php
> $ ref = 0;
> $row =& $ref;
> foreach (array(1, 2, 3) as $row) {
>     // зробити щось
> }
> echo $ ref; // 3 - останнє значення, що використовується в циклі
> ?>
> ```

Хоча у виразах, створюваних за допомогою конструкції [`array()`](function.array.md), немає явного присвоєння за посиланням, проте вони можуть поводитися як такі, якщо вказати префікс `&` для елементів масиву Приклад:

```php
<?php
$a = 1;
$b = array(2, 3);
$arr = array(&$a, &$b[0], &$b[1]);
$arr[0]++; $arr[1]++; $arr[2]++;
/* $a == 2, $b == array(3, 4); */
?>
```

Проте слід зазначити, що посилання в масивах потенційно небезпечні. При звичайному (не за посиланням) присвоєння масиву посилання всередині цього масиву зберігаються. Це також стосується і викликів функцій, коли масив передається за значенням. Приклад:

```php
<?php
/* Присвоение скалярных переменных */
$a = 1;
$b =& $a;
$c = $b;
$c = 7; //$c не ссылка и не изменяет значений $a и $b

/* Присвоение массивов */
$arr = array(1);
$a =& $arr[0]; // $a и $arr[0] ссылаются на одно значение
$arr2 = $arr; // присвоение не по ссылке!
$arr2[0]++;
/* $a == 2, $arr == array(2) */
/* Содержимое $arr изменилось, хотя было присвоено не по ссылке! */
?>
```

Інакше кажучи, поведінка окремих елементів масиву залежить від типу присвоєння цього масиву.

### Передача за посиланням

Друге, що роблять посилання – передача параметрів за посиланням. При цьому локальна змінна в функції і змінна в області видимості, що викликає, посилаються на один і той же вміст. Приклад:

```php
<?php
function foo(&$var) {
    $var++;
}

$a = 5;
foo($a);
?>
```

Цей код надасть $a значення 6. Це відбувається, тому що у функції foo змінна $var посилається на той же вміст, що й змінна $a. Дивіться також детальне пояснення [передачі за посиланням](language.references.pass.md)

### Повернення за посиланням

Третє, що можуть робити посилання – це [повернення за посиланням](language.references.return.md)
