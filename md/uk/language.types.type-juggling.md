Маніпуляції з типами

-   [« Объявление типов](language.types.declarations.html)
    
-   [Переменные »](language.variables.html)
    
-   [PHP Manual](index.html)
    
-   [Типы](language.types.html)
    
-   Маніпуляції з типами
    

## Маніпуляції з типами

PHP не вимагає явного визначення типу при оголошенні змінної. І тут тип змінної визначається значенням, яке вона зберігає. Тобто, якщо змінною $var присвоюється значення типу рядок (string), $var змінить тип на рядок (string). Якщо після цього змінною $var буде присвоєно значення типу ціле число (int), вона змінить тип на ціле число (int).

У певних контекстах PHP може спробувати автоматично перетворити тип значення на інший. Існують такі різні контексти:

-   Числовий контекст
-   Рядковий контекст
-   Логічний контекст
-   Контекст цілих чисел та рядків
-   Порівняльний контекст
-   Контекст функцій

> **Зауваження**: Коли значення потрібно інтерпретувати як інший тип, саме значення *не* змінює тип.

Щоб примусово встановити тип змінної, дивіться розділ [Приведение типа](language.types.type-juggling.html#language.types.typecasting). Щоб змінити тип змінної, дивіться опис функції [settype()](function.settype.html)

### Числовий контекст

Контекст під час використання [арифметического оператора](language.operators.arithmetic.html)

У даному контексті, якщо один з операндів є числом з плаваючою точкою (float) (або не інтерпретується як ціле число (int)), обидва операнди інтерпретуються як число з плаваючою точкою (float) і результатом буде число з плаваючою точкою (float). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результатом також буде ціле число (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, викидається помилка [TypeError](class.typeerror.html)

### Рядковий контекст

Контекст під час використання функцій [echo](function.echo.html) [print](function.print.html) [интерполяции строк](language.types.string.html#language.types.string.parsing) або рядкового [оператора конкатенации](language.operators.string.html)

У цьому контексті значення інтерпретуватиметься як рядок (string).

### Логічний контекст

Контекст під час використання умовних операторів, [тернарного оператора](language.operators.comparison.html#language.operators.comparison.ternary) або [логического оператора](language.operators.logical.html)

У цьому контексті значення інтерпретуватиметься як логічне значення (bool).

### Контекст цілих чисел та рядків

Контекст під час використання [побитовых операторов](language.operators.bitwise.html)

У цьому контексті, якщо у всіх операндів тип рядка (string), результат також буде рядком (string). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результат також буде цілим числом (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, то буде викинута помилка [TypeError](class.typeerror.html)

### Порівняльний контекст

Контекст під час використання [оператора сравнения](language.operators.comparison.html)

Перетворення типів, що відбуваються в цьому контексті, пояснюються в [таблице сравнения различных типов](language.operators.comparison.html#language.operators.comparison.types) розділу Оператори порівняння.

### Контекст функцій

Контекст, коли значення передається типізованому параметру, властивості або повертається з функції, в якій оголошено тип значення, що повертається.

У цьому контексті, коли активний режим суворої типізації (за замовчуванням), тільки скалярні значення можуть бути перетворені на інше скалярне значення. Для оголошень простих типів поведінка така:

-   Оголошення типу bool: значення інтерпретується як логічне значення (bool). Оголошення типу int: значення інтерпретується ціле число (int), якщо перетворення добре визначено. Наприклад, рядок є [числовой строкой](language.types.numeric-strings.html). Оголошення типу float: значення інтерпретується як число з плаваючою точкою (float), якщо перетворення добре визначено. Наприклад, рядок є [числовой строкой](language.types.numeric-strings.html). Оголошення типу string: значення інтерпретується як рядок (string).

Якщо оголошення типу є об'єднаним, дивіться розділ [Приведение для объединённых типов](language.types.declarations.html#language.types.declarations.union.coercive)

**Увага**

[Внутренние функции](functions.internal.html) автоматично підставляють **`null`** до скалярних типів, це поведінка *ЗАСТАРІЛО* у PHP 8.1.0.

### Приведення типів

Приведення типу перетворює значення до вибраного типу, записуючи тип у круглих дужках перед значенням, що перетворюється.

```php
<?php
$foo = 10;   // $foo - это целое число
$bar = (bool) $foo;   // $bar - это логическое значение
?>
```

Допускаються такі типи:

-   `(int)` - приведення типу до цілого числа (int)
-   `(bool)` - приведення типу до логічного значення (bool)
-   `(float)` - приведення типу до плаваючої точки (float)
-   `(string)` - приведення типу до рядка (string)
-   `(array)` - Приведення типу до масиву (array)
-   `(object)` - Приведення типу до об'єкта (object)
-   `(unset)` - Приведення типу до NULL

> **Зауваження**
> 
> `(integer)` є псевдонімом приведення типу `(int)`. . `(boolean)` є псевдонімом приведення типу `(bool)`. . `(binary)` є псевдонімом приведення типу `(string)`. . `(double)` і `(real)` є псевдонімами приведення типу `(float)`. Ці наведення не використовують канонічне ім'я типу і не рекомендуються.

**Увага**

Псевдонім приведення типу `(real)` застарілий, починаючи з PHP 8.0.0.

**Увага**

Приведення типу `(unset)` застаріло починаючи з версії PHP 7.2.0. Зверніть увагу, що приведення `(unset)` рівносильно присвоєння змінної або виклику значення NULL. Приведення `(unset)` видалено у PHP 8.0.0.

**Застереження**

Приведення типу `(binary)` та префікс `b` є для прямої підтримки. В даний час `(binary)` і `(string)` ідентичні, проте це може змінитися і не слід покладатися.

> **Зауваження**
> 
> Прогалини ігноруються у круглих дужках при наведенні типу. Таким чином, наступні два наведення типів еквівалентні:
> 
> ```php
> <?php
> $foo = (int) $bar;
> $foo = ( int ) $bar;
> ?>
> ```

Приведення рядків (string) та змінних до бінарних рядків (string):

```php
<?php
$binary = (binary) $string;
$binary = b"binary string";
?>
```

> **Зауваження**: Замість приведення змінної типу рядок (string) можна також укласти змінну в подвійні лапки.
> 
> ```php
> <?php
> $foo = 10;            // $foo является целым числом
> $str = "$foo";        // $str является строкой
> $fst = (string) $foo; // $fst также является строкой
> 
> // Выводит, что "они одинаковые"
> if ($fst === $str) {
>     echo "они одинаковые";
> }
> ?>
> ```

Можливо, очевидно, що саме відбудеться при перетворенні між певними типами. Для отримання додаткової інформації дивіться ці розділи:

-   [Преобразование типа к логическому значению (boolean)](language.types.boolean.html#language.types.boolean.casting)
-   [Преобразование типа к целому числу (integer)](language.types.integer.html#language.types.integer.casting)
-   [Преобразование типа к числу с плавающей точкой (float)](language.types.float.html#language.types.float.casting)
-   [Преобразование типа к строке (string)](language.types.string.html#language.types.string.casting)
-   [Преобразование типа к массиву (array)](language.types.array.html#language.types.array.casting)
-   [Преобразование типа к объекту (object)](language.types.object.html#language.types.object.casting)
-   [Преобразование типа к ресурсу (resource)](language.types.resource.html#language.types.resource.casting)
-   [Преобразование типа к NULL](language.types.null.html#language.types.null.casting)
-   [Таблицы сравнения типов](types.comparisons.html)

> **Зауваження**: Оскільки PHP підтримує індексацію в рядках (string) за допомогою зміщення, використовуючи той же синтаксис, що і індексація в масивах (array), такий приклад справедливий для всіх версій PHP:
> 
> ```php
> <?php
> $a    = 'car'; // $a является строкой
> $a[0] = 'b';   // $a по-прежнему является строкой
> echo $a;       // bar
> ?>
> ```
> 
> Додаткову інформацію дивіться у розділі [Доступ к символу в строке и его изменение](language.types.string.html#language.types.string.substr)