---
navigation:
  - language.types.declarations.md: « Оголошення типів
  - language.variables.md: Змінні »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Маніпуляції з типами
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Маніпуляції з типами

PHP не вимагає явного визначення типу при оголошенні змінної. Якщо тип змінної не вказано, він буде визначений значенням, яке вона зберігає. Тобто, якщо змінною $var присвоюється значення типу рядок (string), $var змінить тип на рядок (string). Якщо після цього змінної $var буде присвоєно значення типу ціле число (int), вона змінить тип на ціле число (int).

У ряді контекстів PHP може спробувати автоматично перетворити тип значення на інший. Існуючі контексти:

-   Числовий
-   Рядковий
-   Логічний
-   Контекст цілих чисел та рядків
-   Порівняльний
-   Контекст функцій

> **Зауваження**: Коли значення потрібно інтерпретувати як інший тип, саме значення *не*меняет тип.

Про те, як примусово встановити тип змінної, розказано у розділі «[Приведення типу](language.types.type-juggling.md#language.types.typecasting)». Про те, як змінити тип змінної, описано в описі функції [settype()](function.settype.md)

### Числовий контекст

Числовий контекст виникає під час роботи з [арифметичними операторами](language.operators.arithmetic.md)

У цьому контексті, якщо один з операндів - число з плаваючою точкою (float) (або не інтерпретується як ціле число (int)), обидва операнда інтерпретуються як число з плаваючою точкою (float) і результатом буде число з плаваючою точкою (float). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результатом також буде ціле число (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, викидається виняток [TypeError](class.typeerror.md)

### Рядковий контекст

Рядковий контекст виникає під час роботи з мовними конструкціями [echo](function.echo.md) [print](function.print.md), при[інтерполяції рядків](language.types.string.md#language.types.string.parsing)или строковом[оператора конкатенації](language.operators.string.md)

У цьому контексті значення інтерпретуватиметься як рядок (string). Якщо значення не може бути інтерпретовано, викидається виняток [TypeError](class.typeerror.md). До версії PHP 7.4.0 видавалася помилка рівня **`E_RECOVERABLE_ERROR`**

### Логічний контекст

Логічний контекст виникає під час роботи з умовними операторами, [тернарним оператором](language.operators.comparison.md#language.operators.comparison.ternary) або [логічним оператором](language.operators.logical.md)

У цьому контексті значення інтерпретуватиметься як логічне значення (bool).

### Контекст цілих чисел та рядків

Контекст цілих чисел і рядків виникає під час роботи з [побітовими операторами](language.operators.bitwise.md)

У цьому контексті, якщо у всіх операндів є тип рядка (string), результат також буде рядком (string). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результат також буде цілим числом (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, то буде викинуто виняток [TypeError](class.typeerror.md)

### Порівняльний контекст

Порівняльний контекст виникає при роботі з [операторами порівняння](language.operators.comparison.md)

Перетворення типів, що відбуваються в цьому контексті, пояснено у [таблиці порівняння типів](language.operators.comparison.md#language.operators.comparison.types) розділу "Оператори порівняння".

### Контекст функцій

Контекст функцій виникає, коли значення передається типізованим параметром, властивістю або повертається з функції, в якій оголошено тип значення, що повертається.

У цьому контексті значення має бути значенням типу. Є два винятки, перше: якщо тип значення - ціле число (int), а оголошений тип - число з плаваючою точкою (float), то ціле число перетворюється на число з плаваючою точкою. Другий: якщо оголошений тип – це *скалярний* тип, значення перетворюється на скалярний тип і режим суворої типізації активний (за замовчуванням), значення може бути перетворено на допустиме скалярне значення. Опис такої поведінки наведено нижче.

**Увага**

[Вбудовані функції](functions.internal.md) автоматично підставляють **`null`** до скалярних типів, це поведінка *ЗАСТАРІЛО*с PHP 8.1.0.

#### Примусова типізація із простим оголошенням типів

-   Оголошення типу bool: значення інтерпретується як логічне значення (bool).
-   Оголошення типу int: значення інтерпретується як ціле число (int), якщо перетворення надійно визначене. Наприклад, коли рядок[числовий рядок](language.types.numeric-strings.md)
-   Оголошення типу float: значення інтерпретується як число з плаваючою точкою (float), якщо перетворення надійно визначене. Наприклад, коли рядок[числовий рядок](language.types.numeric-strings.md)
-   Оголошення типу string: значення інтерпретується як рядок (string).

#### Примусова типізація з поєднанням типів

Когда директива`strict_types` не ввімкнено, оголошення скалярних типів підлягають обмеженому неявному наведенню типів. Якщо точний тип значення – не частина об'єднання, то цільовий тип вибраний зі списку в порядку зменшення пріоритету:

1.  int
2.  float
3.  string
4.  bool

Якщо тип і існує в об'єднанні та значення може бути приведено до цього типу відповідно до існуючої семантики перевірки типів PHP, то PHP вибирає цей тип. В іншому випадку буде вибрано наступний тип.

**Застереження**

Як виняток, якщо значення — рядок, а ціле число (int) і число з точкою (float) — це частина об'єднання, переважний тип буде визначений існуючою семантикою [числового рядка](language.types.numeric-strings.md)Например, для`«42»` PHP вибирає ціле число (int), а для `«42.0»` - Число з плаваючою точкою (float).

> **Зауваження** :
> 
> Типи, які не входять до списку переваг, не стануть метою для неявного приведення. Говорячи конкретніше, ніякого неявного приведення до типів null, false і true не буде.

**Приклад #1 Приклад примусового включення типів до об'єднання**

```php
<?php

// int|string
42    --> 42          // точный тип
"42"  --> "42"        // точный тип
new ObjectWithToString --> "Результат __toString()"
                      // объект не совместим с int, переход к string
42.0  --> 42          // float совместимый с int
42.1  --> 42          // float совместимый с int
1e100 --> "1.0E+100"  // float слишком велик для типа int, переход к string
INF   --> "INF"       // float слишком велик для типа int, переход к string
true  --> 1           // bool совместимый с int
[]    --> TypeError   // массив не совместим с int или string

// int|float|bool
"45"    --> 45        // int числовая строка
"45.0"  --> 45.0      // float числовая строка

"45X"   --> true      // не числовая строка, переход к bool
""      --> false     // не числовая строка, переход к bool
"X"     --> true      // не числовая строка, переход к bool
[]      --> TypeError // массив не совместимый с int, float или bool
?>
```

### Приведення типів

Приведення типу перетворює значення до вибраного типу, записуючи тип у круглих дужках перед значенням, що перетворюється.

```php
<?php

$foo = 10;   // $foo — это целое число
$bar = (bool) $foo;   // $bar — это логическое значение
?>
```

Дозволено такі типи:

-   `(int)`\- Приведення типу до цілого числа (int)
-   `(bool)`\- Приведення типу до логічного значення (bool)
-   `(float)`— приведення типу до плаваючої точки (float)
-   `(string)`\- Приведення типу до рядка (string)
-   `(array)`\- Приведення типу до масиву (array)
-   `(object)`\- Приведення типу до об'єкта (object)
-   `(unset)`\- Приведення типу до NULL

> **Зауваження** :
> 
> `(integer)`— псевдоним приведения типа`(int)`. . `(boolean)`— псевдоним приведения типа`(bool)`. . `(binary)`— псевдоним приведения типа`(string)`. . `(double)`и`(real)` - псевдоніми приведення типу `(float)`. Ці наведення не використовують канонічне ім'я типу і не рекомендуються.

**Увага**

Псевдоним приведения типа`(real)`устарел с PHP 8.0.0.

**Увага**

Приведение типа`(unset)`устарело с версии PHP 7.2.0. Обратите внимание, что приведение`(unset)` рівносильно присвоєння змінної або виклику значення NULL. Приведення `(unset)`удалено в PHP 8.0.0.

**Застереження**

Приведение типа`(binary)`и префикс`b` є для прямої підтримки. Типи `(binary)`и`(string)` ідентичні, однак, це може змінитись, не потрібно на це покладатися.

> **Зауваження** :
> 
> PHP ігнорує прогалини у круглих дужках при наведенні типу. Тому такі два приведення типів еквівалентні:
> 
> ```php
> <?php
> 
> $foo = (int) $bar;
> $foo = ( int ) $bar;
> ?>
> ```

Приведення рядків (string) та змінних до бінарних рядків (string):

```php
<?php

$binary = (binary) $string;
$binary = b"binary string";
?>
```

> **Зауваження**: Замість приведення змінної до типу рядок (string) можна також укласти змінну подвійні лапки.
> 
> ```php
> <?php
> 
> $ foo = 10; // $foo - ціле число
> $str = "$foo"; // $str - рядок
> $fst = (string) $foo; // $fst теж рядок
> 
> // Виводить, що «вони однакові»
> if ($fst === $str) {
>     echo "вони однакові";
> }
> ?>
> ```

Можливо, очевидно, що станеться при перетворенні між різними типами. Отримати додаткову інформацію можна у розділах:

-   [Перетворення типу до логічного значення (boolean)](language.types.boolean.md#language.types.boolean.casting)
-   [Перетворення типу до цілого числа (integer)](language.types.integer.md#language.types.integer.casting)
-   [Перетворення типу до плаваючої точки (float)](language.types.float.md#language.types.float.casting)
-   [Перетворення типу до рядка (string)](language.types.string.md#language.types.string.casting)
-   [Перетворення типу до масиву (array)](language.types.array.md#language.types.array.casting)
-   [Перетворення типу на об'єкт (object)](language.types.object.md#language.types.object.casting)
-   [Перетворення типу ресурсу (resource)](language.types.resource.md#language.types.resource.casting)
-   [Перетворення типу на NULL](language.types.null.md#language.types.null.casting)
-   [Таблиці порівняння типів](types.comparisons.md)

> **Зауваження**: Оскільки PHP підтримує індексацію в рядках (string) через усунення, використовуючи той же синтаксис, що і індексація в масивах (array), наступний приклад справедливий для всіх версій PHP:
> 
> ```php
> <?php
> 
> $a = 'car'; // $a - рядок
> $a[0] = 'b'; // $a, як і раніше, рядок
> echo $a; // bar
> ?>
> ```
> 
> Додаткову інформацію можна знайти в розділі «[Доступ до символу в рядку та його зміна](language.types.string.md#language.types.string.substr)».
