---
navigation:
  - function.uniqid.md: « uniqid
  - function.usleep.md: usleep »
  - index.md: PHP Manual
  - ref.misc.md: Різні функції
title: unpack
---
# unpack

(PHP 4, PHP 5, PHP 7, PHP 8)

unpack — Розпакувати дані з бінарного рядка

### Опис

```methodsynopsis
unpack(string $format, string $string, int $offset = 0): array|false
```

Розпаковує дані з бінарного рядка в масив відповідно до заданого в `format` форматі.

Розпаковані дані зберігаються в асоціативному масиві. Для цього необхідно позначити різні коди форматів і розділити їх за допомогою слеша /. Можна також передати заміщаючий аргумент, за допомогою якого кожен ключ масиву матиме порядковий номер після заданого імені.

Для підтримки сумісності з Perl зроблено таке:

-   Код "a" тепер зберігає завершальні NULL-байти.
-   Код "A" тепер видаляє всі завершальні пробіли ASCII (пробіли, табуляцію, переноси рядків, повернення каретки, і NULL-байти).
-   Код "Z" доданий для NULL-доповнених рядків і видаляє завершальні NULL-байти.

### Список параметрів

`format`

Дивіться функцію [pack()](function.pack.md) для роз'яснення форматів кодів.

`string`

Запаковані дані.

`offset`

Зміщення, з якого необхідно розпочати розпакування.

### Значення, що повертаються

Повертає асоціативний масив, що містить розпаковані елементи бінарного рядка або **`false`** у разі виникнення помилки.

### список змін

| Версия | Описание |
| --- | --- |
|  | Типи float і double підтримують як зворотний, і прямий порядок передачі байтів. |
|  | Додано необов'язковий параметр `offset` |

### Приклади

**Приклад #1 Приклад використання **unpack()****

```php
<?php
$binarydata = "\x04\x00\xa0\x00";
$array = unpack("cchars/nint", $binarydata);
print_r($array);
?>
```

Результат виконання цього прикладу:

```
Array
(
    [chars] => 4
    [int] => 160
)
```

**Приклад #2 Приклад використання **unpack()** із заміщувальним аргументом**

```php
<?php
$binarydata = "\x04\x00\xa0\x00";
$array = unpack("c2chars/nint", $binarydata);
print_r($array);
?>
```

Результат виконання цього прикладу:

```
Array
(
    [chars1] => 4
    [chars2] => 0
    [int] => 40960
)
```

### Примітки

**Застереження**

PHP зберігає цілі значення зі знаком (signed). Якщо розпакувати значення типу large unsigned long і воно матиме той самий розмір, що і PHP, то результатом буде негативне число, навіть якщо було вказано розпаковувати без знака (unsigned).

**Застереження**

Якщо не назвати елемент, то будуть використані числові індекси, починаючи з `1`. Якщо не позначити більше одного елемента, це означає, що деякі дані будуть перезаписані, так як нумерація перезапускається з `1` для кожного елемента.

**Приклад #3 Приклад використання **unpack()** з безіменними ключами**

```php
<?php
$binarydata = "\x32\x42\x00\xa0";
$array = unpack("c2/n", $binarydata);
var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(2) {
  [1]=>
  int(160)
  [2]=>
  int(66)
}
```

Зверніть увагу, що перше значення специфікатора `c` перезаписується першим значенням із специфікатора `n`

### Дивіться також

-   [pack()](function.pack.md) - Упакувати дані у бінарний рядок
