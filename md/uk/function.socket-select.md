Запускає системний виклик select() для заданих масивів сокетів із зазначеним часом очікування

-   [« socketrecvmsg](function.socket-recvmsg.html)
    
-   [socketsend »](function.socket-send.html)
    
-   [PHP Manual](index.md)
    
-   [Функции сокета](ref.sockets.md)
    
-   Запускає системний виклик select() для заданих масивів сокетів із зазначеним часом очікування
    

# socketselect

(PHP 4> = 4.1.0, PHP 5, PHP 7, PHP 8)

socketselect — Запускає системний виклик select() для заданих масивів сокетів із зазначеним часом очікування

### Опис

```methodsynopsis
socket_select(    ?array &$read,    ?array &$write,    ?array &$except,    ?int $seconds,    int $microseconds = 0): int|false
```

**socketselect()** приймає масиви сокетів та чекає їх зміни статусу. Ті, хто знайомий із сокетами BSD, виявлять, що масиви сокетів насправді є так званими наборами дескрипторів файлів. Спостерігаються три незалежні масиви ресурсів сокетів.

### Список параметрів

`read`

Сокети, перелічені у масиві `read` будуть спостерігатися для перегляду, чи є доступні символи для читання (точніше, щоб бачити, чи не буде читання блокуватися, зокрема, сокет вже досяг кінця файлу, і в цьому випадку [socketread()](function.socket-read.html) поверне рядок із нульовою довжиною).

`write`

Сокети, перелічені у масиві `write` спостерігатимуться для перегляду, чи запис блокуватиметься.

`except`

Сокети, перелічені у масиві `except` спостерігатимуться для винятків.

`seconds`

`seconds` і `microseconds` разом утворюють параметр `timeout`. Параметр `timeout` - максимальний проміжок часу до повернення **socketselect()**. . `seconds` може бути нулем, змушуючи **socketselect()** до негайного повернення. Це корисно для опитування. Якщо `seconds` дорівнює **`null`** (немає часу очікування), **socketselect()** може блокуватися нескінченно.

`microseconds`

**Увага**

При завершенні масиви змінюються, щоб визначити, який сокет насправді змінив статус.

Не потрібно передавати кожен масив у **socketselect()**. Ви можете пропустити його і використовувати порожній масив або **`null`** замість цього. Також не забувайте, що ці масиви передаються *за посиланням* і будуть змінені після завершення **socketselect()**

> **Зауваження**
> 
> Через обмеження поточного двигуна Zend неможливо передати модифікатор константи, такий як **`null`**, безпосередньо як параметр у функцію, яка очікує, що цей параметр буде передано за посиланням. Натомість використовуйте тимчасову змінну або вираз, де ліва сторона є тимчасовою змінною:
> 
> **Приклад #1 Використання **`null`** в **socketselect()****
> 
> ```php
> <?php
> $e = NULL;
> socket_select($r, $w, $e, 0);
> ?>
> ```

### Значення, що повертаються

У разі успішного виконання **socketselect()** повертає кількість сокетів, що містяться в змінених масивах, яка може дорівнювати нулю, якщо час очікування закінчиться до того, як станеться щось цікаве. У разі виникнення помилки повертається **`false`**. Код помилки може бути отриманий за допомогою [socketlasterror()](function.socket-last-error.html)

> **Зауваження**
> 
> Обов'язково використовуйте оператор `===` під час перевірки на помилку. Оскільки **socketselect()** може повертати 0, порівняння з `==` буде оцінюватися як **`true`**
> 
> **Приклад #2 Аналіз результату **socketselect()****
> 
> ```php
> <?php
> $e = NULL;
> if (false === socket_select($r, $w, $e, 0)) {
>     echo "Неудачный вызов socket_select(), причина: " .
>         socket_strerror(socket_last_error()) . "\n";
> }
> ?>
> ```

### Приклади

**Приклад #3 Приклад використання **socketselect()****

```php
<?php
/* Подготовить Масив сокетов для чтения */
$read   = array($socket1, $socket2);
$write  = NULL;
$except = NULL;
$num_changed_sockets = socket_select($read, $write, $except, 0);

if ($num_changed_sockets === false) {
    /* Обработка ошибок */
} else if ($num_changed_sockets > 0) {
    /* По крайней мере, в одном из сокетов произошло что-то интересное */
}
?>
```

### Примітки

> **Зауваження**
> 
> Майте на увазі, деякі реалізації сокетів необхідно обробляти дуже обережно. Декілька основних правил:
> 
> -   Ви завжди повинні спробувати використати **socketselect()** без часу очікування. Ваша програма нічого не повинна робити, якщо немає доступних даних. Код, що залежить від часу очікування, зазвичай не дуже переносимий і важкий для налагодження.
> -   Сокет не повинен додаватися до будь-якого масиву, якщо ви не збираєтеся перевіряти результат після виклику **socketselect()**. Після повернення **socketselect()** всі сокети у всіх масивах мають бути перевірені. Будь-який сокет, доступний для запису чи читання, повинен використовуватися для запису чи читання.
> -   Якщо ви читаєте або записуєте з сокету, що повертається в масивах, майте на увазі, що він необов'язково зможе прочитати або записати дані, що повністю запитуються. Будьте готові прочитати або записати лише один байт.
> -   Зазвичай для більшості реалізацій сокетів єдиний виняток, спійманий за допомогою масиву `except` - Це дані без прив'язки, отримані в сокеті.

### Дивіться також

-   [socketread()](function.socket-read.html) - Читає рядок максимальну довжину байт із сокету
-   [socketwrite()](function.socket-write.html) - Запис у сокет
-   [socketlasterror()](function.socket-last-error.html) - Повертає останню помилку на сокеті
-   [socketstrerror()](function.socket-strerror.html) - Повертає рядок, що описує помилку сокету