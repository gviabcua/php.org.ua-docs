Основи підрахунку посилань

-   [« Сборка мусора](features.gc.md)
    
-   [Збір циклічних посилань »](features.gc.collecting-cycles.html)
    
-   [PHP Manual](index.md)
    
-   [Сборка мусора](features.gc.md)
    
-   Основи підрахунку посилань
    

## Основи підрахунку посилань

Змінна PHP зберігається в контейнері, що називається "zval". Контейнер zval, крім типу та значення змінної, також містить два додаткові елементи. Перший називається "isref" і представляє булеве значення, що вказує, є змінна частиною "набору посилань" чи ні. Завдяки цьому елементу PHP знає як відрізняти звичайні змінні від посилань. Так як PHP містить посилання, які можна створити оператором &, контейнер zval також містить внутрішній механізм підрахунку посилань для оптимізації використання пам'яті Ця друга частина додаткової інформації, звана "refcount" (лічильник посилань), містить кількість імен змінних (також званих символами), які вказують на цей контейнер zval. область видимості змінних Така область видимості існує для головного скрипта, а також для кожної функції та методу.

Контейнер zval створюється під час створення нової змінної, якій присвоюється константа, наприклад:

**Приклад #1 Створення нового контейнера zval**

```php
<?php
$a = "new string";
?>
```

У цьому прикладі створюється новий символ `a` у поточній області видимості та новий контейнер змінної з типом string та значенням `new string`. Біт "isref" за замовчуванням задається рівним **`false`**, т.к. не створено жодного користувача посилання. Значення "refcount" задається рівним `1`, т.к. лише одне ім'я змінної вказує цей контейнер. Зверніть увагу, що посилання (тобто "isref" одно **`true`**) з "refcount" рівним `1` обробляються так, якби вони не були посиланнями (тобто як "isref" було б **`false`**). Якщо у вас встановлено [» Xdebug](http://xdebug.org/), то ви можете вивести цю інформацію, викликавши функцію **xdebugdebugкликав()**

**Приклад #2 Виведення інформації про zval**

```php
<?php
$a = "new string";
xdebug_debug_zval('a');
?>
```

Результат виконання цього прикладу:

```
a: (refcount=1, is_ref=0)='new string'
```

Присвоєння цієї змінної інший збільшує лічильник посилань.

**Приклад #3 Збільшення лічильника посилань zval**

```php
<?php
$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );
?>
```

Результат виконання цього прикладу:

```
a: (refcount=2, is_ref=0)='new string'
```

Лічильник посилань тут дорівнює `2`, т.к. a і b посилаються на той самий контейнер змінної. PHP досить розумний, щоб не копіювати контейнер, поки в цьому немає потреби. Як тільки "refcount" дорівнюватиме нулю, контейнер знищується. "refcount" зменшується на одиницю при відході змінної з області видимості (наприклад, наприкінці функції) або при видаленні цієї змінної (наприклад при виклику) [unset()](function.unset.md)

**Приклад #4 Зменшення лічильника посилань zval**

```php
<?php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' );
$b = 42;
xdebug_debug_zval( 'a' );
unset( $c );
xdebug_debug_zval( 'a' );
?>
```

Результат виконання цього прикладу:

```
a: (refcount=3, is_ref=0)='new string'
a: (refcount=2, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
```

Якщо ми зараз викличемо `unset($a);`, то контейнер, включаючи тип і значення, буде видалено з пам'яті.

### Складові типи даних

Усі дещо ускладнюється зі складовими типами даних, такими як масиви (array) та об'єкти (object). На відміну від скалярних (scalar) значень, масиви та об'єкти зберігають свої властивості у власних таблицях імен. Це означає, що наступний приклад створить відразу три zval контейнери:

**Приклад #5 Створення array zval**

```php
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
xdebug_debug_zval( 'a' );
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
```

Графічно:

![Контейнери для простого масиву](images/12f37b1c6963c1c5c18f30495416a197-simple-array.png)

Результат - три контейнери: a, meaning і number. Схожі правила застосовуються і для збільшення та зменшення "refcounts". Нижче ми додаємо ще один елемент масиву та встановлюємо йому значення вже існуючого елемента:

**Приклад #6 Додавання вже існуючого елемента масиву**

```php
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
```

Графічно:

![Контейнери для простого масиву з посиланнями](images/12f37b1c6963c1c5c18f30495416a197-simple-array2.png)

Наведений вище висновок Xdebug показує, що і старий і новий елементи масиву зараз вказують на контейнер, чий "refcount" дорівнює `2`. Хоча показано два контейнери зі значенням `'life'`, насправді це один контейнер. Функція **xdebugdebugкликав()** не виводить інформацію про це, але ви можете перевірити це також відобразивши покажчики пам'яті.

Видалення елемента з масиву відбувається так само, як і видалення імені змінної з області видимості: зменшується "refcount" контейнера, на який посилається елемент масиву. Знову ж таки, при досягненні "refcount" нуля, контейнер видаляється з пам'яті. Приклад:

**Приклад #7 Видалення елемента з масиву**

```php
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
unset( $a['meaning'], $a['number'] );
xdebug_debug_zval( 'a' );
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
```

Ситуація стане цікавішою, якщо додати масив новим елементом у самого себе. У наступному прикладі ми також використовуємо оператор присвоєння посилання, щоб PHP не створив копію масиву.

**Приклад #8 Додавання масиву новим елементом до самого себе**

```php
<?php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
?>
```

Результатом виконання цього прикладу буде щось подібне:

```
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
```

Графічно:

![Контейнери масиву з циклічними посиланнями](images/12f37b1c6963c1c5c18f30495416a197-loop-array.png)

Можна побачити, що змінна з масивом (a), так само як і другий елемент (1), зараз вказують на контейнер з "refcount" рівним `2`. Символи "..." у виводі означають рекурсію і, у разі, вказують на оригінальний масив.

Як і раніше, видалення змінної зменшує лічильник посилань контейнера на одиницю. Якщо ми застосуємо unset до змінної $a після наведеного вище прикладу, то лічильник посилань контейнера, на який вказують $a і елемент "1", зміниться з "2" на "1":

**Приклад #9 Видалення $a**

```
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
```

Графічно:

![Контейнери після видалення масиву з циклічними посиланнями демонструють витік пам'яті](images/12f37b1c6963c1c5c18f30495416a197-leak-array.png)

### Суть проблеми

Хоча у всіх галузях видимості більше немає імені змінної, що посилається на цю структуру, вона може бути очищена, т.к. елемент масиву "1", як і раніше, посилається на цей масив. Т.к. тепер немає ніякої можливості користувачеві видалити ці дані, ми отримали витік пам'яті. На щастя, PHP видалить ці дані після завершення запиту, але до цього моменту дані займатимуть цінне місце в пам'яті. Така ситуація часто буває, коли реалізуються алгоритми парсингу чи інші, де є дочірні елементи, які посилаються батьківські. Ще частіше така ситуація трапляється з об'єктами, тому що вони завжди неявно використовуються на засланні.

Це не проблема, якщо таке трапляється раз чи два, але якщо існують тисячі чи навіть мільйони таких витоків пам'яті, то вони вже стають проблемою. Особливо у довгопрацюючих скриптах, таких як демони, де запит не закінчується ніколи, або у великих наборах модульних тестів. Останній випадок викликав проблеми під час запуску модульних тестів для компонента Template із бібліотеки ez Components. У деяких випадках може знадобитися понад 2 Гб пам'яті, яка не завжди є на тестовому сервері.