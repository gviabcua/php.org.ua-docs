---
navigation:
  - mysqlnd.plugin.obtaining.md: « Отримання API плагінів mysqlnd
  - mysqlnd.plugin.api.md: API плагінів mysqlnd »
  - index.md: PHP Manual
  - mysqlnd.plugin.md: API для плагінів до вбудованого драйвера MySQL
title: Архитектура плагинов MySQL Native Driver
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Архитектура плагинов MySQL Native Driver

У цій секції розглянуто архітектуру плагінів.`mysqlnd`

**Поверхневий огляд MySQL Native Driver**

Перед початком розробки плагінів`mysqlnd`, корисно ознайомитись, як сам по собі організований`mysqlnd`. . `Mysqlnd`складається з наступних модулів:

**Організаційна схема mysqlnd, помодульно**

| Модули статистики | mysqlnd\_statistics.c |
| --- | --- |
| З'єднання | mysqlnd.c |
| Результуючий набір | mysqlnd\_result.c |
| Метадані результуючого набору | mysqlnd\_result\_meta.c |
| Оператор | mysqlnd\_ps.c |
| Мережа | mysqlnd\_net.c |
| Протокол обміну | mysqlnd\_wireprotocol.c |

**Об'єктно-орієнтована парадигма C**

На рівні коду,`mysqlnd`використовує патерн для реалізації об'єктно-орієнтованого підходу.

У C об'єкти описують використовуючи`struct`. Члени структури є властивостями об'єкта. Члени структури, що вказують на функції, є способами.

На відміну від мов як C++ чи Java, в C немає фіксованих правил успадкування. Однак існують деякі домовленості, які слід слідувати, але це ми обговоримо пізніше.

**Життєвий цикл PHP**

При розгляді життєвого циклу PHP існує два основні цикли:

-   Цикл старту та зупинки двигуна PHP
    
-   Цикл обробки запиту
    

При старті двигуна PHP, перш за все викликається функція ініціалізації модулів (MINIT) для кожного зареєстрованого модуля. Це дозволяє кожному модулю встановити змінні та виділити ресурси, які будуть задіяні весь час життя процесу движка PHP. Коли PHP вимикається, він викликає функцію зупинки модулів (MSHUTDOWN) для кожного модуля.

Протягом життєвого циклу двигуна PHP, він приймає кілька запитів. Кожен запит породжує новий цикл життя. На кожен запит, PHP двигун викликає функцію ініціалізації для кожного модуля. Модуль може зробити виставлення змінних та виділення ресурсів, необхідних обслуговування запиту. Після закінчення життя запиту, двигун викликає функцію зупинки запиту (RSHUTDOWN) для кожного модуля, що дозволяє зробити необхідні чистки.

**Як працює плагін**

Плагин`mysqlnd`працює перехоплюючи виклики модулів, які використовують`mysqlnd`, до`mysqlnd`. Це досягається заміною таблиці функцій`mysqlnd`на створену плагіном.

Наступний код показує заміну таблиці функцій`mysqlnd` :

```
/* хранилище оригинальной таблицы */
struct st_mysqlnd_conn_methods org_methods;

void minit_register_hooks(TSRMLS_D) {
  /* активная таблица функций */
  struct st_mysqlnd_conn_methods * current_methods
    = mysqlnd_conn_get_methods();

  /* бэкап оригинальной таблицы */
  memcpy(&org_methods, current_methods,
    sizeof(struct st_mysqlnd_conn_methods);

  /* установка новых методов */
  current_methods->query = MYSQLND_METHOD(my_conn_class, query);
}
```

Маніпуляцією з таблицею функцій з'єднання необхідно проводити етапі ініціалізації модуля (MINIT). Таблиця функцій - це глобальний ресурс, що розділяється. У багатопотоковому оточенні, зі складанням TSRM, маніпуляція глобальним ресурсом, що розділяється, на етапі обробки запиту призведе до конфліктів.

> **Зауваження** :
> 
> Не використовуйте будь-яку логіку, пов'язану з фіксованим розміром при маніпуляції з таблицею функцій`mysqlnd`. Завжди додавайте нові методи до кінця таблиці, оскільки сама таблиця може у майбутньому будь-якої миті змінитися.

**Виклик батьківських методів**

Якщо записи оригінальної таблиці функцій були збережені, завжди залишається можливість викликати оригінальний метод - батьківський.

У деяких випадках, наприклад, для`Connection::stmt_init()`, життєво важливо спочатку викликати батьківський метод, і лише потім робити щось у новому методі.

```
MYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,
  const char *query, unsigned int query_len TSRMLS_DC) {

  php_printf("my_conn_class::query(query = %s)\n", query);

  query = "SELECT 'query rewritten' FROM DUAL";
  query_len = strlen(query);

  return org_methods.query(conn, query, query_len); /* возврат с вызовом родителя */
}
```

**Розширення властивостей**

Об'єкти `mysqlnd`представлені як C struct. Неможливо додати члена до C struct під час виконання. Користувачі об'єктів`mysqlnd`не можуть просто додати властивості об'єкту.

Довільні дані (властивості) можуть бути додані до об'єкту`mysqlnd`з використанням відповідної функції із сімейства`mysqlnd_plugin_get_plugin_<object>_data()`. При розміщенні об'єкту`mysqlnd`резервується місце наприкінці об'єкта для утримання`void *` указателя на произвольные данные . `mysqlnd`резервує місце для одного`void *`вказівник на плагін.

У наступній таблиці показано, як визначити положення покажчика для конкретного плагіна:

**Розрахунок покажчика для mysqlnd**

| Адрес памяти | Содержимое |
| --- | --- |
|  | Початок об'єкту mysqlnd (C struct) |
| n | Кінець об'єкта mysqlnd (C struct) |
| n + (m x sizeof(void\*)) | void\* для даних об'єкта плагіна номер m |

Якщо ви плануєте робити підклас від одного з конструкторів об'єкту`mysqlnd`, які дозволені, майте це на увазі!

Наступний код демонструє розширення властивостей:

```
/* Любые данные, которые мы хотим добавить */
typedef struct my_conn_properties {
  unsigned long query_counter;
} MY_CONN_PROPERTIES;

/* идентификатор плагина */
unsigned int my_plugin_id;

void minit_register_hooks(TSRMLS_D) {
  /* получаем уникальный идентификатор плагина */
  my_plugin_id = mysqlnd_plugin_register();
  /* snip - see Extending Connection: methods */
}

static MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {
  MY_CONN_PROPERTIES** props;
  props = (MY_CONN_PROPERTIES**)mysqlnd_plugin_get_plugin_connection_data(
    conn, my_plugin_id);
  if (!props || !(*props)) {
    *props = mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);
    (*props)->query_counter = 0;
  }
  return props;
}
```

Розробник плагіна відповідає за керування пам'яттю даних плагіна.

Рекомендується використовувати керування пам'яттю`mysqlnd`для даних плагіна. Ці функції називаються використовуючи такі угоди:`mnd_*loc()`. Управління пам'яттю`mysqlnd`має ряд корисних властивостей, таких як використання налагоджувального модуля управління пам'яттю в неналагоджувальних зборках.

**Коли і як створювати підклас**

|  | Когда создавать подкласс? | Каждый экземпляр имеет свою собственную таблицу функций? | Как создавать подкласс? |
| --- | --- | --- | --- |
| З'єднання (MYSQLND) | MINIT | Ні | mysqlnd\_conn\_get\_methods() |
| Результуючий набір (MYSQLND\_RES) | MINIT or later | Так | mysqlnd\_result\_get\_methods() або методом об'єкта, що маніпулює таблицею функцій |
| Результуючий набір (MYSQLND\_RES\_METADATA) | MINIT | Ні | mysqlnd\_result\_metadata\_get\_methods() |
| Оператор (MYSQLND\_STMT) | MINIT | Ні | mysqlnd\_stmt\_get\_methods() |
| Мережа (MYSQLND\_NET) | MINIT чи пізніше | Так | mysqlnd\_net\_get\_methods() або методом об'єкта, що маніпулює таблицею функцій |
| Протокол обміну (MYSQLND\_PROTOCOL) | MINIT чи пізніше | Так | mysqlnd\_protocol\_get\_methods() або методом об'єкта, що маніпулює таблицею функцій |

Ви не повинні маніпулювати таблицею функцій після MINIT, якщо це не дозволено в таблиці вище.

Деякі класи містять покажчик таблицю функцій методів. Всі екземпляри подібних класів повинні ділити одну й ту саму таблицю функцій. Щоб уникнути хаосу, особливо у багатопотоковому оточенні, керувати такими таблицями функцій варто лише під час MINIT.

Інші класи використовують копії глобально поділених таблиць функцій. Таблиця функцій створюється одночасно з об'єктом. Кожен об'єкт використовує таблицю. Це дає вам дві можливості: ви можете керувати таблицею функцій за промовчанням для об'єкта під час MINIT, а також ви можете змінювати методи об'єкта, не торкаючись інших екземплярів цього ж класу.

Перевага таблиці функцій, що розділяється, у продуктивності, оскільки немає потреби копіювати таблицю функцій окремо для кожного об'єкта.

**Статус конструктора**

| Тип | Размещение, создание, сброс | Может быть изменено? | Вызывающий |
| --- | --- | --- | --- |
| Connection (MYSQLND) | mysqlnd\_init() | Ні | mysqlnd\_connect() |
| Результуючий набір (MYSQLND\_RES) |  |  |  |
| Розміщення: |  |  |  |

-   Connection::result\_init()

Скидання та повторна ініціалізація під час:

-   Result::use\_result()
    
-   Result::store\_result
    

| Так, але викличте батька! |

-   Connection::list\_fields()
    
-   Statement::get\_result()
    
-   Statement::prepare() (Тільки метадані)
    
-   Statement::resultMetaData()
    

| | Методи результуючого набору (MYSQLND\_RES\_METADATA) | Connection::result\_meta\_init() | Так, але викличте батька! | Result::read\_result\_metadata() | | Оператор (MYSQLND\_STMT) | Connection::stmt\_init() | Так, але викличте батька! | Connection::stmt\_init() | | Мережа (MYSQLND\_NET) | mysqlnd\_net\_init() | Ні | Connection::init() | | Протокол обміну (MYSQLND\_PROTOCOL) | mysqlnd\_protocol\_init() | Ні | Connection::init() |

Настійно рекомендується не замінювати конструктор цілком. Конструктори виробляють виділення пам'яті. Виділення пам'яті життєво необхідне для API плагінів`mysqlnd`та для логіки об'єкта`mysqlnd`. Якщо вам не страшні попередження і хочете сильно поміняти конструктор, то хоча б викличте батьківський конструктор перш ніж щось робити.

Незважаючи на всі попередження, це може бути корисним для конструктора підкласу. Конструктори - відмінне місце зміни таблиці функцій для об'єктів, не використовують розділену таблицю, як-от результуючий набір, мережу, протокол обміну.

**Статус знищення**

|  | Производный метод должен вызвать родительский? | Деструктор |
| --- | --- | --- |
| З'єднання | так, після виконання методу | free\_contents(), end\_psession() |
| Результуючий набір | так, після виконання методу | free\_result() |
| Метадані результуючого набору | так, після виконання методу | free() |
| Оператор | так, після виконання методу | dtor(), free\_stmt\_content() |
| Мережа | так, після виконання методу | free() |
| Протокол обміну | так, після виконання методу | free() |

Деструктори є відповідним місцем, щоб звільнити ресурси, які займають властивості.`mysqlnd_plugin_get_plugin_<object>_data()`

Перелічені деструктори можуть не збігатися з актуальними методами`mysqlnd`для очищення самого об'єкта. Однак вони є найкращим місцем, куди ви можете вклинитися для очищення даних свого плагіна. Так само, як і з конструкторами, ви можете повністю перевизначити ці методи, але робити це не рекомендується. Якщо вам необхідно вставити в кожен із перерахованих методів очищення даних свого плагіна, необхідно забезпечити запуск батьківських методів`mysqlnd`

Рекомендований метод для плагінів - виконати код очищення даних плагіна і відразу після цього викликати батьківський метод.
