---
navigation:
  - pdo.transactions.md: « Транзакції та автоматична фіксація змін
  - pdo.error-handling.md: Ошибки и их обработка »
  - index.md: PHP Manual
  - book.pdo.md: PDO
title: 'Підготовлені запити та процедури, що зберігаються'
---
# Підготовлені запити та процедури, що зберігаються

Більшість баз даних підтримують концепцію підготовлених запитів. Що це таке? Це можна описати, як вид скомпілюваного шаблону SQL запиту, який буде запускатися програмою і налаштовуватися за допомогою вхідних параметрів. Підготовлені запити мають дві головні переваги:

-   Запит необхідно якось підготувати і потім його можна запускати стільки разів, скільки потрібно, причому як з тими ж, так і з параметрами, що відрізняються. Коли запит підготовлено, СУБД аналізує його, компілює та оптимізує план його виконання. У разі складних запитів цей процес може займати відчутний час і помітно уповільнити роботу програми, якщо потрібно багато разів виконувати запит із різними параметрами. При використанні підготовленого запиту СУБД аналізує/компілює/оптимізує запит будь-якої складності лише один раз, а програма запускає на виконання вже підготовлений шаблон. Таким чином, підготовлені запити споживають менше ресурсів і працюють швидше.
-   Параметри підготовленого запиту не потрібно екранувати лапками; драйвер робить це автоматично. Якщо в додатку використовуються виключно підготовлені запити, розробник може бути впевнений, що ніяких SQL-ін'єкцій статися не може (проте, якщо інші частини тексту запиту створюються з неекранованим введенням, то ін'єкція SQL як і раніше можлива).

Підготовлені запити також корисні тим, що PDO може емулювати їх, якщо драйвер бази даних немає подібної функціональності. Це означає, що програма може користуватися однією і тією ж методикою доступу до даних незалежно від можливостей СУБД.

**Приклад #1 Вставки, що повторюються, в базу з використанням підготовлених запитів**

У цьому прикладі 2 рази виконується INSERT запит з різними значеннями `name` і `value`, які підставляються замість відповідних псевдозмінних:

```php
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (:name, :value)");
$stmt->bindParam(':name', $name);
$stmt->bindParam(':value', $value);

// вставим одну строку
$name = 'one';
$value = 1;
$stmt->execute();

// теперь другую строку с другими значениями
$name = 'two';
$value = 2;
$stmt->execute();
?>
```

**Приклад #2 Вставки в базу, що повторюються, з використанням підготовлених запитів**

У цьому прикладі 2 рази виконується INSERT запит з різними значеннями `name` і `value`, які підставляються замість псевдозмінних `?`

```php
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (?, ?)");
$stmt->bindParam(1, $name);
$stmt->bindParam(2, $value);

// вставим одну строку
$name = 'one';
$value = 1;
$stmt->execute();

// теперь другую строку с другими значениями
$name = 'two';
$value = 2;
$stmt->execute();
?>
```

**Приклад #3 Вибір даних з використанням підготовлених запитів**

У цьому прикладі проводиться вибірка з бази ключа, який вводить користувач через форму. Введення користувача автоматично полягає в лапки, тому немає ризику SQL ін'єкції.

```php
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name = ?");
$stmt->execute([$_GET['name']]);
foreach ($stmt as $row) {
  print_r($row);
}
?>
```

**Приклад #4 Виклик збереженої процедури з вихідними параметрами**

Якщо СУБД підтримує вихідні параметри, програма може користуватися ними як і вхідними. Вихідні параметри зазвичай використовують для отримання даних зі збережених процедур. Користуватися вихідними параметрами дещо складніше, оскільки розробнику необхідно знати максимальний розмір значень, що витягуються, ще на етапі завдання цих параметрів. Якщо вилучене значення виявиться більшим, ніж передбачалося, буде викликана помилка.

```php
<?php
$stmt = $dbh->prepare("CALL sp_returns_string(?)");
$stmt->bindParam(1, $return_value, PDO::PARAM_STR, 4000);

// вызов хранимой процедуры
$stmt->execute();

print "процедура вернула $return_value\n";
?>
```

**Приклад #5 Виклик збереженої процедури з вхідним/вихідним параметром**

Можна задати параметр одночасно вхідним та вихідним; синтаксис у своїй той самий, як і вихідних параметрів. У наступному прикладі рядок 'привіт' передається в процедуру, що зберігається, а потім цей рядок буде замінений повертається значенням.

```php
<?php
$stmt = $dbh->prepare("CALL sp_takes_string_returns_string(?)");
$value = 'привет';
$stmt->bindParam(1, $value, PDO::PARAM_STR|PDO::PARAM_INPUT_OUTPUT, 4000);

// вызов хранимой процедуры
$stmt->execute();

print "процедура вернула $value\n";
?>
```

**Приклад #6 Неправильне використання псевдозмінної**

```php
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name LIKE '%?%'");
$stmt->execute([$_GET['name']]);

// псевдопеременная может использоваться только в виде отдельного значения
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name LIKE ?");
$stmt->execute(["%$_GET[name]%"]);
?>
```
