Синтаксис генераторів

-   [«Знайомство з генераторами](language.generators.overview.html)
    
-   [Порівняння генераторів з об'єктами класу Iterator »](language.generators.comparison.html)
    
-   [PHP Manual](index.html)
    
-   [Генераторы](language.generators.html)
    
-   Синтаксис генераторів
    

## Синтаксис генераторів

Генератор в цілому виглядає як звичайна функція, за винятком того, що замість повернення одного значення, генератор перебиратиме стільки значень, скільки необхідно. Будь-яка функція, що містить [yield](language.generators.syntax.html#control-structures.yield)є функцією генератора.

Коли генератор викликається, він повертає об'єкт, який можна ітерувати. Коли ви ітеруєте цей об'єкт (наприклад, у циклі [foreach](control-structures.foreach.html)), PHP викликає методи ітерації об'єкта щоразу, коли вам потрібне нове значення, після чого зберігає стан генератора і при наступному виклику повертає наступне значення.

Коли всі значення генератора закінчилися, генератор просто завершить роботу, нічого не повернувши. Після цього основний код продовжить роботу, як у масиві закінчилися елементи для перебору.

> **Зауваження**
> 
> Генератори можуть повертати значення, які можна отримати за допомогою [Generator::getReturn()](generator.getreturn.html)

### Ключове слово **yield**

Вся суть генератора полягає у ключовому слові **yield**. У найпростішому варіанті оператор "yield" можна розглядати як оператор "return", за винятком того, що замість припинення роботи функції, "yield" тільки зупиняє її виконання та повертає поточне значення, і при наступному виклику функції вона відновить виконання з місця на якому перервалася.

**Приклад #1 Простий приклад видачі значень**

```php
<?php
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Обратите внимание, что $i сохраняет своё значение между вызовами.
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}
?>
```

Результат виконання цього прикладу:

```
1
2
3
```

> **Зауваження**
> 
> Послідовність цілих чисел буде пов'язана з одержуваними від генератора значеннями, начебто перебирається неасоціативний масив.

**Застереження**

Значення, яке буде надано $data, - це значення, передане [Generator::send()](generator.send.html) або \*\*`null`\*\*якщо замість цього викликається [Generator::next()](generator.next.html)

#### Отримання значень із ключами

PHP підтримує асоціативні масиви, і генератори є винятком. Так само, як можна отримувати прості значення, як показано вище, ви можете отримувати значення з ключами.

Синтаксис отримання ключ/значення дуже схожий на синтаксис асоціативних масивів, як показано нижче.

**Приклад #2 Отримання пар ключ/значення**

```php
<?php
/* $input содержит пары ключ/значение разделённые точкой с запятой */

$input = <<<'EOF'
1;PHP;Любит знаки доллара
2;Python;Любит пробелы
3;Ruby;Любит блоки
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}
?>
```

Результат виконання цього прикладу:

```
1:
    PHP
    Любит знаки доллара
2:
    Python
    Любит пробелы
3:
    Ruby
    Любит блоки
```

**Застереження**

Також як і для одиночних значень, отримання пар ключ/значення у виразах вимагає обертання їх у дужки:

```php
$data = (yield $key => $value);
```

#### Отримання NULL

Для отримання **`null`** Треба викликати "Yield" без аргументів. Ключ згенерується автоматично.

**Приклад #3 Отримання **`null`****

```php
<?php
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>
```

Результат виконання цього прикладу:

```
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
```

#### Набуття значення за посиланням

Генератори можуть надавати значення за посиланням. Це робиться так само, як [возврат ссылок из функций](functions.returning-values.html)": додавання амперсанди (&) перед ім'ям функції.

**Приклад #4 Отримання значень за посиланням**

```php
<?php
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/* Обратите внимание, что мы можем изменять $number в цикле, и
 * так как генератор возвращает ссылку, $value
 * в gen_reference() также изменится. */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}
?>
```

Результат виконання цього прикладу:

```
2... 1... 0...
```

#### Делегування генератора за допомогою **yield from**

Делегування генератора дозволяє вам отримувати значення з іншого генератора, об'єкта [Traversable](class.traversable.html), або масиву, використовуючи **yield from**. Зовнішній генератор повертатиме значення з внутрішнього генератора, об'єкта або масиву, до того часу, поки вони їх віддають, після чого продовжиться виконання зовнішнього генератора.

Якщо генератор використовується з **yield from**, то вираз **yield from** також повертатиме значення з внутрішнього генератора.

**Застереження**

# Збереження масиву (наприклад, за допомогою [iteratorтоarray()](function.iterator-to-array.html)

**yield from** не скидає ключі. Ключі, повернуті з об'єкту [Traversable](class.traversable.html) або масиву, збережуться. Таким чином, деякі значення можуть перетинатися по ключах з іншими **yield** або **yield from**, Що, при записі в масив, спричинить перезапис колишніх значень.

Загальний випадок, коли це має значення, це коли [iteratorтоarray()](function.iterator-to-array.html) повертає масив із ключами за замовчуванням. В цьому випадку можна отримати несподіваний результат . [iteratorтоarray()](function.iterator-to-array.html) має другий параметр `use_keys`, який можна встановити в **`false`**, для генерації власних ключів та ігнорування ключів, переданих з об'єкта [Generator](class.generator.html)

**Приклад #5 **yield from** з [iteratorтоarray()](function.iterator-to-array.html)**

```php
<?php
function inner() {
    yield 1; // ключ 0
    yield 2; // ключ 1
    yield 3; // ключ 2
}
function gen() {
    yield 0; // ключ 0
    yield from inner(); // ключи 0-2
    yield 4; // ключ 1
}
// Задайте false вторым параметром для получения массива [0, 1, 2, 3, 4]
var_dump(iterator_to_array(gen()));
?>
```

Результат виконання цього прикладу:

```
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(4)
  [2]=>
  int(3)
}
```

**Приклад #6 Основи використання **yield from****

```php
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    yield 9;
    yield 10;
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

foreach (count_to_ten() as $num) {
    echo "$num ";
}
?>
```

Результат виконання цього прикладу:

```
1 2 3 4 5 6 7 8 9 10
```

**Приклад #7 **yield from** і значення, що повертаються**

```php
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    return yield from nine_ten();
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

function nine_ten() {
    yield 9;
    return 10;
}

$gen = count_to_ten();
foreach ($gen as $num) {
    echo "$num ";
}
echo $gen->getReturn();
?>
```

Результат виконання цього прикладу:

```
1 2 3 4 5 6 7 8 9 10
```