---
navigation:
  - language.generators.overview.md: «Знайомство з генераторами
  - language.generators.comparison.md: Порівняння генераторів з об'єктами класу Iterator »
  - index.md: PHP Manual
  - language.generators.md: Генератори
title: Синтаксис генераторів
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Синтаксис генераторів

Генератор в цілому виглядає як звичайна функція, за винятком того, що замість повернення одного значення, генератор перебиратиме стільки значень, скільки необхідно. Будь-яка функція, що містить [yield](language.generators.syntax.md#control-structures.yield)є функцією генератора.

Коли генератор викликається, він повертає об'єкт, який можна ітерувати. Коли ви ітеруєте цей об'єкт (наприклад, у циклі [foreach](control-structures.foreach.md)), PHP викликає методи ітерації об'єкта щоразу, коли вам потрібне нове значення, після чого зберігає стан генератора і при наступному виклику повертає наступне значення.

Коли всі значення генератора закінчилися, генератор просто завершить роботу, нічого не повернувши. Після цього основний код продовжить роботу, як у масиві закінчилися елементи для перебору.

> **Зауваження** :
> 
> Генератори можуть повертати значення, які можна отримати за допомогою [Generator::getReturn()](generator.getreturn.md)

### Ключевое слово**yield**

Вся суть генератора полягає у ключовому слові **yield**. . У найпростішому варіанті оператор "yield" можна розглядати як оператор "return", за винятком того, що замість припинення роботи функції, "yield" тільки зупиняє її виконання та повертає поточне значення, і при наступному виклику функції вона відновить виконання з місця на якому перервалася.

**Приклад #1 Простий приклад видачі значень**

```php
<?php
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Обратите внимание, что $i сохраняет своё значение между вызовами.
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}
?>
```

Результат виконання наведеного прикладу:

```
1
2
3
```

> **Зауваження** :
> 
> Послідовність цілих чисел буде пов'язана з одержуваними від генератора значеннями, начебто перебирається неасоціативний масив.

#### Отримання значень із ключами

PHP підтримує асоціативні масиви, і генератори є винятком. Так само, як можна отримувати прості значення, як показано вище, ви можете отримувати значення з ключами.

Синтаксис отримання ключ/значення дуже схожий на синтаксис асоціативних масивів, як показано нижче.

**Приклад #2 Отримання пар ключ/значення**

```php
<?php
/* $input содержит пары ключ/значение разделённые точкой с запятой */

$input = <<<'EOF'
1;PHP;Любит знаки доллара
2;Python;Любит пробелы
3;Ruby;Любит блоки
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}
?>
```

Результат виконання наведеного прикладу:

```
1:
    PHP
    Любит знаки доллара
2:
    Python
    Любит пробелы
3:
    Ruby
    Любит блоки
```

#### Отримання NULL

Для получения\*\*`null`\*\* Треба викликати "Yield" без аргументів. Ключ згенерується автоматично.

**Пример #3 Получение**`null`\*\*\*\*

```php
<?php
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>
```

Результат виконання наведеного прикладу:

```
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
```

#### Отримання значення за посиланням

Генератори можуть надавати значення за посиланням. Це робиться так само, як [повернення посилань із функцій](functions.returning-values.md): додаванням амперсанда (&) перед ім'ям функції.

**Приклад #4 Отримання значень за посиланням**

```php
<?php
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/* Обратите внимание, что мы можем изменять $number в цикле, и
 * так как генератор возвращает ссылку, $value
 * в gen_reference() также изменится. */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}
?>
```

Результат виконання наведеного прикладу:

```
2... 1... 0...
```

#### Делегирование генератора с помощью**yield from**

Делегування генератора дозволяє вам отримувати значення з іншого генератора, об'єкта [Traversable](class.traversable.md), або масиву, використовуючи **yield from**. Зовнішній генератор повертатиме значення з внутрішнього генератора, об'єкта або масиву, до того часу, поки вони їх віддають, після чого продовжиться виконання зовнішнього генератора.

Якщо генератор використовується з **yield from**, то вираз **yield from** також повертатиме значення з внутрішнього генератора.

**Застереження**

# Сохранение в массив (например, с помощью[iterator\_to\_array()](function.iterator-to-array.md)) .

**yield from** не скидає ключі. Ключі, повернуті з об'єкту [Traversable](class.traversable.md) або масиву, збережуться. Таким чином, деякі значення можуть перетинатися по ключах з іншими **yield**или**yield from**, Що, при записі в масив, спричинить перезапис колишніх значень.

Загальний випадок, коли це має значення, це коли [iterator\_to\_array()](function.iterator-to-array.md) повертає масив із ключами за замовчуванням. В цьому випадку можна отримати несподіваний результат . [iterator\_to\_array()](function.iterator-to-array.md) має другий параметр `preserve_keys`, який можна встановити в **`false`**, для генерації власних ключів та ігнорування ключів, переданих з об'єкта [Generator](class.generator.md)

**Пример #5**yield from**с[iterator\_to\_array()](function.iterator-to-array.md)**

```php
<?php
function inner() {
    yield 1; // ключ 0
    yield 2; // ключ 1
    yield 3; // ключ 2
}
function gen() {
    yield 0; // ключ 0
    yield from inner(); // ключи 0-2
    yield 4; // ключ 1
}
// Задайте false вторым параметром для получения массива [0, 1, 2, 3, 4]
var_dump(iterator_to_array(gen()));
?>
```

Результат виконання наведеного прикладу:

```
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(4)
  [2]=>
  int(3)
}
```

**Приклад #6 Основи використання **yield from****

```php
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    yield 9;
    yield 10;
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

foreach (count_to_ten() as $num) {
    echo "$num ";
}
?>
```

Результат виконання наведеного прикладу:

```
1 2 3 4 5 6 7 8 9 10
```

**Пример #7**yield from\*\* і значення, що повертаються\*\*

```php
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    return yield from nine_ten();
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

function nine_ten() {
    yield 9;
    return 10;
}

$gen = count_to_ten();
foreach ($gen as $num) {
    echo "$num ";
}
echo $gen->getReturn();
?>
```

Результат виконання наведеного прикладу:

```
1 2 3 4 5 6 7 8 9 10
```
