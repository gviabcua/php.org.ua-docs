- [« Ds\Map::hasValue](ds-map.hasvalue.md)
- [Ds\Map::isEmpty »](ds-map.isempty.md)

- [PHP Manual](index.md)
- [Колекція пар ключ-значення](class.ds-map.md)
- Створює нову колекцію пар, створену перетином з іншого
колекцією пар

# Ds\Map::intersect

(PECL ds \>= 1.0.0)

Ds\Map::intersect — Створює нову колекцію пар, створену перетином
з іншою колекцією пар

### Опис

public **Ds\Map::intersect**([Ds\Map](class.ds-map.md) `$map`):
[Ds\Map](class.ds-map.md)

Створює нову колекцію пар з поточної, що містить елементи, ключі
яких присутні як у поточній колекції, так і в переданій
параметрі `map`. Іншими словами, повертає копію поточної колекції,
якої видалені всі елементи, ключі яких відсутні в колекції
`map`.

`A ∩ B = {x : x ∈ A ∧ x ∈ B}`

> **Примітка**:
>
> Значення беруться із поточної колекції пар.

### Список параметрів

`map`
Нова колекція типу Map.

### Значення, що повертаються

Перетин поточної колекції та переданої в `map`.

### Також дивіться

- [» Перетин](https://en.wikipedia.org/wiki/Intersection_(set_theory))
на Вікіпедія

### Приклади

**Приклад #1 Приклад використання **Ds\Map::intersect()****

` <?php$a = new \Ds\Map(["a" => 1, "b" => 2, c" => 3]);$b = new \Ds\Map(["b" => 4, "c" => 5, "d" => 6]);var_dump($a->intersect($b));?> `

Результатом виконання цього прикладу буде щось подібне:

object(Ds\Map)#3 (2) {
[0]=>
object(Ds\Pair)#4 (2) {
["key"]=>
string(1) "b"
["value"]=>
int(2)
}
[1]=>
object(Ds\Pair)#5 (2) {
["key"]=>
string(1) "c"
["value"]=>
int(3)
}
}
