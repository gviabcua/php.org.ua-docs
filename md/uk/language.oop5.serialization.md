---
navigation:
  - language.oop5.references.md: « Об'єкти та посилання
  - language.oop5.variance.md: Коваріантність та контраваріантність »
  - index.md: PHP Manual
  - language.oop5.md: Класи та об'єкти
title: Серіалізація об'єктів
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Серіалізація об'єктів

## Серіалізація об'єктів - збереження об'єктів між сесіями

Функция[serialize()](function.serialize.md) повертає рядкове подання будь-якого значення, яке може бути збережене у PHP. Функція [unserialize()](function.unserialize.md) може використовувати цей рядок для відновлення вихідного значення змінної. Використання серіалізації для збереження об'єкта збереже всі його змінні. Методи в об'єкті не будуть збережені лише ім'я класу.

Щоб десеріалізувати об'єкт функцією [unserialize()](function.unserialize.md)необхідно заздалегідь визначити клас цього об'єкта. Тобто, якщо є екземпляр класу А, і він буде серіалізований, буде отримано його рядкове уявлення, яке містить значення всіх змінних, що містяться в ньому. Щоб відновити об'єкт із рядка в іншому PHP-файлі, клас A повинен бути визначений у цьому файлі заздалегідь. Це можна зробити, наприклад, шляхом збереження визначення класу A в окремому файлі та підключення цього файлу або викликом функції [spl\_autoload\_register()](function.spl-autoload-register.md) для автоматичного з'єднання.

```php
<?php
// A.php:

  class A {
      public $one = 1;

      public function show_one() {
          echo $this->one;
      }
  }

// page1.php:

  include "A.php";

  $a = new A;
  $s = serialize($a);
  // сохраняем $s где-нибудь, откуда page2.php сможет его получить.
  file_put_contents('store', $s);

// page2.php:

  // это нужно для того, чтобы функция unserialize работала правильно.
  include "A.php";

  $s = file_get_contents('store');
  $a = unserialize($s);

  // теперь можно использовать метод show_one() объекта $a.
  $a->show_one();
?>
```

Якщо в додатку серіалізуються об'єкти, які будуть використані в додатку пізніше, слідують суворій рекомендації — підключати визначення класу для цього об'єкта у всьому додатку. При невиконанні цієї вимоги десеріалізація об'єкта пройде без визначення класу, але PHP призначить цьому об'єкту клас **\_\_PHP\_Incomplete\_Class\_Name**, що не має методів, і зробить об'єкт марним.

Тому, як у прикладі вище, якщо змінна $a стала частиною сесії шляхом додавання нового ключа до суперглобального масиву [$\_SESSION](reserved.variables.session.md)потрібно підключати файл `A.php` на всіх сторінках, а не лише на сторінках page1.php та page2.php.

Зверніть увагу, що, окрім уже наведеної поради, можна підключитися до подій серіалізації та десеріалізації об'єкта через методи [\_\_sleep()](language.oop5.magic.md#object.sleep) і [\_\_wakeup()](language.oop5.magic.md#object.wakeup)В методе[\_\_sleep()](language.oop5.magic.md#object.sleep) можна керувати тим, які якості об'єкта будуть серіалізовані.
