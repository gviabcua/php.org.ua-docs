- [«call_user_func](function.call-user-func.md)
- [forward_static_call_array »](function.forward-static-call-array.md)

- [PHP Manual](index.md)
- [Функції керування функціями](ref.funchand.md)
- Створює функцію динамічно, оцінюючи рядок коду

#create_function

(PHP 4 \>= 4.0.1, PHP 5, PHP 7)

create_function — Створює функцію динамічно, оцінюючи рядок коду

**Увага**

Ця функція оголошена *УСТАРНІЙ*, починаючи з PHP 7.2.0 і була *Видалена*
у версії PHP 8.0.0. Використовувати цю функцію не рекомендується.

### Опис

**create_function**(string `$args`, string `$code`): string

Створює функцію динамічно з переданих параметрів та повертає її
Унікальне ім'я.

**Застереження**

Функція всередині робить виклик функції [eval()](function.eval.md), а
значить має такі самі проблеми з безпекою, як і
[eval()](function.eval.md). Також у неї погані характеристики
продуктивності та використання пам'яті, оскільки створені функції
є глобальними і не можуть бути звільнені.

Використовуйте [анонімні функції](functions.anonymous.md).

### Список параметрів

Зазвичай рекомендується передавати параметри у вигляді рядків [з одинарним лапкою](language.types.string.md#language.types.string.syntax.single).
При використанні рядків [з подвійним лапкою](language.types.string.md#language.types.string.syntax.double)
імена змінних у коді повинні бути ретельно екрановані, наприклад,
ось так: `\$ somevar`.

`args`
Аргументи функції у вигляді рядка, розділеного комами.

`code`
Код функції.

### Значення, що повертаються

Повертає унікальне ім'я функції у вигляді рядка або **`false`** у випадку
виникнення помилки. Зверніть увагу, що ім'я містить недрукований
символ (`` "`), тому слід дотримуватися обережності під час друку імені
або включення його в будь-який інший рядок.

### Приклади

**Приклад #1 Створення функції динамічно за допомогою **create_function()**
або анонімних функцій**

Ви можете використовувати динамічно створену функцію, щоб, наприклад,
створити функцію з урахуванням інформації, зібраної під час виконання.
По-перше, використовуючи функцію create_function()**:

` <?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo $newfunc( 2, M_E) . "
";?> `

Тепер той самий код, використовуючи [анонімну функцію](functions.anonymous.md); зверніть увагу, що код і
аргументи більше не містяться у рядках:

` <?php$newfunc = function($a,$b) { return "ln($a) + ln($b) = " . log($a * $b); };echo $newfunc(2, M_E) . "
";?> `

Результат виконання цього прикладу:

ln(2) + ln(2.718281828459) = 1.6931471805599

**Приклад #2 Створення загальної функції-обробника за допомогою
**create_function()** або анонімних функцій**

Іншим варіантом використання може бути загальна функція-обробник,
яка може застосовувати набір операцій до списку параметрів:

` <?phpfunction process($var1, $var2, $farr){   foreach ($farr as $f) {       echo $f($var1, $var2) . "
";    }}// створюємо купу математичних функцій$farr = array(   create_function('$x,$y', 'return "тригонометрія: ".(sin($x) +$); ),   create_function('$x,$y', 'return "гіпотенуза: ".sqrt($x*$x + $y*$y);'),   create_function('$a,$b', 'if ( $a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;}'),   create_function('$a,$b', "return \" min(b^2+a, a^2,b)== \".min(\$a*\$a+\$b,\$b*\$b+\$a);"),    create_function('$ a,$b', 'if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; }') );echo "
Використання першого масиву динамічних функцій
";echo "Параметри: 2.3445, M_PI
";process(2.3445, M_PI, $farr);// тепер створюємо купу функцій обробки рядків$garr = array(   create_function('$b,$a', 'if (str) 0) return "** \"$a\" '.       'і \"$b\"
** для мені однакові! (дивлячись по першим 3 символам)";'),   create_function('$a,$b', 'return "CRCs: " . crc32($a) . ", ".crc32($b);'                                                         crc32($b);'                          cc33($b);' ■ '$a,$b', 'return "similar(a,b) = " . similar_text($a, $b, $p) . "($p%)";'));echo "
Використання другого масиву динамічних функцій
";process("Варкалося. Хливі шорьки піралися за наве", "Варан повзе", $garr);?> `

І знову, той же код з використанням [анонімних функцій](functions.anonymous.md). Зверніть увагу, що імена
змінних у коді більше не потрібно екранувати, оскільки вони не
укладено у рядок.

` <?phpfunction process($var1, $var2, $farr){   foreach ($farr as $f) {       echo $f($var1, $var2) . "
";    }}// творюємо купу математичних функцій$farr = array(    function($x,$y) { return "тригонометрія: ".(sin($x) + $x*   ($x,$y) { return "гіпотенуза: ".sqrt($x*$x + $y*$y); },    function($a,$b) { if ($a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;} },   function($a,$b) { return "min(b^2+a, a^2, b) = " . min($a*$a+$b, $b*$b+$a); },    function($a,$b) { if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; } });echo "
Використання першого масиву динамічних функцій
";echo "Параметри: 2.3445, M_PI
process(2.3445, M_PI, $ farr); return "** \"$a\" " .        "і \"$b\"
** для мені однакові! (дивлячись по перших 3 символів)"; },   function($a,$b) { return "CRCs: " . crc32($a) . ", ".crc32($b); $, $ b) { return "similar(a,b) = " . similar_text($a, $b, $p) . "($p%)"; });echo "
Використання другого масиву динамічних функцій
";process("Варкалося. Хливі шорьки піралися за наве", "Варан повзе", $garr);?> `

Результат виконання цього прикладу:

Використання першого масиву динамічних функцій
Параметри: 2.3445, M_PI
тригонометрія: -1.6291725057799
гіпотенуза: 3.9199852871011
b*a^2 = 4.8103313314525
min(b^2+a, a^2,b) = 8.6382729035898
ln(a)/b = 0.27122299212594

Використання другого масиву динамічних функцій
** "Варан повзе" і "Варкалося.
** для мене однакові! (дивлячись за першими 3 символами)
CRCs: 2672527412, 2269828269
similar(a,b) = 16(31.683168316832%)

**Приклад #3 Використання динамічних функцій як
callback-функцій**

Можливо, найпоширенішим використанням динамічних функцій
є передача їх як callback-функцій, наприклад, при
використання [array_walk()](function.array-walk.md) або
[usort()](function.usort.md).

` <?php$av = array("the ", "a ", "that ", "this ");array_walk($av, create_function('&$v,$k', '$v = $v . ") mango";'));print_r($av);?> `

Перетворення наведеного вище коду на [анонімну функцію](functions.anonymous.md):

` <?php$av = array("о, ", "ех, ", "то ", "це ");array_walk($av, create_function('&$v,$k', '$v = $v . "манго";'));print_r($av);?> `

Результат виконання цього прикладу:

Array
(
[0] => о, манго
[1] => ех, манго
[2] => то манго
[3] => це манго
)

Сортування рядків від найдовшого до найкоротшого за допомогою
**create_function()**:

` <?php$sv = array("мало", "багато", "великий рядок", "рядок рядок рядок");echo "Оригінальний масив:
";print_r($sv);echo "Відсортований:
";usort($sv, create_function('$a,$b','return strlen($b) - strlen($a);'));print_r($sv);?> `

Перетворення наведеного вище коду на [анонімну функцію](functions.anonymous.md):

` <?php$sv = array("мало", "багато", "великий рядок", "рядок рядок рядок");echo "Оригінальний масив:
";print_r($sv);echo "Відсортований:
";usort($sv,function($a,$b) { return strlen($b) - strlen($a); });print_r($sv);?> `

Результат виконання цього прикладу:

Оригінальний масив:
Array
(
[0] => мало
[1] => багато
[2] => великий рядок
[3] => рядок рядок рядок
)
Відсортований:
Array
(
[0] => рядок рядок рядок
[1] => великий рядок
[2] => багато
[3] => мало
)

### Дивіться також
 - [Анонімні функції](functions.anonymous.md)
