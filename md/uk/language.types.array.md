---
navigation:
  - language.types.numeric-strings.html: Числові рядки
  - language.types.iterable.md: Ітеровані »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Масиви
---
## Масиви

Насправді масив у PHP - це впорядковане відображення, яке встановлює відповідність між *значенням* і *ключем*. Цей тип оптимізовано в декількох напрямках, тому ви можете використовувати його як власне масив, список (вектор), хеш-таблицю (що є реалізацією карти), словник, колекцію, стек, черга і, можливо, ще щось. Оскільки значенням масиву може бути інший масив PHP, можна також створювати дерева та багатовимірні масиви.

Пояснення цих структур даних виходить за рамки цього довідкового посібника, але ви знайдете як мінімум один приклад щодо кожної з них. За додатковою інформацією ви можете звернутися до відповідної літератури на цю велику тему.

### Синтаксис

#### Визначення за допомогою [array()](function.array.md)

Масив (тип array) може бути створений мовною конструкцією [array()](function.array.md). Як параметри вона приймає будь-яку кількість розділених комами пар `key => value` (Ключ => значення).

```
array(
    key  => value,
    key2 => value2,
    key3 => value3,
    ...
)
```

Кома після останнього елемента масиву необов'язкова і може бути опущена. Зазвичай це робиться для однорядкових масивів, тобто `array(1, 2)` переважніше `array(1, 2, )`. Для багаторядкових масивів з іншого боку зазвичай використовується завершальна кома, так як дозволяє легше додавати нові елементи в кінець масиву.

> **Зауваження**
> 
> Існує короткий синтаксис масиву, який замінює `array()` на `[]`

**Приклад #1 Простий масив**

```php
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Использование синтаксиса короткого Масива
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
```

key може бути типу int, або типу string. value може бути будь-якого типу.

Додатково з ключем key будуть зроблені такі перетворення:

-   Рядки (string), що містять ціле число (int) (за винятком випадків, коли число випереджається знаком `+`) будуть перетворені до типу int. Наприклад, ключ зі значенням `"8"` буде насправді збережено зі значенням `8`. З іншого боку, значення `"08"` не буде перетворено, тому що воно не є коректним десятковим цілим.
-   Числа з плаваючою точкою (float) також будуть перетворені до типу int, тобто дрібна частина буде відкинута. Наприклад, ключ зі значенням `8.7` буде насправді збережено зі значенням `8`
-   Тип bool також перетворюються на тип int. Наприклад, ключ зі значенням `true` буде збережено зі значенням `1` та ключ зі значенням `false` буде збережено зі значенням `0`
-   Тип null буде перетворено на порожній рядок. Наприклад, ключ зі значенням `null` буде насправді збережено зі значенням `""`
-   Масиви (array) та об'єкти (object) *не можуть* використовуватися як ключі. При такому використанні генеруватиметься попередження: `Недопустимый тип смещения (Illegal offset type)`

Якщо кілька елементів в оголошенні масиву використовують однаковий ключ, то тільки останній буде використовуватись, а всі інші будуть перезаписані.

**Приклад #2 Приклад перетворення типів та перезапису елементів**

```php
<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(1) {
  [1]=>
  string(1) "d"
}
```

Оскільки всі ключі у наведеному вище прикладі перетворюються на `1`, значення буде перезаписано на кожен новий елемент і залишиться тільки останнє значення `"d"`

Масиви PHP можуть містити ключі типів int і string одночасно, так як PHP не робить відмінності між індексованими і асоціативними масивами.

**Приклад #3 Змішані ключі типів int та string**

```php
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
```

Параметр key є необов'язковим. Якщо він не вказаний, PHP використовуватиме попереднє найбільше значення ключа типу int збільшене на 1.

**Приклад #4 Індексовані масиви без ключа**

```php
<?php
$array = array("foo", "bar", "hallo", "world");
var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hallo"
  [3]=>
  string(5) "world"
}
```

Можливо вказати ключ тільки для деяких елементів та пропустити для інших:

**Приклад #5 Ключі для деяких елементів**

```php
<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
```

Як ви бачите останнє значення `"d"` було присвоєно ключу `7`. Це сталося тому, що найбільше значення ключа цілого типу перед цим було `6`

**Приклад #6 Розширений приклад перетворення типів та перезапису елементів**

```php
<?php
$array = array(
    1    => 'a',
    '1'  => 'b', // значение "b" перезапишет значение "a"
    1.5  => 'c', // значение "c" перезапишет значение "b"
    -1 => 'd',
    '01'  => 'e', // поскольку это не целочисленная строка, она НЕ перезапишет ключ для 1
    '1.5' => 'f', // поскольку это не целочисленная строка, она НЕ перезапишет ключ для 1
    true => 'g', // значение "g" перезапишет значение "c"
    false => 'h',
    '' => 'i',
    null => 'j', // значение "j" перезапишет значение "i"
    'k', // значение "k" присваивается ключу 2. Потому что самый большой целочисленный ключ до этого был 1
    2 => 'l', // значение "l" перезапишет значение "k"
);

var_dump($array);
?>
```

Результат виконання цього прикладу:

```
array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
```

Цей приклад включає всі варіації перетворення ключів та перезапису елементів

#### Доступ до елементів масиву за допомогою квадратних дужок

Доступ до елементів масиву може бути здійснений синтаксисом. `array[key]`

**Приклад #7 Доступ до елементів масиву**

```php
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
?>
```

Результат виконання цього прикладу:

```
string(3) "bar"
int(24)
string(3) "foo"
```

> **Зауваження**
> 
> До PHP 8.0.0 квадратні та фігурні дужки могли використовуватися взаємозамінно для доступу до елементів масиву (наприклад, у прикладі вище `$array[42]` і `$array{42}` робили те саме). Синтаксис фігурних дужок застарів у PHP 7.4.0 і більше не підтримується у PHP 8.0.0.

**Приклад #8 Розіменування масиву**

```php
<?php
function getArray() {
    return array(1, 2, 3);
}

$secondElement = getArray()[1];
?>
```

> **Зауваження**
> 
> Спроба доступу до невизначеного ключа в масиві - це те саме, що й спроба доступу до будь-якої іншої невизначеної змінної: буде згенеровано помилку рівня **`E_NOTICE`**, і результат буде **`null`**

> **Зауваження**
> 
> Масив, що розіменовує скалярне значення, яке не є рядком (string), віддасть **`null`**. До PHP 7.4.0 не видається повідомлення про помилку. Починаючи з PHP 7.4.0, видається помилка **`E_NOTICE`**; з PHP 8.0.0 видається помилка **`E_WARNING`**

#### Створення/модифікація за допомогою синтаксису квадратних дужок

Існуючий масив може бути змінений шляхом явної установки значень у ньому.

Це виконується присвоєнням значень масиву (array) із зазначенням у дужках ключа. Крім того, ключ можна опустити, в результаті вийде порожня пара дужок (`[]`

```
$arr[key] = value;
    $arr[] = value;
    // key может быть int или string
    // value может быть любым значением любого типа
```

Якщо масив $arr ще не існує або для нього встановлено значення **`null`** або \*\*`false`\*\*він буде створений. Таким чином, це ще один спосіб визначити масив array. Однак такий спосіб застосовувати не рекомендується, оскільки якщо змінна $arr вже містить деяке значення (наприклад, значення типу string із змінної запиту), то це значення залишиться на місці і `[]` може насправді означати [доступ к символу в строке](language.types.string.html#language.types.string.substr). Краще ініціалізувати змінну шляхом явного надання значення.

> **Зауваження**: Починаючи з PHP 7.1.0, використовуючи в оператор "порожній індекс" на рядку, призведе до фатальної помилки. Раніше, у цьому випадку, рядок мовчки перетворювався на масив.

> **Зауваження**: Починаючи з PHP 8.1.0, створення нового масиву за допомогою значення **`false`** застаріло. Створення нового масиву з **`null`** і невизначеного значення, як і раніше, дозволено.

Для зміни певного значення просто надайте нове значення елементу, використовуючи його ключ. Якщо ви бажаєте видалити пару ключ/значення, вам необхідно використовувати функцію [unset()](function.unset.md)

```php
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // В этом месте скрипта это
                // то же самое, что и $arr[13] = 56;

$arr["x"] = 42; // Это добавляет к Масиву новый
                // элемент с ключом "x"

unset($arr[5]); // Это удаляет элемент из Масива

unset($arr);    // Это удаляет Масив полностью
?>
```

> **Зауваження**
> 
> Як уже говорилося вище, якщо ключ не був вказаний, то буде взято максимальний з існуючих цілих (int) індексів, і новим ключем буде це максимальне значення (в крайньому випадку 0) плюс 1. Якщо цілих (int) індексів ще немає, то ключем буде `0` (нуль).
> 
> Врахуйте, що максимальне ціле значення ключа *не обов'язково існує в масиві в даний момент*. Воно могло просто існувати в масиві якийсь час, відколи він був переіндексований востаннє. Наступний приклад це ілюструє:
> 
> ```php
> <?php
> // Создаём простой Масив.
> $array = array(1, 2, 3, 4, 5);
> print_r($array);
> 
> // Теперь удаляем каждый элемент, но сам Масив оставляем нетронутым:
> foreach ($array as $i => $value) {
>     unset($array[$i]);
> }
> print_r($array);
> 
> // Добавляем элемент (обратите внимание, что новым ключом будет 5, вместо 0).
> $array[] = 6;
> print_r($array);
> 
> // Переиндексация:
> $array = array_values($array);
> $array[] = 7;
> print_r($array);
> ?>
> ```
> 
> Результат виконання цього прикладу:
> 
> ```
> Array
> (
>     [0] => 1
>     [1] => 2
>     [2] => 3
>     [3] => 4
>     [4] => 5
> )
> Array
> (
> )
> Array
> (
>     [5] => 6
> )
> Array
> (
>     [0] => 6
>     [1] => 7
> )
> ```

#### Деструктуризація масиву

Масиви можуть бути деструктуровані за допомогою мовних конструкцій `[]` (починаючи з PHP 7.1.0) або [list()](function.list.md). Ці конструкції можуть бути використані для деструктуризації масиву окремі змінні.

```php
<?php
$source_array = ['foo', 'bar', 'baz'];
[$foo, $bar, $baz] = $source_array;
echo $foo;    // выведет "foo"
echo $bar;    // выведет "bar"
echo $baz;    // выведет "baz"
?>
```

Деструктуризація масиву може бути використана в конструкції [foreach](control-structures.foreach.html) для деструктуризації багатовимірного масиву під час ітерації щодо нього.

```php
<?php
$source_array = [
    [1, 'John'],
    [2, 'Jane'],
];
foreach ($source_array as [$id, $name]) {
    // логика работы с $id и $name
}
?>
```

Елементи масиву ігноруватимуться, якщо змінна не вказана. Деструктуризація масиву завжди починається з індексу `0`

```php
<?php
$source_array = ['foo', 'bar', 'baz'];

// Присваивание элементу с индексом 2 переменной $baz
[, , $baz] = $source_array;

echo $baz;    // выведет "baz"
?>
```

Починаючи з PHP 7.1.0, асоціативні масиви можуть бути деструктуровані. Це дозволяє легше вибирати потрібний елемент у масивах з числовим індексом, оскільки індекс може бути явно вказаний.

```php
<?php
$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Присваивание элементу с индексом 'baz' переменной $three
['baz' => $three] = $source_array;

echo $three;    // выведет 3

$source_array = ['foo', 'bar', 'baz'];

// Присваивание элементу с индексом 2 переменной $baz
[2 => $baz] = $source_array;

echo $baz;    // выведет "baz"
?>
```

Деструктуризація масиву може бути використана для простої заміни двох змінних місць.

```php
<?php
$a = 1;
$b = 2;
[$b, $a] = [$a, $b];
echo $a;    // выведет 2
echo $b;    // выведет 1
?>
```

> **Зауваження**
> 
> Оператор `...` не підтримується у привласненнях.

> **Зауваження**
> 
> Спроба отримати доступ до ключа масиву, який не був визначений, аналогічна до будь-якої іншої невизначеної змінної: буде видано повідомлення про помилку рівня **`E_NOTICE`** (Рівень **`E_WARNING`** в PHP 8.0.0), а результатом буде **`null`**

### Корисні функції

Для роботи з масивами існує достатньо корисних функцій. Дивіться розділ [функції для роботи з масивами](ref.array.md)

> **Зауваження**
> 
> Функція [unset()](function.unset.md) дозволяє видаляти ключі масиву. Зверніть увагу, що масив *НЕ* буде переіндексовано. Якщо ви дійсно хочете поведінки в стилі "видалити і зрушити", можна переіндексувати масив використовуючи [arrayvalues()](function.array-values.html)
> 
> ```php
> <?php
> $a = array(1 => 'один', 2 => 'два', 3 => 'три');
> unset($a[2]);
> /* даст Масив, представленный так:
>    $a = array(1 => 'один', 3 => 'три');
>    а НЕ так:
>    $a = array(1 => 'один', 2 => 'три');
> */
> 
> $b = array_values($a);
> // Теперь $b это array(0 => 'один', 1 => 'три')
> ?>
> ```

Керуюча конструкція [foreach](control-structures.foreach.html) Існує спеціально для масивів. Вона надає можливість легко пройтися масивом.

### Що можна і не можна робити з масивами

#### Чому `$foo[bar]` неправильно?

Завжди укладайте у лапки рядковий літерал в індексі асоціативного масиву. Наприклад, пишіть `$foo['bar']`, а не `$foo[bar]`. Але чому? Часто у старих скриптах можна зустріти наступний синтаксис:

```php
<?php
$foo[bar] = 'враг';
echo $foo[bar];
// и т.д.
?>
```

Це не так, хоч і працює. Причина в тому, що цей код містить невизначену константу (`bar`), а не рядок (`'bar'` - зверніть увагу на лапки). Це працює, тому що PHP автоматично перетворює *"голий рядок"* (не укладений у лапки рядок, який не відповідає жодному з відомих символів мови) у рядок зі значенням цього "голого рядка". Наприклад, якщо константа з ім'ям **`bar`** не визначено, то PHP замінить bar на рядок `'bar'` та використовує її.

**Увага**

Резервний варіант для обробки невизначеної константи як порожнього рядка викликає помилку рівня **`E_NOTICE`**. Починаючи з PHP 7.2.0, поведінка оголошена застарілою і викликає помилку рівня. **`E_WARNING`**. Починаючи з PHP 8.0.0, видалено та викидає виняток [Error](class.error.md)

> **Зауваження**: Це не означає, що потрібно *завжди* укладати ключ у лапки. Немає необхідності укладати в лапки [константи](language.constants.md) або [змінні](language.variables.md)оскільки це завадить PHP обробляти їх.
> 
> ```php
> <?php
> error_reporting(E_ALL);
> ini_set('display_errors', true);
> ini_set('html_errors', false);
> // Простой Масив:
> $array = array(1, 2);
> $count = count($array);
> for ($i = 0; $i < $count; $i++) {
>     echo "\nПроверяем $i: \n";
>     echo "Плохо: " . $array['$i'] . "\n";
>     echo "Хорошо: " . $array[$i] . "\n";
>     echo "Плохо: {$array['$i']}\n";
>     echo "Хорошо: {$array[$i]}\n";
> }
> ?>
> ```
> 
> Результат виконання цього прикладу:
> 
> ```
> Проверяем 0:
> Notice: Undefined index:  $i in /path/to/script.html on line 9
> Плохо:
> Хорошо: 1
> Notice: Undefined index:  $i in /path/to/script.html on line 11
> Плохо:
> Хорошо: 1
> 
> Проверяем 1:
> Notice: Undefined index:  $i in /path/to/script.html on line 9
> Плохо:
> Хорошо: 2
> Notice: Undefined index:  $i in /path/to/script.html on line 11
> Плохо:
> Хорошо: 2
> ```

Додаткові приклади, які демонструють цей факт:

```php
<?php
// Показываем все ошибки
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Верно
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Неверно. Это работает, но из-за неопределённой константы с
// именем fruit также вызывает ошибку PHP уровня E_NOTICE
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Давайте определим константу, чтобы продемонстрировать, что
// происходит. Мы присвоим константе с именем fruit значение 'veggie'.
define('fruit', 'veggie');

// Теперь обратите внимание на разницу
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Внутри строки это нормально. Внутри строк константы не
// рассматриваются, так что ошибки E_NOTICE здесь не произойдёт
print "Hello $arr[fruit]";      // Hello apple

// С одним исключением: фигурные скобки вокруг Масивов внутри
// строк позволяют константам там находиться
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Это не будет работать и вызовет ошибку обработки, такую как:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Это, конечно, также действует и с суперглобальными переменными в строках
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Ещё одна возможность - конкатенация
print "Hello " . $arr['fruit']; // Hello apple
?>
```

Якщо ви переведете [errorreporting](errorfunc.configuration.html#ini.error-reporting) режим відображення помилок рівня **`E_NOTICE`** (наприклад, такий як **`E_ALL`**), Ви відразу побачите ці помилки. За замовчуванням [errorreporting](errorfunc.configuration.html#ini.error-reporting) встановлена ​​їх не відображати.

Як зазначено у розділі [синтаксис](language.types.array.html#language.types.array.syntax), усередині квадратних дужок ('`[`'і'`]`') має бути вираз. Це означає, що можна писати так:

```php
<?php
echo $arr[somefunc($bar)];
?>
```

Це приклад використання значення, що повертається функцією, як індекс масиву. PHP відомі також і константи:

```php
<?php
$error_descriptions[E_ERROR]   = "Произошла фатальная ошибка";
$error_descriptions[E_WARNING] = "PHP сообщает о предупреждении";
$error_descriptions[E_NOTICE]  = "Это лишь неофициальное замечание";
?>
```

Зверніть увагу, що **`E_ERROR`** - це такий самий вірний ідентифікатор, як і `bar` у першому прикладі. Але останній приклад по суті еквівалентний такому запису:

```php
<?php
$error_descriptions[1] = "Произошла фатальная ошибка";
$error_descriptions[2] = "PHP сообщает о предупреждении";
$error_descriptions[8] = "Это лишь неофициальное замечание";
?>
```

оскільки **`E_ERROR`** відповідає `1` і т.д.

##### То що ж у цьому поганого?

Колись у майбутньому команда розробників PHP можливо захоче додати ще одну константу або ключове слово, або константа з іншого коду може втрутитися і тоді у вас можуть виникнути проблеми. Наприклад, ви вже не можете використовувати таким чином слова `empty` і `default`оскільки вони є [зарезервованими ключовими словами](reserved.md)

> **Зауваження**: Повторимо, всередині рядка (string), укладеного в подвійні лапки, коректно не оточувати індекси масиву лапками, тому `"$foo[bar]"` є вірним записом. Більш докладно чому - дивіться наведені вище приклади, а також розділ по [обробці змінних у рядках](language.types.string.html#language.types.string.parsing)

### Перетворення на масив

Для будь-якого з типів int, float, string, bool і resource, перетворення значення масив дає результатом масив з одним елементом (з індексом 0), що є скалярним значенням, з якого ви почали. Іншими словами, `(array)$scalarValue` - це точно те саме, що і `array($scalarValue)`

Якщо ви перетворюєте на масив об'єкт (object), ви отримаєте як елементи масиву властивості (змінні-члени) цього об'єкта. Ключами будуть імена змінних-членів, з деякими примітними винятками: цілі численні властивості стануть недоступними; до закритих полів класу (private) попереду буде дописано ім'я класу; до захищених полів класу (protected) попереду буде додано символ ''. Ці додані значення з обох сторін також мають `NUL` байти. Неініціалізовані [типізовані властивості](language.oop5.properties.html#language.oop5.properties.typed-properties) автоматично відкидаються.

```php
<?php
class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}
var_export((array) new A());
?>
```

Результат виконання цього прикладу:

```
array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
```

Це може викликати дещо несподівану поведінку:

```php
<?php
class A {
    private $A; // Это станет '\0A\0A'
}
class B extends A {
    private $A; // Это станет '\0B\0A'
    public $AA; // Это станет 'AA'
}
var_dump((array) new B());
?>
```

Результат виконання цього прикладу:

```
array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
```

Наведений вище код покаже 2 ключі з ім'ям 'AA', хоча один з них насправді має ім'я '0А0A'.

Якщо ви перетворюєте на масив значення **`null`**, Ви отримаєте порожній масив.

### Порівняння

Масиви можна порівнювати за допомогою функції [arraydiff()](function.array-diff.html) і [операторів масивів](language.operators.array.md)

### Розпакування масиву

Масив із префіксом `...` буде розпакований під час визначення масиву. Тільки масиви та об'єкти, які реалізують інтерфейс [Traversable](class.traversable.md), можуть бути розпаковані. Розпакування масиву за допомогою `...` доступна починаючи з PHP 7.4.0.

Масив можна розпаковувати кілька разів і додавати звичайні елементи до або після оператора `...`

**Приклад #9 Просте розпакування масиву**

```php
<?php
// Использование короткого синтаксиса Масива.
// Также работает с синтаксисом array().
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; // [1, 2, 3]
$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]
function getArr() {
  return ['a', 'b'];
}
$arr6 = [...getArr(), 'c' => 'd']; // ['a', 'b', 'c' => 'd']
?>
```

Розпакування масиву за допомогою оператора `...` слідує семантиці функції [arraymerge()](function.array-merge.html). Тобто пізніші рядкові ключі перезаписують раніші, а цілочисленні ключі перенумеровуються:

**Приклад #10 Розпакування масиву з дублюючим ключем**

```php
<?php
// строковый ключ
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]
// целочисленный ключ
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Который [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// где исходные целочисленные ключи не были сохранены.
?>
```

> **Зауваження**
> 
> Ключі, які не є ні цілими числами, ні рядками, викликають помилку [TypeError](class.typeerror.md). Такі ключі можуть бути згенеровані лише об'єктом [Traversable](class.traversable.md)

> **Зауваження**
> 
> До PHP 8.1 розпакування масиву з рядковим ключем не підтримувалося:
> 
> ```php
> <?php
> $arr1 = [1, 2, 3];
> $arr2 = ['a' => 4];
> $arr3 = [...$arr1, ...$arr2];
> // Ошибка: невозможно распаковать Масив со строковыми ключами в example.php:5
> $arr4 = [1, 2, 3];
> $arr5 = [4, 5];
> $arr6 = [...$arr4, ...$arr5]; // работает. [1, 2, 3, 4, 5]
> ?>
> ```

### Приклади

Тип масиву в PHP є дуже гнучким, ось кілька прикладів:

```php
<?php
// это
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
            4        // ключом будет 0
          );

$b = array('a', 'b', 'c');

// . . .полностью соответствует
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // ключом будет 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// после выполнения этого кода, $a будет Масивом
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',
// 'name' => 'apple', 0 => 4), а $b будет
// array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').
?>
```

**Приклад #11 Використання array()**

```php
<?php
// Масив как карта (свойств)
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// исключительно числовые ключи
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// это то же самое, что и array(0 => 7, 1 => 8, ...)

$switching = array(         10, // ключ = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // ключ = 6 (максимальным числовым индексом было 5)
                    '8'  =>  2, // ключ = 8 (число!)
                    '02' => 77, // ключ = '02'
                    0    => 12  // значение 10 будет перезаписано на 12
                  );

// пустой Масив
$empty = array();
?>
```

**Приклад #12 Колекція**

```php
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Вам нравится $color?\n";
}

?>
```

Результат виконання цього прикладу:

```
Вам нравится red?
Вам нравится blue?
Вам нравится green?
Вам нравится yellow?
```

Зміна значень масиву безпосередньо можлива шляхом передачі за посиланням.

**Приклад #13 Зміна елемента в циклі**

```php
<?php
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* это нужно для того, чтобы последующие записи в
$color не меняли последний элемент Масива */

print_r($colors);
?>
```

Результат виконання цього прикладу:

```
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
```

Наступний приклад створює масив, що починається з одиниці.

**Приклад #14 Індекс, що починається з одиниці**

```php
<?php
$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');
print_r($firstquarter);
?>
```

Результат виконання цього прикладу:

```
Array
(
    [1] => 'Январь'
    [2] => 'Февраль'
    [3] => 'Март'
)
```

**Приклад #15 Заповнення масиву**

```php
<?php
// заполняем Масив всеми элементами из директории
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
```

Масиви впорядковані. Ви можете змінювати порядок елементів за допомогою різних функцій сортування. Для додаткової інформації дивіться розділ [функції для роботи з масивами](ref.array.md). Ви можете підрахувати кількість елементів у масиві за допомогою функції [count()](function.count.md)

**Приклад #16 Сортування масиву**

```php
<?php
sort($files);
print_r($files);
?>
```

Оскільки значення масиву може бути будь-чим, їм також може бути інший масив. Таким чином ви можете створювати рекурсивні та багатовимірні масиви.

**Приклад #17 Рекурсивні та багатовимірні масиви**

```php
<?php
$fruits = array ( "fruits"  => array ( "a" => "апельсин",
                                       "b" => "банан",
                                       "c" => "яблоко"
                                     ),
                  "numbers"   => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "первая",
                                       5 => "вторая",
                                            "третья"
                                     )
                );

// Несколько примеров доступа к значениям предыдущего Масива
echo $fruits["holes"][5];    // напечатает "вторая"
echo $fruits["fruits"]["a"]; // напечатает "апельсин"
unset($fruits["holes"][0]);  // удалит "первая"

// Создаст новый многомерный Масив
$juices["apple"]["green"] = "good";
?>
```

Зауважте, що при присвоєнні масиву завжди відбувається копіювання значення. Щоб скопіювати масив за посиланням, потрібно використовувати [оператор посилання](language.operators.md)

```php
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 изменился,
             // $arr1 всё ещё array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // теперь $arr1 и $arr3 одинаковы
?>
```
