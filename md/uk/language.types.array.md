---
navigation:
  - language.types.numeric-strings.md: Числові рядки
  - language.types.object.md: Об'єкти »
  - index.md: PHP Manual
  - language.types.md: Типи
title: Масиви
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Масиви

Масив у PHP – це впорядкована структура даних, яка пов'язує *значения* и*ключі*. Цей тип даних оптимізований для різних цілей, тому з ним працюють як з масивом, списком (вектором), хеш-таблицею (реалізацією карти), словником, колекцією, стеком, чергою і, можливо, ще чимось. Оскільки значення масиву бувають інші масиви, також доступні дерева і багатовимірні масиви.

Пояснення цих структур даних виходить за рамки цього посібника, але щонайменше один приклад буде наведено для кожної з них. За додатковою інформацією звертаються до великого обсягу літератури на цю велику тему.

### Синтаксис

#### Определение при помощи[array()](function.array.md)

Масив (array) створюють мовною конструкцією [array()](function.array.md). Як аргументи вона приймає будь-яку кількість розділених комами пар `ключ => значення`

```synopsis
array(
    key  => value,
    key2 => value2,
    key3 => value3,
    ...
)
```

Кома після останнього елемента масиву необов'язкова і її можна опустити. Зазвичай це робиться для однорядкових масивів, краще віддати перевагу `array(1, 2)` замість `array(1, 2, )`. Для багаторядкових масивів, навпаки, зазвичай вказують кому, що висить, так як спрощує додавання нових елементів в кінець масиву.

> **Зауваження** :
> 
> Існує короткий синтаксис масиву, який замінює мовну конструкцію `array()` вираз `[]`

**Приклад #1 Простий масив**

```php
<?php

$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Работа с коротким синтаксисом массива
$array = [
    "foo" => "bar",
    "bar" => "foo",
];

?>
```

Ключ масиву (key) можна вказувати або як ціле значення (int), або як рядок (string). Значення масиву (value) може належати будь-якому типу даних.

Додатково відбудуться такі перетворення ключа key:

-   Рядки (string), що містять ціле число (int) (за винятком випадків, коли перед числом вказують знак`+` ), будуть перетворені на ціле число (int). Наприклад, ключ зі значенням`«8»`збережеться зі значенням`8`. При цьому значення`«08»`не перетворюється, оскільки воно - не коректне десяткове ціле.
-   Числа з плаваючою точкою (float) також перетворюються на цілі значення (int) - дробова частина буде відкинута. Наприклад, ключ зі значенням`8.7`буде збережеться зі значенням`8`
-   Логічний тип (bool) також перетворюється на цілий тип (int). Наприклад, ключ зі значенням\*\*`true`**збережеться зі значенням , а ключ зі значенням**`false`\*\*збережеться зі значенням
-   Тип null перетворюється на порожній рядок. Наприклад, ключ зі значенням`null`збережеться зі значенням`""`
-   Масиви (array) та об'єкти (object)*не можна*вказувати як ключі. Це згенерує попередження:`Неприпустимий тип зміщення (Illegal offset type)`

Якщо декількома елементами в оголошенні масиву вказано однаковий ключ, лише останній буде збережено, а інші будуть перезаписані.

**Приклад #2 Приклад перетворення типів та перезапису елементів**

```php
<?php

$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);

?>
```

Результат виконання наведеного прикладу:

```
array(1) {
  [1]=>
  string(1) "d"
}
```

Оскільки всі ключі в наведеному прикладі перетворюються на , значення буде перезаписано на кожен новий елемент і залишиться тільки останнє значення `«d»`

PHP дозволяє масивам містити одночасно цілі (int) і рядкові (string) ключі, оскільки PHP однаково сприймає індексні та асоціативні масиви.

**Приклад #3 Змішані цілочислові (int) та рядкові (string) ключі**

```php
<?php

$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);

?>
```

Результат виконання наведеного прикладу:

```
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
```

Ключ (key) – необов'язковий. Якщо він не вказаний, PHP інкрементує попереднє найбільше ціле (int) значення ключа.

**Приклад #4 Індексні масиви без ключа**

```php
<?php

$array = array("foo", "bar", "hallo", "world");
var_dump($array);

?>
```

Результат виконання наведеного прикладу:

```
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hallo"
  [3]=>
  string(5) "world"
}
```

Дозволено вказувати ключ одним елементам та пропускати для інших:

**Приклад #5 Ключі для деяких елементів**

```php
<?php

$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);

?>
```

Результат виконання наведеного прикладу:

```
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
```

Видно, что последнее значение`«d»` надалося ключу `7`. Це сталося тому, що перед цим найбільшим значенням цілого ключа було `6`

**Приклад #6 Розширений приклад перетворення типів та перезапису елементів**

```php
<?php

$array = array(
    1    => 'a',
    '1'  => 'b', // значение «b» перезапишет значение «a»
    1.5  => 'c', // значение «c» перезапишет значение «b»
    -1 => 'd',
    '01'  => 'e', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1
    '1.5' => 'f', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1
    true => 'g', // значение «g» перезапишет значение «c»
    false => 'h',
    '' => 'i',
    null => 'j', // значение «j» перезапишет значение «i»
    'k', // значение «k» присваивается ключу 2. Потому что самый большой целочисленный ключ до этого был 1
    2 => 'l', // значение «l» перезапишет значение «k»
);

var_dump($array);

?>
```

Результат виконання наведеного прикладу:

```
array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
```

Цей приклад включає всі варіації перетворення ключів та перезапису елементів

#### Доступ до елементів масиву через синтаксис квадратних дужок

Доступ до елементів масиву можна отримувати, використовуючи синтакс. `array[key]`

**Приклад #7 Доступ до елементів масиву**

```php
<?php

$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);

?>
```

Результат виконання наведеного прикладу:

```
string(3) "bar"
int(24)
string(3) "foo"
```

> **Зауваження** :
> 
> До PHP 8.0.0 квадратні та фігурні дужки могли взаємозамінюватися при доступі до елементів масиву (наприклад, у наведеному прикладі `$array[42]`и`$array{42}` робили те саме). Синтаксис фігурних дужок застарів із PHP 7.4.0 і більше не підтримується з PHP 8.0.0.

**Приклад #8 Розіменування масиву**

```php
<?php

function getArray() {
    return array(1, 2, 3);
}

$secondElement = getArray()[1];

?>
```

> **Зауваження** :
> 
> Спроба доступу до невизначеного ключа в масиві — це те саме, що й спроба доступу до будь-якої іншої невизначеної змінної: буде видано помилку рівня **`E_WARNING`**(ошибка уровня\*\*`E_NOTICE`\*\* до PHP 8.0.0), і результат дорівнюватиме **`null`**

> **Зауваження** :
> 
> Спроба розіменувати не масив, а скалярне значення, яке відрізняється від рядка (string), віддасть **`null`**, Тоді як розйменування рядка (string) трактує її як індексний масив. При такій спробі до PHP 7.4.0 не видавалося повідомлення про помилку. З PHP 7.4.0 видається помилка рівня **`E_NOTICE`**; з PHP 8.0.0 видається помилка рівня **`E_WARNING`**

#### Створення та модифікація із застосуванням синтаксису квадратних дужок

Розробник може змінювати існуючий масив явною установкою значень.

Це робиться шляхом присвоєння значень масиву (array) із зазначенням ключа у квадратних дужках. Крім того, якщо опустити ключ, вийде порожня пара дужок (`[]`

```synopsis
$arr[key] = value;
    $arr[] = value;
    // Ключ key может принадлежать типу int или string
    // Значение value может быть любым значением любого типа
```

Якщо масив $arr ще не існує або для нього встановлено значення \*\*`null`** або **`false`\*\*він буде створений. Таким чином, це ще один спосіб визначити масив array. Однак такий спосіб застосовувати не рекомендовано, оскільки якщо змінна $arr вже містить значення (наприклад, рядок (string) із змінної запиту), то це значення залишиться на місці та вираз `[]` може означати [доступ до символу в рядку](language.types.string.md#language.types.string.substr). Краще ініціалізувати змінну явним наданням значення.

> **Зауваження**: Починаючи з PHP 7.1.0 оператор порожнього індексу на рядку викине фатальну помилку Раніше рядок мовчки перетворювався на масив.

> **Зауваження**: З PHP 8.1.0 спосіб, яким створювали новий масив приведенням до нього значення **`false`**, застарілий. Спосіб, яким створюють новий масив приведенням до нього значення **`null`** і невизначеного значення, як і раніше, доступний.

Для зміни конкретного значення елементу просто надають нове значення, вказуючи його ключ. Якщо потрібно видалити пару ключ/значення, необхідно викликати конструкцію [unset()](function.unset.md)

```php
<?php

$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // В этом месте скрипта это
                // то же самое, что и $arr[13] = 56;

$arr["x"] = 42; // Это добавляет в массив новый
                // элемент с ключом «x»

unset($arr[5]); // Это удаляет элемент из массива

unset($arr);    // Это удаляет весь массив

?>
```

> **Зауваження** :
> 
> Як було сказано раніше, якщо розробник не вказав ключ, то буде взято максимальний з існуючих цілих (int) індексів, і новим ключем буде це максимальне значення (в крайньому випадку 0) плюс 1. Якщо цілих (int) індексів ще немає, то ключем буде (нуль).
> 
> Враховують, що максимальне ціле значення ключа *не обов'язково існує в масиві в даний момент*. Воно могло існувати в масиві якийсь час з останньої переіндексації. Наступний приклад це ілюструє:
> 
> ```php
> <?php
> 
> // Створюємо простий масив.
> $array = array(1, 2, 3, 4, 5);
> print_r($array);
> 
> // Тепер видаляємо кожен елемент, але масив залишаємо недоторканим:
> foreach ($array as $i => $value) {
>     unset($array[$i]);
> }
> print_r($array);
> 
> // Додаємо елемент (зверніть увагу, що новим ключем буде 5, а чи не 0).
> $array[] = 6;
> print_r($array);
> 
> // Переіндексація:
> $array = array_values($array);
> $array[] = 7;
> print_r($array);
> 
> ?>
> ```
> 
> Результат виконання наведеного прикладу:
> 
> ```
> Array
> (
>     [0] => 1
>     [1] => 2
>     [2] => 3
>     [3] => 4
>     [4] => 5
> )
> Array
> (
> )
> Array
> (
>     [5] => 6
> )
> Array
> (
>     [0] => 6
>     [1] => 7
> )
> ```

#### Деструктуризація масиву

Масиви можна деструктурувати мовними конструкціями `[]` (починаючи з PHP 7.1.0) або [list()](function.list.md). Ці мовні конструкції можна використовувати для деструктуризації масиву на окремі змінні.

```php
<?php

$source_array = ['foo', 'bar', 'baz'];
[$foo, $bar, $baz] = $source_array;
echo $foo;    // выведет «foo»
echo $bar;    // выведет «bar»
echo $baz;    // выведет «baz»

?>
```

Деструктуризацію масиву також виконують у конструкції [foreach](control-structures.foreach.md) для деструктуризації багатовимірного масиву під час ітерації масивом.

```php
<?php

$source_array = [
    [1, 'John'],
    [2, 'Jane'],
];
foreach ($source_array as [$id, $name]) {
    // логика работы с $id и $name
}

?>
```

Елементи масиву будуть проігноровані, якщо змінна не вказана. Деструктуризація масиву починається з індексу

```php
<?php

$source_array = ['foo', 'bar', 'baz'];

// Присваивание элемента с индексом 2 переменной $baz
[, , $baz] = $source_array;

echo $baz;    // выведет "baz"

?>
```

З PHP 7.1.0 асоціативні масиви також можна деструктурувати. Це спрощує вибір потрібного елемента в масивах з числовим індексом, оскільки індекс може бути явно.

```php
<?php

$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Присваивание элемента с индексом «baz» переменной $three
['baz' => $three] = $source_array;

echo $three;    // выведет 3

$source_array = ['foo', 'bar', 'baz'];

// Присваивание элемента с индексом 2 переменной $baz
[2 => $baz] = $source_array;

echo $baz;    // выведет «baz»

?>
```

Деструктуризацією масив користуються, щоб поміняти дві змінні місця.

```php
<?php

$a = 1;
$b = 2;
[$b, $a] = [$a, $b];
echo $a;    // выведет 2
echo $b;    // выведет 1

?>
```

> **Зауваження** :
> 
> Оператор`...` не підтримується у привласненнях.

> **Зауваження** :
> 
> Спроба отримати доступ до невизначеного ключа масиву аналогічна до будь-якої іншої невизначеної змінної: буде видано повідомлення про помилку рівня **`E_WARNING`** (помилки рівня **`E_NOTICE`**до PHP 8.0.0), а результатом будет значение**`null`**

### Корисні функції

Для роботи з масивами є чимало корисних функцій. Докладніше про це розказано у розділі « [Функції для роботи з масивами](ref.array.md) ».

> **Зауваження** :
> 
> Мовна конструкція [unset()](function.unset.md) вміє видаляти ключі масиву. Зверніть увагу, що масив *НЕ* буде переіндексовано. Якщо потрібно поведінку в стилі «видалити та зрушити», можна переіндексувати масив функцією [array\_values()](function.array-values.md)
> 
> ```php
> <?php
> 
> $a = array(1 => 'один', 2 => 'два', 3 => 'три');
> unset($a[2]);
> /* дасть масив, поданий так:
>    $a = array(1 => 'один', 3 => 'три');
>    а НЕ так:
>    $a = array(1 => 'один', 2 => 'три');
> */
> 
> $ b = array_values ​​($ a);
> // Тепер $b це array(0 => 'один', 1 => 'три')
> ?>
> ```

Управляющая конструкция[foreach](control-structures.foreach.md) Існує спеціально для масивів. Вона пропонує простий спосіб перебору масиву.

### Що можна і не можна робити з масивами

#### Чому вираз `$foo[bar]` неправильно?

Рекомендовано укладати в лапки рядковий літерал в індексі асоціативного масиву. Наприклад, потрібно писати `$foo['bar']`, а не`$foo[bar]`. Але чому? Часто у старих скриптах можна зустріти наступний синтаксис:

```php
<?php

$foo[bar] = 'враг';
echo $foo[bar];
// и т. д.

?>
```

Це не так, хоч і працює. Причина в тому, що цей код містить невизначену константу (`bar`), а не рядок (`'bar'` - Зверніть увагу на лапки). Це працює, тому що PHP автоматично перетворює *«голий рядок»* (не укладений у лапки рядок, який не відповідає жодному з відомих символів мови) у рядок зі значенням цього «голого рядка». Наприклад, якщо константа з ім'ям \*\*`bar`\*\*не определена, то PHP заменит bar на строку`«bar»` і працюватиме з нею.

**Увага**

Резервний варіант для обробки невизначеної константи як порожнього рядка видає помилку рівня **`E_NOTICE`**. Починаючи з PHP 7.2.0, поведінка оголошена застарілою і видає помилку рівня. **`E_WARNING`**. Починаючи з PHP 8.0.0 видалено та викидає виняток [Error](class.error.md)

> **Зауваження**: Це не означає, що потрібно *завжди* укладати ключ у лапки. Не обов'язково укладати в лапки [константи](language.constants.md) або [змінні](language.variables.md)оскільки це завадить PHP обробляти їх.
> 
> ```php
> <?php
> 
> error_reporting(E_ALL);
> ini_set('display_errors', true);
> ini_set('html_errors', false);
> 
> // Простий масив:
> $array = array(1, 2);
> $ count = count ($ array);
> 
> for ($i = 0; $i < $count; $i++) {
>     echo "\nПеревіряємо $i: \n";
>     echo "Погано:". $array['$i'] . "\n";
>     echo "Добре: ". $array[$i] . "\n";
>     echo "Погано: {$array['$i']}\n";
>     echo "Добре: {$array[$i]}\n";
> }
> 
> ?>
> ```
> 
> Результат виконання наведеного прикладу:
> 
> ```
> Перевіряємо 0:
> Notice: Undefined index: $i in /path/to/script.md on line 9
> Погано:
> Добре: 1
> Notice: Undefined index: $i in /path/to/script.md on line 11
> Погано:
> Добре: 1
> 
> Перевіряємо 1:
> Notice: Undefined index: $i in /path/to/script.md on line 9
> Погано:
> Добре: 2
> Notice: Undefined index: $i in /path/to/script.md on line 11
> Погано:
> Добре: 2
> ```

Додаткові приклади, що підтверджують цей факт:

```php
<?php

// Показываем все ошибки
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Верно
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Неверно. Это работает, но из-за неопределённой константы с
// именем fruit также выдаёт ошибку PHP уровня E_NOTICE
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Давайте определим константу, чтобы продемонстрировать, что
// происходит. Присвоим константе с именем fruit значение «veggie».
define('fruit', 'veggie');

// Теперь обратите внимание на разницу
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Внутри строки это нормально. Внутри строк константы не
// рассматриваются, так что ошибки E_NOTICE здесь не произойдёт
print "Hello $arr[fruit]";      // Hello apple

// С одним исключением: фигурные скобки вокруг массивов внутри
// строк позволяют константам там находиться
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Это не будет работать и вызовет ошибку обработки:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Это, конечно, также действует и с суперглобальными переменными в строках
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Ещё одна возможность — конкатенация
print "Hello " . $arr['fruit']; // Hello apple

?>
```

Якщо директива [error\_reporting](errorfunc.configuration.md#ini.error-reporting)настроена на режим отображения ошибок уровня\*\*`E_NOTICE`**(наПриклад,**`E_ALL`\*\*), помилки відразу будуть видні. За замовчуванням директива [error\_reporting](errorfunc.configuration.md#ini.error-reporting) налаштована те що, щоб не показувати попередження.

Як зазначено у розділі [про синтаксис](language.types.array.md#language.types.array.syntax), усередині квадратних дужок («`[`» та «`]`») має бути вираз. Тобто такий код працює:

```php
<?php

echo $arr[somefunc($bar)];

?>
```

Це приклад роботи з функцією, що повертається значенням як індекс масиву. PHP також знає про константів:

```php
<?php

$error_descriptions[E_ERROR]   = "Произошла фатальная ошибка";
$error_descriptions[E_WARNING] = "PHP сообщает о предупреждении";
$error_descriptions[E_NOTICE]  = "Это лишь неофициальное замечание";

?>
```

Обратите внимание, что\*\*`E_ERROR`\*\* — це такий самий допустимий ідентифікатор, як і `bar` у першому прикладі. Але останній приклад по суті еквівалентний такому запису:

```php
<?php

$error_descriptions[1] = "Произошла фатальная ошибка";
$error_descriptions[2] = "PHP выдал предупреждение";
$error_descriptions[8] = "Это просто уведомление";

?>
```

оскільки значення константи **`E_ERROR`** відповідає значенню и т. д.

##### То що ж у цьому поганого?

Колись у майбутньому команда розробників PHP, можливо, захоче додати ще одну константу або ключове слово, або константа з іншого коду може втрутитися. Наприклад, неправильно використовувати слова `empty`и`default`, оскільки вони відносяться до [зарезервованим ключовим словам](reserved.md)

> **Зауваження**: Повторимо, усередині рядка (string) у подвійних лапках допустимо не оточувати індекси масиву лапками, тому `«$foo[bar]»` - Припустима запис. У прикладах вище пояснено, чому додаткова інформація дана в розділі [про обробку змінних у рядках](language.types.string.md#language.types.string.parsing)

### Перетворення на масив

Перетворення цілого числа (int), числа з плаваючою точкою (float), рядки (string), логічного значення (bool) або ресурсу (resource) у масив — створює масив з одним елементом з індексом 0 та значенням скаляра, який було перетворено. Говорячи інакше, вираз `(array) $scalarValue` аналогічно виразу `array($scalarValue)`

Якщо об'єкт (object) буде перетворено на масив, елементами масиву будуть властивості (змінні-члени) цього об'єкта. Ключами будуть імена змінних-членів, з наступними примітними винятками: цілі численні властивості стануть недоступні; до закритих полів класу (private) на початок буде дописано ім'я класу; до захищених полів класу (protected) на початок буде додано символ '\*'. Ці додані з обох сторін значення також отримають `NUL`\-байти. Неініціалізовані [типізовані властивості](language.oop5.properties.md#language.oop5.properties.typed-properties) автоматично відкидаються.

```php
<?php

class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}
var_export((array) new A());

?>
```

Результат виконання наведеного прикладу:

```
array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
```

Це може викликати дещо несподівану поведінку:

```php
<?php

class A {
    private $A; // Это станет '\0A\0A'
}
class B extends A {
    private $A; // Это станет '\0B\0A'
    public $AA; // Это станет 'AA'
}
var_dump((array) new B());

?>
```

Результат виконання наведеного прикладу:

```
array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
```

Наведений код покаже 2 ключі з ім'ям «AA», хоча один із них насправді має ім'я «\\0A\\0A».

Якщо перетворити на масив значення **`null`**, вийде порожній масив

### Порівняння

Масиви порівнюють функцією [array\_diff()](function.array-diff.md) і [операторами масивів](language.operators.array.md)

### Розпакування масиву

Масив, перед яким вказано оператора `...`, буде розпакований під час визначення масиву Тільки масиви та об'єкти, які реалізують інтерфейс [Traversable](class.traversable.md), можна розпаковувати. Розпакування масиву оператором `...` доступна починаючи з PHP 7.4.0.

Масив можна розпаковувати кілька разів і додавати звичайні елементи до або після оператора. `...` :

**Приклад #9 Просте розпакування масиву**

```php
<?php

// Применение короткого синтаксиса массива.
// Работает также с синтаксисом array().
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; // [1, 2, 3]
$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]

function getArr() {
  return ['a', 'b'];
}

$arr6 = [...getArr(), 'c' => 'd']; // ['a', 'b', 'c' => 'd']

?>
```

Распаковка массива оператором`...` дотримується семантики функції [array\_merge()](function.array-merge.md). Тобто пізніші рядкові ключі перезаписують раніші, а цілочисленні ключі перенумеровуються:

**Приклад #10 Розпакування масиву з дублюючим ключем**

```php
<?php

// строковый ключ
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]

// целочисленный ключ
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Который [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// где исходные целочисленные ключи не были сохранены.

?>
```

> **Зауваження** :
> 
> Ключі, тип яких не належить ні цілими числами, ні рядками, викидають виняток [TypeError](class.typeerror.md). Такі ключі генеруються лише об'єктом [Traversable](class.traversable.md)

> **Зауваження** :
> 
> До PHP 8.1 розпакування масиву з рядковим ключем не підтримувалося:
> 
> ```php
> <?php
> 
> $arr1 = [1, 2, 3];
> $arr2 = ['a' => 4];
> $arr3 = [...$arr1, ...$arr2];
> // Error error: Uncaught Error: Cannot unpack array with string keys in example.php:5
> $arr4 = [1, 2, 3];
> $ arr5 = [4, 5];
> $arr6 = [...$arr4, ...$arr5]; // працює. [1, 2, 3, 4, 5]
> 
> ?>
> ```

### Приклади

Масив у PHP - гнучкий тип даних. Ось кілька прикладів:

```php
<?php

// Этот код:
$a = array( 'color' => 'красный',
            'taste' => 'сладкий',
            'shape' => 'круг',
            'name'  => 'яблоко',
            4        // ключом будет 0
          );

$b = array('a', 'b', 'c');

// ...эквивалентен этому:
$a = array();
$a['color'] = 'красный';
$a['taste'] = 'сладкий';
$a['shape'] = 'круг';
$a['name']  = 'яблоко';
$a[]        = 4;        // ключом будет 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// после выполнения приведённого кода, переменная $a будет массивом
// array('color' => 'красный', 'taste' => 'сладкий', 'shape' => 'круг',
// 'name' => 'яблоко', 0 => 4), а переменная $b будет
// array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').

?>
```

**Приклад #11 Виклик мовної конструкції array()**

```php
<?php

// Массив как карта (свойств)
$map = array(
    'version'    => 4,
    'OS'         => 'Linux',
    'lang'       => 'english',
    'short_tags' => true
);

// строго числовые ключи
$array = array(
    7,
    8,
    0,
    156,
    -10
);
// это то же самое, что и array(0 => 7, 1 => 8, ...)

$switching = array(
    10,         // ключ = 0
    5    =>  6,
    3    =>  7,
    'a'  =>  4,
    11,         // ключ = 6 (максимальным числовым индексом было 5)
    '8'  =>  2, // ключ = 8 (число!)
    '02' => 77, // ключ = '02'
    0    => 12  // значение 10 будет перезаписано на 12
);

// пустой массив
$empty = array();

?>
```

**Приклад #12 Колекція**

```php
<?php

$colors = array('красный', 'голубой', 'зелёный', 'жёлтый');

foreach ($colors as $color) {
    echo "Вам нравится $color?\n";
}

?>
```

Результат виконання наведеного прикладу:

```
Вам нравится красный?
Вам нравится голубой?
Вам нравится зелёный?
Вам нравится жёлтый?
```

Безпосередня зміна значень масиву допустима через передачу значень посилання.

**Приклад #13 Зміна елемента в циклі**

```php
<?php

foreach ($colors as &$color) {
    $color = mb_strtoupper($color);
}
unset($color); /* это нужно, чтобы очередные записи в
                  переменной $color не меняли последний элемент массива */

print_r($colors);

?>
```

Результат виконання наведеного прикладу:

```
Array
(
    [0] => КРАСНЫЙ
    [1] => ГОЛУБОЙ
    [2] => ЗЕЛЁНЫЙ
    [3] => ЖЁЛТЫЙ
)
```

Наступний приклад створює масив, індексація якого починається з одиниці.

**Приклад #14 Індекс, що починається з одиниці**

```php
<?php

$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');
print_r($firstquarter);

?>
```

Результат виконання наведеного прикладу:

```
Array
(
    [1] => 'Январь'
    [2] => 'Февраль'
    [3] => 'Март'
)
```

**Приклад #15 Заповнення масиву**

```php
<?php

// заполняем массив всеми элементами из директории
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);

?>
```

Масиви впорядковані. Порядок змінюють різними функціями сортування. Докладніше про це розказано у розділі « [Функції для роботи з масивами](ref.array.md) ». Для підрахунку кількості елементів у масиві викликають функцію [count()](function.count.md)

**Приклад #16 Сортування масиву**

```php
<?php

sort($files);
print_r($files);

?>
```

Оскільки значення масиву дозволяється бути будь-яким, значення може бути також іншим масивом. Тому дозволено створювати рекурсивні та багатовимірні масиви.

**Приклад #17 Рекурсивні та багатовимірні масиви**

```php
<?php

$fruits = array ( "fruits"  => array ( "a" => "апельсин",
                                       "b" => "банан",
                                       "c" => "яблоко"
                                     ),
                  "numbers"   => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "первая",
                                       5 => "вторая",
                                            "третья"
                                     )
                );

// Несколько Прикладов доступа к значениям предыдущего массива
echo $fruits["holes"][5];    // напечатает «вторая»
echo $fruits["fruits"]["a"]; // напечатает «апельсин»
unset($fruits["holes"][0]);  // удалит «первая»

// Создаст новый многомерный массив
$juices["apple"]["green"] = "хороший";

?>
```

Надання масиву включає копіювання значення. Щоб скопіювати масив за посиланням, вказують [оператор присвоювання за посиланням](language.operators.md)

```php
<?php

$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // Массив $arr2 изменился,
             // Массив $arr1 всё ещё выглядит так: array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // Теперь массивы $arr1 и $arr3 одинаковы

?>
```
