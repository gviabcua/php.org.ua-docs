- [«Числові рядки](language.types.numeric-strings.md)
- [Ітеровані»](language.types.iterable.md)

- [PHP Manual](index.md)
- [Типи](language.types.md)
- Масиви

## Масиви

Насправді масив у PHP – це впорядковане відображення, яке
встановлює відповідність між *значенням* та *ключом*. Цей тип
оптимізований у кількох напрямках, тому ви можете використовувати
його як власне масив, список (вектор), хеш-таблицю (є
реалізацією карти), словник, колекцію, стек, черга і, можливо,
щось ще. Оскільки значенням масиву може бути інший масив PHP,
можна також створювати дерева та багатовимірні масиви.

Пояснення цих структур даних виходить за межі даного довідкового
керівництва, але ви знайдете як мінімум один приклад щодо кожної з них. За
додатковою інформацією ви можете звернутися до відповідної
літературі з цієї великої тематики.

### Синтаксис

#### Визначення за допомогою [array()](function.array.md)

Масив (тип array) може бути створений мовною конструкцією
[array()](function.array.md). Як параметри вона приймає
будь-яку кількість розділених комами пар `key => value` (ключ =\>
значення).

`` synopsis
array(
key => value,
key2 => value2,
key3 => value3,
...
)
````

Кома після останнього елемента масиву необов'язкова і може бути
опущена. Зазвичай це робиться для однорядкових масивів, тобто
`array(1, 2)` переважніше `array(1, 2, )`. Для багаторядкових
масивів з іншого боку зазвичай використовується завершальна кома, так
як дозволяє легше додавати нові елементи до кінця масиву.

> **Примітка**:
>
> Існує короткий синтаксис масиву, який замінює `array()` на
> `[]`.

**Приклад #1 Простий масив**

`<?php$array = array(    "foo" => "bar",   "bar" => "foo",);// Використання синтаксису короткого масива$array = [    " => "foo",];?> `

key може бути типу int, або типу string. value може бути будь-якого
типу.

Додатково із ключем key будуть зроблені такі перетворення:

- Рядки (string), що містять ціле число (int) (за винятком випадків,
коли число передує знаком `+`) будуть перетворені до типу int.
Наприклад, ключ зі значенням ``8'` буде насправді збережено
зі значенням `8`. З іншого боку, значення ``08`` не буде
перетворено, тому що воно не є коректним десятковим цілим.
- Числа з плаваючою точкою (float) також будуть перетворені на тип
int, тобто дрібна частина буде відкинута. Наприклад, ключ зі
значенням `8.7` буде насправді збережено зі значенням `8`.
- Тип bool також перетворюються на тип int. Наприклад, ключ зі
значенням `true` буде збережено зі значенням `1` і ключ зі значенням
`false` буде збережено зі значенням `0`.
- Тип null буде перетворено на порожній рядок. Наприклад, ключ зі
значенням `null` буде насправді збережено зі значенням
`````.
- Масиви (array) та об'єкти (object) *не можуть* використовуватися в
якість ключів. При такому використанні генеруватиметься
попередження: `Неприпустимий тип зсуву (Illegal offset type)`.

Якщо кілька елементів в оголошенні масиву використовують однаковий
ключ, то тільки останній буде використовуватись, а всі інші будуть
перезаписані.

**Приклад #2 Приклад перетворення типів та перезапису елементів**

`<?php$array = array(    1   == "a",   "1"  => "b",   1.5  => "c", ' > ;

Результат виконання цього прикладу:

array(1) {
[1]=>
string(1) "d"
}

Оскільки всі ключі у наведеному вище прикладі перетворюються на `1`,
значення буде перезаписано на кожен новий елемент і залишиться тільки
останнє надано значення ``d'`.

Масиви в PHP можуть містити ключі типів int і string одночасно, так
як PHP не робить відмінності між індексованими та асоціативними
масивами.

**Приклад #3 Змішані ключі типів int та string**

`<?php$array = array(    "foo" => "bar",   "bar" => "foo",    100   => -100,    -0;

Результат виконання цього прикладу:

array(4) {
["foo"]=>
string(3) "bar"
["bar"]=>
string(3) "foo"
[100] =>
int(-100)
[-100] =>
int(100)
}

Параметр key є необов'язковим. Якщо він не вказаний, PHP буде
використати попереднє найбільше значення ключа типу int, збільшене
на 1.

**Приклад #4 Індексовані масиви без ключа**

` <?php$array = array("foo", "bar", "hallo", "world");var_dump($array);?> `

Результат виконання цього прикладу:

array(4) {
[0]=>
string(3) "foo"
[1]=>
string(3) "bar"
[2]=>
string(5) "hallo"
[3]=>
string(5) "world"
}

Можливо вказати ключ тільки для деяких елементів та пропустити для
інших:

**Приклад #5 Ключі для деяких елементів**

`<?php$array = array(         "a",         "b",    6 => "c",         |

Результат виконання цього прикладу:

array(4) {
[0]=>
string(1) "a"
[1]=>
string(1) "b"
[6]=>
string(1) "c"
[7]=>
string(1) "d"
}

Як ви бачите останнє значення ``d'` було надано ключу `7`. Це
сталося тому, що найбільше значення ключа цілого типу перед
цим було `6`.

**Приклад #6 Розширений приклад перетворення типів та перезапису
елементів**

`<?php$array = array(    1    => 'a',   '1'  => 'b', // значення "b" перезапише|значення "a"    | значення "b"    -1 => 'd',   '01'  => 'e', // оскільки це не цілочисельна рядок, не не перезапише ключ' >  рядок, не НЕ перезапише ключ для 1    true => 'g', // значення "g" перезапише значення "c"    false => 'h', ' '  значення "j" перезапише значення "i"    'k', // значення "k" привласнюється ключу 2. Тому що найбільший цілочисленний значення к| | ");var_dump($array);?> `

Результат виконання цього прикладу:

array(7) {
[1]=>
string(1) "g"
[-1]=>
string(1) "d"
["01"]=>
string(1) "e"
["1.5"]=>
string(1) "f"
[0]=>
string(1) "h"
[""]=>
string(1) "j"
[2]=>
string(1) "l"
}

Цей приклад включає всі варіації перетворення ключів та перезапису
елементів

#### Доступ до елементів масиву за допомогою квадратних дужок

Доступ до елементів масиву може бути здійснений за допомогою синтаксису
`array[key]`.

**Приклад #7 Доступ до елементів масиву**

` <?php$array = array(    "foo" => "bar",    42    => 24,    "multi" => array(         "dimensional" => array(             "array" => "foo"         )    ));var_dump ($array["foo"]);var_dump($array[42]);var_dump($array["multi"]["dimensional"]["array"]);?> `

Результат виконання цього прикладу:

string(3) "bar"
int(24)
string(3) "foo"

> **Примітка**:
>
> До PHP 8.0.0 квадратні та фігурні дужки могли використовуватись
> взаємозамінні для доступу до елементів масиву (наприклад, у прикладі
> вище `$array[42]` і `$array{42}` робили те саме). Синтаксис
> фігурних дужок застарів у PHP 7.4.0 і більше не підтримується у PHP
>8.0.0.

**Приклад #8 Розіменування масиву**

`<?phpfunction getArray() {    return array(1, 2, 3);}$secondElement = getArray()[1];// або такlist(, $secondElement) = getArray();?>

> **Примітка**:
>
> Спроба доступу до невизначеного ключа в масиві - це те саме,
> що й спроба доступу до будь-якої іншої невизначеної змінної: буде
> згенеровано помилку рівня **`E_NOTICE`**, і результат буде
> **`null`**.

> **Примітка**:
>
> Масив, що розіменовує скалярне значення, яке не є
> рядком (string), віддасть **`null`**. До PHP 7.4.0 не видається
> повідомлення про помилку. Починаючи з PHP 7.4.0, видається помилка
> **`E_NOTICE`**; з PHP 8.0.0 видається помилка **`E_WARNING`**.

#### Створення/модифікація за допомогою синтаксису квадратних дужок

Існуючий масив може бути змінений шляхом явної установки значень в
ньому.

Це виконується присвоєнням значень масиву (array) із зазначенням у
дужках ключа. Крім того, ключ можна опустити, в результаті вийде
порожня пара дужок (`[]`).

`` synopsis
$arr[key] = value;
$arr[] = value;
// key може бути int або string
// value може бути будь-яким значенням будь-якого типу
````

Якщо масив `$arr` ще не існує або для нього встановлено значення
**`null`** або **`false`**, він буде створений. Таким чином, це ще один
спосіб визначити масив array. Однак такий спосіб застосовувати не
рекомендується, тому що якщо змінна `$arr` вже містить деяке
значення (наприклад, значення типу string із змінної запиту), то це
значення залишиться на місці і `[]` може насправді означати [доступ
до символу в рядку](language.types.string.md#language.types.string.substr). Краще
ініціалізувати змінну шляхом явного надання значення.

> **Примітка**: Починаючи з PHP 7.1.0, використовуючи в оператор "порожній"
> індекс" на рядку, призведе до фатальної помилки. Раніше, у цьому випадку,
> рядок мовчки перетворювалася на масив.

> **Примітка**: Починаючи з PHP 8.1.0, створення нового масиву за допомогою
> значення **`false`** застаріло. Створення нового масиву з **`null`** та
> невизначеного значення, як і раніше, дозволено.

Для зміни певного значення просто надайте нове значення
елемент, використовуючи його ключ. Якщо ви хочете видалити пару ключ/значення,
Ви повинні використовувати функцію [unset()](function.unset.md).

` <?php$arr = array(5 => 1, 12 => 2);$arr[] = 56; // В цьому місце скрипта це                  // те те ж ж, що і $arr[13] = 56;$arr["| // Це додає до масиву новий                 // елемент з ключом "x"unset($arr[5]); // Це видаляє елемент із масивуunset($arr); // Це видаляє масив повністю?> `

> **Примітка**:
>
> Як уже говорилося вище, якщо ключ не було вказано, то буде взято
> максимальний з існуючих цілісних (int) індексів та новим
> ключем буде це максимальне значення (принаймні 0) плюс 1.
> Якщо цілих (int) індексів ще немає, то ключем буде `0` (нуль).
>
> Врахуйте, що максимальне значення ключа *не обов'язково
> існує у масиві на даний момент*. Воно могло просто існувати в
> масиві якийсь час, відколи він був переіндексований в
> востаннє. Наступний приклад це ілюструє:
>
> `<?php//Створюємопростиймасив.$array=array(1,2,3,4,5);print_r($array); as $i => $value) {   Unset($array[$i]);}print_r($array); ;print_r($array);// Переіндексація:$array==array_values($array);$array[] = 7;print_r($array);?> `
>
> Результат виконання цього прикладу:
>
> Array
> (
> [0] => 1
> [1] => 2
> [2] => 3
> [3] => 4
> [4] => 5
> )
> Array
> (
> )
> Array
> (
> [5] => 6
> )
> Array
> (
> [0] => 6
> [1] => 7
> )

### Корисні функції

Для роботи з масивами існує достатня кількість корисних
функцій. Дивіться розділ [функції для роботи з масивами](ref.array.md).

> **Примітка**:
>
> Функція [unset()](function.unset.md) дозволяє видаляти ключі
> масиву. Зверніть увагу, що масив *НЕ* буде переіндексовано.
> Якщо ви дійсно хочете поведінки в стилі "видалити і зрушити",
> можна переіндексувати масив використовуючи
> [array_values()](function.array-values.md).
>
> ` <?php$a = array(1 => 'один', 2 => 'два', 3 => 'три');unset($a[2]);/* дасть масив, представлений так:   $ a = array(1 => 'один', 3 => 'три'); а НЕ так:   $a = array(1 => 'один', 2 => 'три');*/$b = array_values($a);// Теперь $b це array(0 => 1 => 'три')?> `

Керуюча конструкція [foreach](control-structures.foreach.md)
Існує спеціально для масивів. Вона надає можливість легко
пройтися масивом.

### Що можна і не можна робити з масивами

#### Чому `$foo[bar]` неправильно?

Завжди укладайте в лапки рядковий літерал в індексі асоціативного
масиву. Наприклад, пишіть `$foo['bar']`, а чи не `$foo[bar]`. Але чому?
Часто у старих скриптах можна зустріти наступний синтаксис:

` <?php$foo[bar] = 'ворог';echo $foo[bar];// і т.д.?> `

Це неправильно, хоч і працює. Причина в тому, що код містить
невизначену константу (`bar`), а не рядок (``bar'` - зверніть
увагу на лапки). Це працює, тому що PHP автоматично
перетворює *"голий рядок"* (не укладений у лапки рядок, який
не відповідає жодному з відомих символів мови)
значенням цього "голого рядка". Наприклад, якщо константа з ім'ям
**`bar`** не визначена, то PHP замінить bar на рядок ``bar'` і
використовує її.

**Увага**

Резервний варіант для обробки невизначеної константи як порожній
рядки викликає помилку рівня **`E_NOTICE`**. Починаючи з PHP 7.2.0
поведінка оголошена застарілою та викликає помилку рівня **`E_WARNING`**.
Починаючи з PHP 8.0.0, видалено та викидає виняток
[Error](class.error.md).

> **Примітка**: Це не означає, що потрібно *завжди* укладати ключ у
> лапки. Немає необхідності укладати в лапки
> [константи](language.constants.md) або
> [змінні](language.variables.md), оскільки це завадить PHP
> обробляти їх.
>
> ` <?phperror_reporting(E_ALL);ini_set('display_errors', true);ini_set('html_errors', false);// Простий масив:$array = array(1, 2);$count = count($array) ;for ($i = 0; $i < $count; $i++) {   echo "
Перевіряємо $i:
";    echo "Погано: " . $array['$i'] . "
";    echo "Добре: " . $array[$i] . "
";    echo "Погано: {$array['$i']}
";    echo "Добре: {$array[$i]}
";}?> `
>
> Результат виконання цього прикладу:
>
> Перевіряємо 0:
> Notice: Undefined index: $i in /path/to/script.md on line 9
> Погано:
> Добре: 1
> Notice: Undefined index: $i in /path/to/script.md on line 11
> Погано:
> Добре: 1
>
> Перевіряємо 1:
> Notice: Undefined index: $i in /path/to/script.md on line 9
> Погано:
> Добре: 2
> Notice: Undefined index: $i in /path/to/script.md on line 11
> Погано:
> Добре: 2

Додаткові приклади, що демонструють цей факт:

` <?php// Показуємо все помилкиerror_reporting(E_ALL);$arr = array('fruit' => 'apple', 'veggie' => 'carrot');// Вірноprint $arr['fru' // appleprint $arr['veggie']; // Carrot // Неправильно. Це працює, але за невизначеної константи с// іменем fruit також викликає помилки PHP рівня E_NOTICE//// Notice: Use of undefined       ¦ // apple// Давайте визначимо константу, щоб продемонструвати, що// відбувається. Ми присвоїмо константі з іменем fruit значення 'veggie'.define('fruit', 'veggie'); // appleprint $arr[fruit]; // Carrot // Всередині рядки це нормально. Всередині рядків константи не// розглядаються, так що помилки E_NOTICE тут не відбудеться print "Hello $arr[fruit]"; // Hello apple// З одним винятком: фігурні дужки навколо масивів внутрі// рядків дозволяють константам там перебуватиprint "Hello {$arr[fruit]}"; // Hello carrotprint "Hello {$arr['fruit']}"; // Hello apple// Это не будет работать и вызовет ошибку обработки, такую как:// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'// Это, конечно, также действует и с суперглобальными переменными в строкахprint " Hello $arr['fruit']";print "Hello $_GET['foo']";//Ще одна можливість - конкатенаціяprint "Hello " . $arr['fruit']; // Hello apple?> `

Якщо ви переведете [error_reporting](errorfunc.configuration.md#ini.error-reporting) у
режим відображення помилок рівня **`E_NOTICE`** (наприклад, такий як
**`E_ALL`**), ви відразу побачите ці помилки. За замовчуванням
[error_reporting](errorfunc.configuration.md#ini.error-reporting)
встановлена їх не відображати.

Як зазначено у розділі
[синтаксис](language.types.array.md#language.types.array.syntax),
всередині квадратних дужок (''['' і '']'') має бути вираз. Це
означає, що можна писати так:

` <?phpecho $arr[somefunc($bar)];?> `

Це приклад використання значення, що повертається функцією як
індексу масиву PHP відомі також і константи:

` <?php$error_descriptions[E_ERROR]   = "Відбулася фатальна помилка";$error_descriptions[E_WARNING] = "PHP повідомляє про попередження";$error_descriptions[E_NOTICE] 

Зверніть увагу, що **`E_ERROR`** - це такий самий вірний
ідентифікатор, як і `bar` у першому прикладі. Але останній приклад насправді
еквівалентний такому запису:

` <?php$error_descriptions[1] = "Сталася фатальна помилка";$error_descriptions[2] = "PHP повідомляє про попередження";$error_descriptions[8] = "Це лише неофіційне >>

оскільки **`E_ERROR`** відповідає `1` і т.д.

##### Так що ж у цьому поганого?

Колись у майбутньому команда розробників PHP можливо побажає
додати ще одну константу або ключове слово, або константа з
інший код може втрутитися і тоді у вас можуть виникнути проблеми.
Наприклад, ви вже не можете використовувати таким чином слова `empty` та
`default`, оскільки вони є [зарезервованими ключовими словами](reserved.md).

> **Примітка**: Повторимо, усередині рядка (string), укладеного в подвійні
> лапки, коректно не оточувати індекси масиву лапками, тому
> ``$foo[bar]'` є вірним записом. Докладніше чому -
> дивіться наведені вище приклади, а також розділ по [обробці
> змінних у > рядках](language.types.string.md#language.types.string.parsing).

### Перетворення в масив

Для будь-якого з типів int, float, string, bool та resource, перетворення
значення масив дає результатом масив з одним елементом (з індексом
0) є скалярним значенням, з якого ви почали. Іншими
словами, `(array)$scalarValue` - це точно те саме, що і
`array($scalarValue)`.

Якщо ви перетворюєте на масив об'єкт (object), ви отримаєте як
елементів масиву властивості (змінні члени) цього об'єкта. Ключами
будуть імена змінних-членів, з деякими примітними
винятками: цілі властивості стануть недоступні; до закритих полів
класу (private) попереду буде дописано ім'я класу; до захищених полів
класу (protected) попереду буде додано символ '\*'. Ці додані
значення з обох боків також мають 'NUL' байти. Неініціалізовані
[типізовані властивості](language.oop5.properties.md#language.oop5.properties.typed-properties)
автоматично відкидаються.

` <?phpclass A {    private $B; protected $ C; public $D; function __construct()    {        $this->{1} = null; }}var_export((array) new A());?> `

Результат виконання цього прикладу:

array (
''. "". 'A'. "". 'B' => NULL,
''. "". '*'. "". 'C' => NULL,
'D' => NULL,
1 => NULL,
)

Це може викликати дещо несподівану поведінку:

` <?phpclass A {    private $A; // Це стане ' A A'}class B extends A {    private $A; // Це стане ' B A'   public$$AA; // Це стане 'AA'}var_dump((array) new B());?> `

Результат виконання цього прикладу:

array(3) {
["BA"]=>
NULL
["AA"]=>
NULL
["AA"]=>
NULL
}

Наведений вище код покаже 2 ключі з ім'ям 'AA', хоча один з них на
насправді має ім'я 'A A'.

Якщо ви перетворюєте на масив значення **`null`**, ви отримаєте порожній
масив.

### Порівняння

Масиви можна порівнювати за допомогою функції
[array_diff()](function.array-diff.md) та [операторів масивів](language.operators.array.md).

### Розпакування масиву

Масив із префіксом `...` буде розпакований під час визначення масиву.
Тільки масиви та об'єкти, які реалізують інтерфейс
[Traversable](class.traversable.md), можуть бути розпаковані.
Розпакування масиву за допомогою `...` доступне, починаючи з PHP 7.4.0.

Масив можна розпаковувати кілька разів і додавати звичайні елементи до
або після оператора `...`:

**Приклад #9 Просте розпакування масиву**

`<?php// Використання короткого синтаксису масиву.// Також працює с синтаксисом array().$arr1 = [1, 2, 3];$arr2 = [...$arr1]; // [1, 2, 3]$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]function getArr() { return ['a', 'b'];}$arr6 = [...getArr(), 'c' => 'd ']; // ['a', 'b', 'c' => 'd']?> `

Розпакування масиву за допомогою оператора `...` слідує семантиці функції
[array_merge()](function.array-merge.md). Тобто пізніші
рядкові ключі перезаписують раніші, а цілі ключі
перенумеровуються:

**Приклад #10 Розпакування масиву з дублюючим ключем**

` <?php// рядковий ключ$arr1 = ["a" => 1];$arr2 = ["a" => 2];$arr3 = ["a" => 0, ...$arr1, . ..$arr2];var_dump($arr3); // ["a" => 2]// цілочисленний ключ$arr4 = [1, 2, 3];$arr5 = [4, 5, 6];$arr6 = [...$arr4, ...$ arr5]; var_dump ($ arr6); // [1, 2, 3, 4, 5, 6]// Котрий [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => / де вихідні цілочисленні ключи не були збережені.?> `

> **Примітка**:
>
> Ключі, які є цілими числами, ні рядками, викликають > помилку [TypeError](class.typeerror.md). Такі ключі можуть бути
> згенеровані лише об'єктом [Traversable](class.traversable.md).

> **Примітка**:
>
> До PHP 8.1 розпакування масиву з рядковим ключем не підтримувалося:
>
> ` <?php$arr1 = [1, 2, 3];$arr2 = ['a' => 4];$arr3 = [...$arr1, ...$arr2];// Помилка: неможливо розпакувати масив з рядковими ключами в example.php:5$arr4 = [1, 2, 3];$arr5 = [4, 5];$arr6 = [...$arr4, ...$arr5]; // працює. [1, 2, 3, 4, 5]?> `

### Приклади

Тип масив у PHP є дуже гнучким, ось кілька прикладів:

` <?php// это$a = array( 'color' => 'red',            'taste' => 'sweet',            'shape' => 'round',            'name'  => 'apple',            4        / / ключом буде 0           );$b = array('a', 'b', 'c');// . . .повністю відповідає$a = array();$a['color'] = 'red';$a['taste'] = 'sweet';$a['shape'] = 'round';$a[' name']  = 'apple';$a[]        = 4; // ключом буде 0$b = array();$b[] = 'a';$b[] = 'b';$b[] = 'c';// після виконання цього коду, $a буде масивом // array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',// 'name' => 'apple', 0 => 4), а $ b буде// array(0 => 'a', 1 => 'b', 2 => 'c'), або просто array('a', 'b', 'c').?> `

**Приклад #11 Використання array()**

` <?php// Массив как карта (свойств)$map = array( 'version'    => 4,              'OS'         => 'Linux',              'lang'       => 'english',              'short_tags' => true            ); // исключительно числовые ключи$array = array( 7,                8,                0,                156,                -10              );// это то же самое, что и array(0 => 7, 1 => 8, ...)$switching = array(         10, // ключ = 0                    5    =>  6,                    3    =>  7,                    'a'  =>  4,                            11, // ключ = 6 (максимальным числовым индексом было 5)                    '8'  =>  2, // ключ = 8 (число!)                    '02' => 77, // ключ = '02'                    0    => 12  // значение 10 будет перезаписано на 12                  );// пустой массив$empty = array();?> `

**Приклад #12 Колекція**

` <?php$colors = array('red', 'blue', 'green', 'yellow');foreach ($colors as $color) {    echo "Вам подобається $color?
";}?> `

Результат виконання цього прикладу:

Вам подобається red?
Вам подобається blue?
Вам подобається green?
Вам подобається yellow?

Зміна значень масиву безпосередньо можлива шляхом передачі їх по
посилання.

**Приклад #13 Зміна елемента в циклі**

` <?phpforeach ($colors as &$color) {   $color = strtoupper($color);}unset($color); /* це потрібно для того, щоб наступні записи в$color не міняли останній елемент масиву */print_r($colors);?> `

Результат виконання цього прикладу:

Array
(
[0] => RED
[1] => BLUE
[2] => GREEN
[3] => YELLOW
)

Наступний приклад створює масив, що починається з одиниці.

**Приклад #14 Індекс, що починається з одиниці**

` <?php$firstquarter = array(1 => 'Січень', 'Лютого', 'Березень');print_r($firstquarter);?> `

Результат виконання цього прикладу:

Array
(
[1] => 'Січень'
[2] => 'Лютий'
[3] => 'Березень'
)

**Приклад #15 Заповнення масиву**

`<?php// заповнюємо масив всіми елементами з директорії$handle = opendir('.');while (false !== ($file = readdir($handle))) {    $$file| ($handle);?> `

Масиви впорядковані. Ви можете змінювати порядок елементів, використовуючи
різні функції сортування. Для додаткової інформації дивіться
розділ [функції роботи з масивами](ref.array.md). Ви можете
підрахувати кількість елементів у масиві за допомогою функції
[count()](function.count.md).

**Приклад #16 Сортування масиву**

` <?phpsort($files);print_r($files);?> `

Оскільки значення масиву може бути чим завгодно, ним також може бути
інший масив. Таким чином ви можете створювати рекурсивні та
багатовимірні масиви.

**Приклад #17 Рекурсивні та багатовимірні масиви**

` <?php$fruits = array ( "fruits"  => array ( "a" => "апельсин",                                       "b" => "банан",                                       "c" => "яблоко"                                     ),                  "numbers"   => array ( 1,                                       2,                                       3,                                       4,                                       5,                                       6                                     ),                  "holes"   => array (      "первая",                                       5 => "вторая",                                            "третья"                                     )                );// Несколько примеров доступа к значениям предыдущего массиваecho $fruits[ "holes"] [5]; // надрукує "друга"echo $fruits["fruits"]["a"]; // надрукує "апельсин"unset($fruits["holes"][0]); // видалити "перша"// Створити новий багатомірний масив$juices["apple"]["green"] = "good";?> `

Зверніть увагу, що при привласненні масиву завжди відбувається
копіювання значення. Щоб скопіювати масив за посиланням, вам потрібно використовувати [оператор посилання](language.operators.md).

` <?php$arr1 = array(2, 3);$arr2 = $arr1;$arr2[] = 4; // $arr2 змінився,               // $arr1 все ще array(2, 3)$arr3 = &$arr1;$arr3[] = 4; // тепер $arr1 і $arr3 однакові?> `
