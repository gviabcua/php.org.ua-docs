---
navigation:
  - language.namespaces.rules.md: « Правила дозволу імен
  - language.enumerations.md: Перерахування »
  - index.md: PHP Manual
  - language.namespaces.md: Простори імен
title: 'Часті питання (FAQ): що потрібно знати про простори імен'
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Часті питання (FAQ): що потрібно знати про простори імен

(PHP 5 >= 5.3.0, PHP 7, PHP 8)

Цей перелік питань поділено на дві частини: загальні питання та деякі особливості реалізації, які корисні для повного розуміння.

Спершу, спільні питання.

1.  [Якщо в коді не вказано простору імен, чи потрібно вважати щось із цього важливим?](language.namespaces.faq.md#language.namespaces.faq.shouldicare)
2.  [Як звертатися до внутрішніх чи глобальних класів у просторі імен?](language.namespaces.faq.md#language.namespaces.faq.globalclass)
3.  [Як звертатися до функцій класів у просторах імен, чи константам у їхньому просторі імен?](language.namespaces.faq.md#language.namespaces.faq.innamespace)
4.  [Як дозволяються імена`\my\name`или`\name`?](language.namespaces.faq.md#language.namespaces.faq.full)
5.  [Як дозволяється ім'я`my\name`?](language.namespaces.faq.md#language.namespaces.faq.qualified)
6.  [Як дозволяється неповне ім'я класу`name`?](language.namespaces.faq.md#language.namespaces.faq.shortname1)
7.  [Як дозволяється неповне ім'я функції або неповне ім'я константи на кшталт`name`?](language.namespaces.faq.md#language.namespaces.faq.shortname2)

Деякі деталі реалізації просторів імен, які корисно розуміти.

1.  [Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.](language.namespaces.faq.md#language.namespaces.faq.conflict)
2.  [Вкладені простори імен неприпустимі.](language.namespaces.faq.md#language.namespaces.faq.nested)
3.  [Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.](language.namespaces.faq.md#language.namespaces.faq.quote)
4.  [Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка](language.namespaces.faq.md#language.namespaces.faq.constants)
5.  [Неможливо перевизначити спеціальні константи **`null`** **`true`**или**`false`**](language.namespaces.faq.md#language.namespaces.faq.builtinconst)

### Якщо в коді не вказано простору імен, чи потрібно вважати щось із цього важливим?

Ні, простори імен ніяк не впливають ні на існуючий код, ні ще не написаний код без просторів імен. Можна написати такий код, якщо потрібно:

**Приклад #1 Доступ до глобальних класів поза межами імен**

```php
<?php

$a = new \stdClass;

?>
```

Це функціонально еквівалентно наступному:

**Приклад #2 Доступ до глобальних класів поза простором імен**

```php
<?php

$a = new stdClass;

?>
```

### Як звертатися до внутрішніх чи глобальних класів у просторі імен?

**Приклад #3 Доступ до внутрішніх класів у просторах імен**

```php
<?php

namespace foo;
$a = new \stdClass;

function test(\ArrayObject $parameter_type_example = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// расширение внутреннего или глобального класса
class MyException extends \Exception {}

?>
```

### Як використовувати функції класів у просторах імен чи константи у власному просторі імен?

**Приклад #4 Доступ до внутрішніх класів, функцій або константів у просторах імен**

```php
<?php

namespace foo;

class MyClass {}

// использование класса из текущего пространства имен в качестве типа параметра
function test(MyClass $parameter_type_example = null) {}
// другой способ использовать класс из текущего пространства имен в качестве типа параметра
function test(\foo\MyClass $parameter_type_example = null) {}

// расширение класса из текущего пространства имён
class Extended extends MyClass {}

// доступ к глобальной функции
$a = \globalfunc();

// доступ к глобальной константе
$b = \INI_ALL;

?>
```

### Как имена вроде`\my\name`или`\name` перетворюються?

Імена, які починаються з `\`, Перетворюються до того, як вони виглядають, тобто . `\my\name` - це насправді `my\name`, а`\Exception` - це `Exception`

**Приклад #5 Абсолютні імена**

```php
<?php

namespace foo;
$a = new \my\name(); // создаёт экземпляр класса my\name
echo \strlen('hi'); // вызывает функцию strlen
$a = \INI_ALL; // переменной $a присваивается значение константы INI_ALL

?>
```

### Як ім'я `my\name`преобразуется?

Імена, які містять зворотний сліш, але не починаються з нього, такі як `my\name` можуть бути перетворені двома способами.

Якщо є імпортуючий вираз, який створює синонім `my` іншого імені, то цей синонім застосовується до `my`в`my\name`

В іншому випадку, поточне ім'я простору імен стає префіксом до `my\name`

**Приклад #6 Повні імена**

```php
<?php

namespace foo;
use blah\blah as foo;

$a = new my\name(); // создаёт экземпляр класса foo\my\name
foo\bar::name(); // вызывает статический метод name в классе blah\blah\bar
my\bar(); // вызывает функцию foo\my\bar
$a = my\BAR; // присваивает переменной $a значение константы foo\my\BAR

?>
```

### Как неполное имя класса вроде`name` перетворюється?

Імена класів, які не містять зворотного слішу, наприклад, `name` можуть бути перетворені двома способами.

Якщо є імпортуючий вираз, який створює синонім `name` іншого імені, то застосовується цей синонім.

В іншому випадку, поточне ім'я простору імен стає префіксом до `name`

**Приклад #7 Неповні імена класів**

```php
<?php

namespace foo;
use blah\blah as foo;

$a = new name(); // создаёт экземпляр класса foo\name
foo::name(); // вызывает статический метод name в классе blah\blah

?>
```

### Як неповне ім'я функції або неповне ім'я константи, наприклад, `name` перетворюється?

Імена функцій або констант, які не містять зворотного слішу, наприклад, `name` можуть бути перетворені двома способами.

Спочатку поточне ім'я простору імен стає префіксом до `name`

Потім, якщо константа чи функція `name` не існує в поточному просторі імен, буде використано глобальну константу або функцію `name`якщо вона існує.

**Приклад #8 Неповні імена функцій або констант**

```php
<?php

namespace foo;
use blah\blah as foo;

const FOO = 1;

function my() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // вызывает глобальную функцию sort
    $a = array_flip($a);
    return $a;
}

my(); // вызывает foo\my
$a = strlen('hi'); // вызывает глобальную функцию strlen, потому что foo\strlen не существует
$arr = array(1,3,2);
$b = sort($arr); // вызывает функцию foo\sort
$c = foo(); // вызывает функцию foo\foo — импорт не применяется

$a = FOO; // присваивает переменной $a значение константы «foo\FOO» — импорт не применяется
$b = INI_ALL; // присваивает переменной $b значение глобальной константы INI_ALL

?>
```

### Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.

Наступні комбінації скриптів допустимі:

file1.php

```php
<?php

namespace my\stuff;
class MyClass {}

?>
```

another.php

```php
<?php

namespace another;
class thing {}

?>
```

file2.php

```php
<?php

namespace my\stuff;
include 'file1.php';
include 'another.php';

use another\thing as MyClass;
$a = new MyClass; // создаёт экземпляр класса thing из пространства имён another

?>
```

Конфлікт імен відсутній навіть незважаючи на те, що клас `MyClass` існує всередині простору імен `my\stuff`, тому що визначення MyClass знаходиться в окремому файлі. Однак наступний приклад призводить до фатальної помилки з конфліктом імен, тому що клас MyClass визначений у тому файлі, де знаходиться оператор use.

```php
<?php

namespace my\stuff;
use another\thing as MyClass;
class MyClass {} // фатальная ошибка: MyClass конфликтует с выражением импорта
$a = new MyClass;

?>
```

### Вкладені простори імен неприпустимі.

PHP не дозволяє вкладення просторів імен одне в інше

```php
<?php

namespace my\stuff {
    namespace nested {
        class foo {}
    }
}

?>
```

Однак, можна зімітувати вкладені простори імен так:

```php
<?php

namespace my\stuff\nested {
    class foo {}
}

?>
```

### Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.

Важливо розуміти це, тому що зворотний сліш усередині рядків працює як символ, що екранує. Він має бути продубльований, коли вказано всередині рядка, інакше з'являється ризик ненавмисних наслідків:

**Приклад #9 Підводне каміння при вказівці імені простору імен усередині рядка з подвійними лапками**

```php
<?php

$a = "dangerous\name"; // \n — это переход на новую строку внутри строки с двойными кавычками!
$obj = new $a;

$a = 'not\at\all\dangerous'; // а тут нет проблем.
$obj = new $a;

?>
```

Усередині рядків, укладених в одинарні лапки, зворотний слєш як роздільник більш безпечний, але, як і раніше, рекомендована практика екранування зворотного слєша в усіх рядках є найкращим варіантом.

### Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка

Будь-яка невизначена константа — неповне ім'я на зразок `FOO` - буде приводити до висновку повідомлення про те, що PHP припустив, що `FOO` було значення константи. Будь-яка константа, з повним або абсолютним ім'ям, яка містить символ зворотного сліша, буде призводити до фатальної помилки, якщо не буде знайдена.

**Приклад #10 Невизначені константи**

```php
<?php

namespace bar;
$a = FOO; // выводит предупреждение: undefined constants "FOO" assumed "FOO";
$a = \FOO; // фатальная ошибка: undefined namespace constant FOO
$a = Bar\FOO; // фатальная ошибка: undefined namespace constant bar\Bar\FOO
$a = \Bar\FOO; // фатальная ошибка: undefined namespace constant Bar\FOO

?>
```

### Неможливо перевизначити спеціальні константи **`null`** **`true`**или**`false`**

Будь-яка спроба визначити константу простору імен, яка збігається з назвами спеціальних вбудованих констант, призведе до фатальної помилки.

**Приклад #11 Невизначені константи**

```php
<?php

namespace bar;
const NULL = 0; // Фатальная ошибка;
const true = 'stupid'; // также фатальная ошибка;
// и т. д.

?>
```
