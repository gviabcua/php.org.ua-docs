Часті питання (FAQ): речі, які вам необхідно знати про простори імен

-   [« Правила разрешения имён](language.namespaces.rules.html)
    
-   [Перечисления »](language.enumerations.html)
    
-   [PHP Manual](index.html)
    
-   [Пространства имён](language.namespaces.html)
    
-   Часті питання (FAQ): речі, які вам необхідно знати про простори імен
    

## Часті питання (FAQ): речі, які вам необхідно знати про простори імен

(PHP 5> = 5.3.0, PHP 7, PHP 8)

Цей перелік питань поділено на дві частини: загальні питання та деякі особливості реалізації, які корисні для більш повного розуміння.

Спершу, спільні питання.

1.  [Якщо я не використовую простору імен, чи слід вважати щось із цього важливим?](language.namespaces.faq.html#language.namespaces.faq.shouldicare)
2.  [Як мені використовувати внутрішні чи глобальні класи у просторі імен?](language.namespaces.faq.html#language.namespaces.faq.globalclass)
3.  [Як мені використовувати функції класів у просторах імен, чи константи у їхньому власному просторі імен?](language.namespaces.faq.html#language.namespaces.faq.innamespace)
4.  [Как такое имя как`\my\name`или`\name`преобразуется?](language.namespaces.faq.html#language.namespaces.faq.full)
5.  [Как такое имя, как`my\name`преобразуется?](language.namespaces.faq.html#language.namespaces.faq.qualified)
6.  [Как неполное имя класса такое как`name`преобразуется?](language.namespaces.faq.html#language.namespaces.faq.shortname1)
7.  [Как неполное имя функции или неполное имя константы такое как`name`преобразуется?](language.namespaces.faq.html#language.namespaces.faq.shortname2)

Деякі деталі реалізації просторів імен, які корисно розуміти.

1.  [Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.](language.namespaces.faq.html#language.namespaces.faq.conflict)
2.  [Вкладені простори імен неприпустимі.](language.namespaces.faq.html#language.namespaces.faq.nested)
3.  [Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.](language.namespaces.faq.html#language.namespaces.faq.quote)
4.  [Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка](language.namespaces.faq.html#language.namespaces.faq.constants)
5.  [Неможливо перевизначити спеціальні константи, такі як NULL, TRUE, FALSE, ZENDTHREADSAFE или ZENDDEBUGBUILD](language.namespaces.faq.html#language.namespaces.faq.builtinconst)

### Якщо я не використовую простору імен, чи слід вважати щось із цього важливим?

Ні. Простір імен не впливає ні на який існуючий код ні в якому вигляді або на будь-який написаний код, який не містить просторів імен. Ви можете написати такий код, якщо бажаєте:

**Приклад #1 Доступ до глобальних класів поза межами імен**

```php
<?php
$a = new \stdClass;
?>
```

Це функціонально еквівалентно наступному:

**Приклад #2 Доступ до глобальних класів поза простором імен**

```php
<?php
$a = new stdClass;
?>
```

### Як мені використовувати внутрішні чи глобальні класи у просторі імен?

**Приклад #3 Доступ до внутрішніх класів у просторах імен**

```php
<?php
namespace foo;
$a = new \stdClass;

function test(\ArrayObject $parameter_type_example = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// расширение внутреннего или глобального класса
class MyException extends \Exception {}
?>
```

### Як мені використовувати функції класів у просторах імен чи константи у їхньому власному просторі імен?

**Приклад #4 Доступ до внутрішніх класів, функцій або константів у просторах імен**

```php
<?php
namespace foo;

class MyClass {}

// использование класса из текущего пространства имен в качестве типа параметра
function test(MyClass $parameter_type_example = null) {}
// другой способ использовать класс из текущего пространства имен в качестве типа параметра
function test(\foo\MyClass $parameter_type_example = null) {}

// расширение класса из текущего пространства имён
class Extended extends MyClass {}

// доступ к глобальной функции
$a = \globalfunc();

// доступ к глобальной константе
$b = \INI_ALL;
?>
```

### Як таке ім'я як `\my\name` або `\name` перетворюється?

Імена, які починаються з `\` завжди перетворюються на те, як вони виглядають, тобто . `\my\name` - це насправді `my\name`, і `\Exception` - це `Exception`

**Приклад #5 Абсолютні імена**

```php
<?php
namespace foo;
$a = new \my\name(); // создаёт экземпляр класса "my\name"
echo \strlen('hi'); // вызывает функцию "strlen"
$a = \INI_ALL; // переменной $a присваивается значение константы "INI_ALL"
?>
```

### Як таке ім'я, як `my\name` перетворюється?

Імена, які містять зворотний сліш, але не починаються з нього, такі як `my\name` можуть бути перетворені двома різними способами.

Якщо є імпортуючий вираз, який створює синонім `my` іншого імені, то цей синонім застосовується до `my` в `my\name`

В іншому випадку, поточне ім'я простору імен стає префіксом до `my\name`

**Приклад #6 Повні імена**

```php
<?php
namespace foo;
use blah\blah as foo;

$a = new my\name(); // создаёт экземпляр класса "foo\my\name"
foo\bar::name(); // вызывает статический метод "name" в классе "blah\blah\bar"
my\bar(); // вызывает функцию "foo\my\bar"
$a = my\BAR; // присваивает переменной $a значение константы "foo\my\BAR"
?>
```

### Як неповне ім'я класу таке як `name` перетворюється?

Імена класів, які не містять зворотний сліш, такі як `name` можуть бути перетворені двома різними способами.

Якщо є імпортуючий вираз, який створює синонім `name` іншого імені, то застосовується цей синонім.

В іншому випадку, поточне ім'я простору імен стає префіксом до `name`

**Приклад #7 Неповні імена класів**

```php
<?php
namespace foo;
use blah\blah as foo;

$a = new name(); // создаёт экземпляр класса "foo\name"
foo::name(); // вызывает статический метод "name" в классе "blah\blah"
?>
```

### Як неповне ім'я функції або неповне ім'я константи таке як `name` перетворюється?

Імена функцій або констант, які не містять зворотного слішу, такі як `name` можуть бути перетворені двома різними способами.

Спершу, поточне ім'я простору імен стає префіксом до `name`

Потім, якщо константа чи функція `name` не існує у поточному просторі імен, використовується глобальна константа чи функція `name`якщо вона існує.

**Приклад #8 Неповні імена функцій або констант**

```php
<?php
namespace foo;
use blah\blah as foo;

const FOO = 1;

function my() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // вызывает глобальную функцию "sort"
    $a = array_flip($a);
    return $a;
}

my(); // вызывает "foo\my"
$a = strlen('hi'); // вызывает глобальную функцию "strlen", потому что "foo\strlen" не существует
$arr = array(1,3,2);
$b = sort($arr); // вызывает функцию "foo\sort"
$c = foo(); // вызывает функцию "foo\foo" - импорт не применяется

$a = FOO; // присваивает переменной $a значение константы "foo\FOO" - импорт не применяется
$b = INI_ALL; // присваивает переменной $b значение глобальной константы "INI_ALL"
?>
```

### Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.

Наступні комбінації скриптів допустимі:

file1.php

```php
<?php
namespace my\stuff;
class MyClass {}
?>
```

another.php

```php
<?php
namespace another;
class thing {}
?>
```

file2.php

```php
<?php
namespace my\stuff;
include 'file1.php';
include 'another.php';

use another\thing as MyClass;
$a = new MyClass; // создаёт экземпляр класса "thing" из пространства имён "another"
?>
```

Конфлікт імен відсутній навіть незважаючи на те, що клас `MyClass` існує всередині простору імен `my\stuff`, тому що визначення MyClass знаходиться в окремому файлі. Однак наступний приклад призводить до фатальної помилки з конфліктом імен, тому що клас MyClass визначений у тому файлі, де знаходиться оператор use.

```php
<?php
namespace my\stuff;
use another\thing as MyClass;
class MyClass {} // фатальная ошибка: MyClass конфликтует с выражением импорта
$a = new MyClass;
?>
```

### Вкладені простори імен неприпустимі.

PHP не дозволяє вкладення просторів імен одне в інше

```php
<?php
namespace my\stuff {
    namespace nested {
        class foo {}
    }
}
?>
```

Однак, можна зімітувати вкладені простори імен так:

```php
<?php
namespace my\stuff\nested {
    class foo {}
}
?>
```

### Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.

Дуже важливо уявляти це, тому що зворотний сліш використовується як символ усередині рядків. Він завжди повинен бути продубльований, коли використовується всередині рядка, інакше виникає ризик виникнення ненавмисних наслідків:

**Приклад #9 Підводне каміння при використанні імені простору імен усередині рядка з подвійними лапками**

```php
<?php
$a = "dangerous\name"; // \n - это переход на новую строку внутри строки с двойными кавычками!
$obj = new $a;

$a = 'not\at\all\dangerous'; // а тут нет проблем.
$obj = new $a;
?>
```

Усередині рядків, укладених в одинарні лапки, зворотний слєш як роздільник більш безпечний, але, як і раніше, рекомендована практика екранування зворотного слєша у всіх рядках є найкращим варіантом.

### Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка

Будь-яка невизначена константа, яка є неповним ім'ям, як `FOO`, буде приводити до висновку повідомлення про те, що PHP припустив, що `FOO` було значення константи. Будь-яка константа, з повним або абсолютним ім'ям, яка містить символ зворотного сліша, буде призводити до фатальної помилки, якщо не буде знайдена.

**Приклад #10 Невизначені константи**

```php
<?php
namespace bar;
$a = FOO; // выводит предупреждение: undefined constants "FOO" assumed "FOO";
$a = \FOO; // фатальная ошибка: undefined namespace constant FOO
$a = Bar\FOO; // фатальная ошибка: undefined namespace constant bar\Bar\FOO
$a = \Bar\FOO; // фатальная ошибка: undefined namespace constant Bar\FOO
?>
```

### Неможливо перевизначити спеціальні константи, такі як NULL, TRUE, FALSE, ZENDTHREADSAFE або ZENDDEBUGBUILD

Будь-яка спроба визначити константу простору імен, яка збігається з назвами спеціальних вбудованих констант, призведе до фатальної помилки.

**Приклад #11 Невизначені константи**

```php
<?php
namespace bar;
const NULL = 0; // Фатальная ошибка;
const true = 'stupid'; // также фатальная ошибка;
// и т.д.
?>
```