Пізніше статичне зв'язування

-   [« Сравнение объектов](language.oop5.object-comparison.html)
    
-   [Об'єкти та посилання »](language.oop5.references.html)
    
-   [PHP Manual](index.html)
    
-   [Классы и объекты](language.oop5.html)
    
-   Пізніше статичне зв'язування
    

## Пізніше статичне зв'язування

PHP реалізує функцію, звану пізніше статичне зв'язування, яка може бути використана для того, щоб отримати посилання на клас, що викликається в контексті статичного успадкування.

Якщо точніше говорити, пізніше статичне зв'язування зберігає ім'я класу вказаного в останньому "неперенаправленому виклику". У разі статичних викликів це явно вказаний клас (зазвичай ліворуч від оператора [](language.oop5.paamayim-nekudotayim.html)); у разі нестатичних викликів це клас об'єкта. "Переспрямований виклик" - це статичний виклик, що починається з `self::` `parent::` `static::`, або, якщо рухатися вгору по ієрархії класів, [forwardstaticcall()](function.forward-static-call.html). Функція [getcalledclass()](function.get-called-class.html) може бути використана для отримання рядка з ім'ям викликаного класу, а `static::` представляє її сферу дії.

Сама назва "пізнє статичне зв'язування" відображає в собі внутрішню реалізацію цієї особливості. "Пізнє зв'язування" відображає той факт, що звернення через `static::` не будуть обчислюватися по відношенню до класу, в якому метод, що викликається, визначений, а будуть обчислюватися на основі інформації в ході виконання. Також ця особливість була названа "статичне зв'язування" тому, що вона може бути використана (але не обов'язково) у статичних методах.

### Обмеження `self::`

Статичні посилання на поточний клас, такі як `self::` або `__CLASS__`, обчислюються використовуючи клас, якого ця функція належить, як у тому місці, де було визначено:

**Приклад #1 Використання `self::`**

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
```

Результат виконання цього прикладу:

```
A
```

### Використання пізнього статичного зв'язування

Пізніше статичне зв'язування намагається усунути це обмеження, надаючи ключове слово, яке посилається клас, викликаний безпосередньо під час виконання. Просто кажучи, ключове слово, яке дозволить вам посилатися на `B` з `test()` у попередньому прикладі. Вирішили не вводити нове ключове слово, а використовувати `static`, яка вже зарезервована.

**Приклад #2 Просте використання `static::`**

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
```

Результат виконання цього прикладу:

```
B
```

> **Зауваження**
> 
> У нестатичному контексті викликаним класом буде той, до якого належить екземпляр об'єкта. Оскільки `$this->` буде намагатися викликати закриті методи з тієї ж області дії, використання `static::` може дати різні результати. Інша відмінність у тому, що `static::` може посилатися лише на статичні поля класу.

**Приклад #3 Використання `static::` у нестатичному контексті**

```php
<?php
class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {
   /* foo() будет скопирован в В, следовательно его область действия по прежнему А,
      и вызов будет успешным */
}

class C extends A {
    private function foo() {
        /* исходный метод заменён; область действия нового метода - С */
    }
}

$b = new B();
$b->test();
$c = new C();
$c->test();   // потерпит ошибку
?>
```

Результат виконання цього прикладу:

```
success!
success!
success!


Fatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9
```

> **Зауваження**
> 
> Дозволяюча область пізнього статичного зв'язування буде фіксована статичним викликом, що обчислює її. З іншого боку, статичні виклики з використанням таких директив як `parent::` або `self::` перенаправляють інформацію дзвінка.
> 
> **Приклад #4 Перенаправлені та ненаправлені дзвінки**
> 
> ```php
> <?php
> class A {
>     public static function foo() {
>         static::who();
>     }
> 
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> 
> class B extends A {
>     public static function test() {
>         A::foo();
>         parent::foo();
>         self::foo();
>     }
> 
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> class C extends B {
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> 
> C::test();
> ?>
> ```
> 
> Результат виконання цього прикладу:
> 
> ```
> A
> C
> C
> ```