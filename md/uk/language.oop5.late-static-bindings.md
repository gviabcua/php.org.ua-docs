---
navigation:
  - language.oop5.object-comparison.md: « Порівняння об'єктів
  - language.oop5.references.md: Об'єкти та посилання »
  - index.md: PHP Manual
  - language.oop5.md: Класи та об'єкти
title: Пізніше статичне зв'язування
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Пізніше статичне зв'язування

PHP реалізує функцію, звану пізніше статичне зв'язування, яка може бути використана для того, щоб отримати посилання на клас, що викликається в контексті статичного успадкування.

Якщо точніше говорити, пізніше статичне зв'язування зберігає ім'я класу вказаного в останньому "неперенаправленому виклику". У разі статичних викликів це явно вказаний клас (зазвичай ліворуч від оператора [`::`](language.oop5.paamayim-nekudotayim.md)); у разі нестатичних викликів це клас об'єкта. "Переспрямований виклик" - це статичний виклик, що починається з `self::` `parent::` `static::`, або, якщо рухатися вгору по ієрархії класів, [forward\_static\_call()](function.forward-static-call.md)Функция[get\_called\_class()](function.get-called-class.md) може бути використана для отримання рядка з ім'ям викликаного класу, а `static::` представляє її сферу дії.

Сама назва "пізнє статичне зв'язування" відображає в собі внутрішню реалізацію цієї особливості. "Пізнє зв'язування" відображає той факт, що звернення через `static::` не будуть обчислюватися по відношенню до класу, в якому метод, що викликається, визначений, а будуть обчислюватися на основі інформації в ході виконання. Також ця особливість була названа "статичне зв'язування" тому, що вона може бути використана (але не обов'язково) у статичних методах.

### Ограничения`self::`

Статичні посилання на поточний клас, такі як `self::`или`__CLASS__`, обчислюються використовуючи клас, якого ця функція належить, як у тому місці, де було визначено:

**Приклад #1 Использование`self::`**

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
```

Результат виконання наведеного прикладу:

```
A
```

### Використання пізнього статичного зв'язування

Пізніше статичне зв'язування намагається усунути це обмеження, надаючи ключове слово, яке посилається клас, викликаний безпосередньо під час виконання. Простіше кажучи, ключове слово, яке дозволить вам посилатися на `B`из`test()` у попередньому прикладі. Вирішили не вводити нове ключове слово, а використовувати `static`, яка вже зарезервована.

**Приклад #2 Простое использование`static::`**

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
```

Результат виконання наведеного прикладу:

```
B
```

> **Зауваження** :
> 
> У нестатичному контексті викликаним класом буде той, до якого належить екземпляр об'єкта. Оскільки `$this->` буде намагатися викликати закриті методи з тієї ж області дії, використання `static::` може дати різні результати. Інша відмінність у тому, що `static::` може посилатися лише на статичні поля класу.

**Приклад #3 Использование`static::` у нестатичному контексті**

```php
<?php
class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {
   /* foo() будет скопирован в В, следовательно его область действия по прежнему А,
      и вызов будет успешным */
}

class C extends A {
    private function foo() {
        /* исходный метод заменён; область действия нового метода - С */
    }
}

$b = new B();
$b->test();
$c = new C();
$c->test();   // потерпит ошибку
?>
```

Результат виконання наведеного прикладу:

```
success!
success!
success!


Fatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9
```

> **Зауваження** :
> 
> Дозволяюча область пізнього статичного зв'язування буде фіксована статичним викликом, що обчислює її. З іншого боку, статичні виклики з використанням таких директив як `parent::`или`self::` перенаправляють інформацію дзвінка.
> 
> **Приклад #4 Перенаправлені та неперенаправлені дзвінки**
> 
> ```php
> <?php
> class A {
>     public static function foo() {
>         static::who();
>     }
> 
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> 
> class B extends A {
>     public static function test() {
>         A::foo();
>         parent::foo();
>         self::foo();
>     }
> 
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> class C extends B {
>     public static function who() {
>         echo __CLASS__."\n";
>     }
> }
> 
> C::test();
> ?>
> ```
> 
> Результат виконання наведеного прикладу:
> 
> ```
> A
> C
> C
> ```
