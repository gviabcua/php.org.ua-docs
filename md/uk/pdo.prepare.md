Підготовляє запит до виконання та повертає пов'язаний із цим запитом об'єкт

-   [« PDO::lastInsertId](pdo.lastinsertid.html)
    
-   [PDO::query »](pdo.query.html)
    
-   [PHP Manual](index.html)
    
-   [PDO](class.pdo.html)
    
-   Підготовляє запит до виконання та повертає пов'язаний із цим запитом об'єкт
    

# PDO::prepare

(PHP 5 >= 5.1.0, PHP 7, PHP 8, PHP 8, PECL pdo >= 0.1.0)

PDO::prepare — Готує запит до виконання та повертає пов'язаний із цим запитом об'єкт

### Опис

```methodsynopsis
public PDO::prepare(string $query, array $options = []): PDOStatement|false
```

Підготовка SQL-запиту до бази даних до запуску за допомогою методу [PDOStatement::execute()](pdostatement.execute.html). Запит може містити іменовані (:name) або неіменовані (?) псевдозмінні, які будуть замінені на реальні значення під час запуску запиту на виконання. Використовувати одночасно і іменовані, і неіменовані псевдозмінні в одному запиті не можна, необхідно вибрати щось одне. Використовуйте псевдозмінні, щоб прив'язати до запиту введення користувача, не включайте дані, введені користувачем, безпосередньо в запит.

Ви повинні підбирати унікальні імена псевдозмінних для кожного значення, яке необхідно надсилати в запит під час виклику [PDOStatement::execute()](pdostatement.execute.html). Не можна використовувати одну псевдозмінну в запиті більше одного разу, крім варіанта, коли активовано режим емуляції.

> **Зауваження**
> 
> Псевдозмінні повинні представляти лише одиничний обсяг даних. Ні частина значення, ні службове слово, ні ім'я поля, ні будь-яку довільну частину запиту. Наприклад, ви не можете зв'язати псевдозмінну з кількома значеннями для вставки в конструкцію IN().

Виклик **PDO::prepare()** і [PDOStatement::execute()](pdostatement.execute.html) для запитів, які будуть запускатися багаторазово з різними параметрами, підвищує продуктивність програми, дозволяючи драйверу кешувати на клієнті та/або сервері план виконання запиту та метадані, а також допомагає уникнути SQL-ін'єкцій, оскільки немає необхідності екранувати параметри, що передаються.

Якщо драйвер не підтримує запити, що підготовляються, PDO вміє їх емулювати, а також може замінювати псевдозмінні на те, що більше підходить, якщо, наприклад, драйвер підтримує тільки іменовані або, навпаки, тільки неіменовані псевдозмінні.

> **Зауваження**: Синтаксичний аналізатор, що використовується для підготовлених емульованих операторів і для перезапису іменованих параметрів або параметрів стилю знака питання, підтримує нестандартні зворотні сліші для одинарних і подвійних лапок. Це означає, що завершальні лапки, що безпосередньо передують зворотній косій межі, не розпізнаються як такі, що може призвести до неправильного виявлення параметрів, що призведе до збою підготовленого оператора при його виконанні. Обхідний шлях – не використовувати емульовану підготовку до таких SQL-запитів та уникати перезапису параметрів, використовуючи стиль параметрів, який спочатку підтримується драйвером.

Починаючи з PHP 7.4.0, можна уникнути екранування знаків питання, подвоївши їх. Це означає, що рядок `??` буде перетворено на `?` при надсиланні запиту до бази даних.

### Список параметрів

`query`

Це має бути коректний SQL-запит з погляду цільової СУБД.

`options`

Цей масив містить одну або більше пар ключ => значення для встановлення значень атрибутів об'єкта PDOStatement, який буде повернутий з цього методу. В основному, ви використовуватимете цей масив для присвоєння значення `PDO::ATTR_CURSOR` атрибуту `PDO::CURSOR_SCROLL`, щоб отримати курсор, що прокручується. Деякі драйвери можуть мати свої специфічні налаштування, які можна встановити під час підготовки запиту.

### Значення, що повертаються

Якщо СУБД успішно підготувала запит, **PDO::prepare()** повертає об'єкт [PDOStatement](class.pdostatement.html). Якщо підготувати запит не вдалося, **PDO::prepare()** повертає **`false`** або викидає виняток [PDOException](class.pdoexception.html) (залежить від поточного режиму [обработки ошибок](pdo.error-handling.html)

> **Зауваження**
> 
> Емульовані підготовлені запити не створюються на сервері баз даних, тому **PDO::prepare()** неспроможна перевірити правильність побудованого запиту.

### Приклади

**Приклад #1 Підготовка SQL-запиту з іменованими параметрами**

```php
<?php
/* Выполнение запроса с передачей ему массива параметров */
$sql = 'SELECT name, colour, calories
    FROM fruit
    WHERE calories < :calories AND colour = :colour';
$sth = $dbh->prepare($sql, array(PDO::ATTR_CURSOR => PDO::CURSOR_FWDONLY));
$sth->execute(array('calories' => 150, 'colour' => 'red'));
$red = $sth->fetchAll();
/* Ключи массива также могут начинаться с двоеточия ":" (необязательно) */
$sth->execute(array(':calories' => 175, ':colour' => 'yellow'));
$yellow = $sth->fetchAll();
?>
```

**Приклад #2 Підготовка SQL-запиту з неназваними параметрами (символ '?')**

```php
<?php
/* Выполнение запроса с передачей ему массива параметров */
$sth = $dbh->prepare('SELECT name, colour, calories
    FROM fruit
    WHERE calories < ? AND colour = ?');
$sth->execute(array(150, 'red'));
$red = $sth->fetchAll();
$sth->execute(array(175, 'yellow'));
$yellow = $sth->fetchAll();
?>
```

**Приклад #3 Підготовка SQL-запиту з екранованим знаком питання**

```php
<?php
/* замечание: работает только с базами данных PostgreSQL */
$sth = $dbh->prepare('SELECT * FROM issues WHERE tag::jsonb ?? ?');
$sth->execute(['feature']);
$featureIssues = $sth->fetchAll();
$sth->execute(['performance']);
$performanceIssues = $sth->fetchAll();
?>
```

### Дивіться також

-   [PDO::exec()](pdo.exec.html) - Виконує SQL-запит та повертає кількість порушених рядків
-   [PDO::query()](pdo.query.html) - готує та виконує вираз SQL без заповнювачів
-   [PDOStatement::execute()](pdostatement.execute.html) - Запускає підготовлений запит на виконання