---
navigation:
  - function.ksort.md: « ksort
  - function.natcasesort.md: natcasesort »
  - index.md: PHP Manual
  - ref.array.md: Функції для роботи з масивами
title: list
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# list

(PHP 4, PHP 5, PHP 7, PHP 8)

list - Надає змінним значення схожим на масиви синтаксисом

### Опис

```methodsynopsis
list(mixed $var, mixed ...$vars = ?): array
```

Як і конструкція [array()](function.array.md), це функція, а мовна конструкція. Конструкцією **list()** користуються, щоб надавати списку змінних значення за одну операцію. Рядки не можна розпакувати, а вирази **list()** не можна викликати без аргументів.

> **Зауваження** :
> 
> До PHP 7.1.0 конструкция**list()** працювала тільки з індексованими масивами та приймала числові індекси починаючи з 0.

### Список параметрів

`var`

Змінна.

`vars`

Додаткові змінні.

### Значення, що повертаються

Повертає привласнений масив.

### список змін

| Версия | Опис |
| --- | --- |
| 7.3.0 | Додано підтримку присвоєння за посиланнями при деструктуруванні масиву. |
| 7.1.0 | Тепер у конструкції **list()** можна задавати ключі. Це дозволяє розіменовувати асоціативні масиви та масиви з індексами не по порядку. |

### Приклади

**Приклад #1 Приклад використання конструкції **list()****

```php
<?php

$info = array('кофе', 'коричневый', 'кофеин');

// Составить список всех переменных
list($drink, $color, $power) = $info;
echo "$drink - $color, а $power делает его особенным.\n";

// Составить список только некоторых из них
list($drink, , $power) = $info;
echo "В $drink есть $power.\n";

// Или пропустить все, кроме третьей
list( , , $power) = $info;
echo "Мне нужен $power!\n";

// Конструкция list() не работает со строками
list($bar) = "abcde";
var_dump($bar); // NULL
?>
```

**Приклад #2 Приклад використання конструкції **list()****

```php
<?php

$result = $pdo->query("SELECT id, name FROM employees");
while (list($id, $name) = $result->fetch(PDO::FETCH_NUM)) {
    echo "id: $id, name: $name\n";
}
?>
```

**Пример #3 Использование**list()\*\* з індексами масивів\*\*

```php
<?php

list($a, list($b, $c)) = array(1, array(2, 3));

var_dump($a, $b, $c);

?>
```

```
int(1)
int(2)
int(3)
```

**Пример #4 Конструкция**list()\*\* та порядок вказівки індексів\*\*

Порядок визначення індексів у масиві, з яким працюватиме конструкція **list()**, не важливий.

```php
<?php

$foo = array(2 => 'a', 'foo' => 'b', 0 => 'c');
$foo[1] = 'd';
list($x, $y, $z) = $foo;
var_dump($foo, $x, $y, $z);
```

Дає такий висновок (зверніть увагу на порядок, в якому елементи порівнювалися, і в якому порядку записані елементи в синтаксисі **list()**):

```
array(4) {
  [2]=>
  string(1) "a"
  ["foo"]=>
  string(1) "b"
  [0]=>
  string(1) "c"
  [1]=>
  string(1) "d"
}
string(1) "c"
string(1) "d"
string(1) "a"
```

**Пример #5**list()\*\* з ключами\*\*

Починаючи з PHP 7.1.0 конструкції **list()** можна містити явні ключі, які вказують як довільні вирази. Допустимо змішувати рядкові та цілочислові ключі; однак елементи з ключами і без ключів не можна змішувати.

```php
<?php

$data = [
    ["id" => 1, "name" => 'Tom'],
    ["id" => 2, "name" => 'Fred'],
];
foreach ($data as ["id" => $id, "name" => $name]) {
    echo "id: $id, name: $name\n";
}
echo PHP_EOL;
list(1 => $second, 3 => $fourth) = [1, 2, 3, 4];
echo "$second, $fourth\n";
```

Результат виконання наведеного прикладу:

```
id: 1, name: Tom
id: 2, name: Fred

2, 4
```

### Дивіться також

-   [each()](function.each.md) \- Повертає поточну пару ключ/значення з масиву та зміщує його покажчик
-   [array()](function.array.md) \- створює масив
-   [extract()](function.extract.md) \- Імпортує змінні масиву до поточної таблиці символів
