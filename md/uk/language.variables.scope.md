---
navigation:
  - language.variables.predefined.md: «Зумовлені змінні
  - language.variables.variable.md: Змінні змінні »
  - index.md: PHP Manual
  - language.variables.md: Змінні
title: Область видимості змінної
---
## Область видимості змінної

Область видимості змінної – це контекст, у якому ця змінна визначена. У більшості випадків всі змінні PHP мають лише одну область видимості. Ця єдина область видимості охоплює також файли, що включаються (include) і необхідні (require). Наприклад:

```php
<?php
$a = 1;
include 'b.inc';
?>
```

Тут змінна $a буде доступна всередині скрипта b.inc. Однак визначення (тіло) функції користувача задає локальну область видимості даної функції. Будь-яка змінна за умовчанням обмежена локальною областю видимості функції. Наприклад:

```php
<?php
$a = 1; /* глобальная область видимости */

function test()
{
    echo $a; /* ссылка на переменную в локальной области видимости */
}

test();
?>
```

Цей скрипт не згенерує жодного висновку, оскільки вираз echo вказує на локальну версію змінної $a, а в межах цієї області видимості їй не було надано значення. Можливо ви помітили, що це трохи відрізняється від мови C у тому, що глобальні змінні C автоматично доступні функціям, якщо тільки вони не були перезаписані локальним визначенням. Це може викликати деякі проблеми, оскільки люди можуть ненароком змінити глобальну змінну. У PHP, якщо глобальна змінна буде використовуватися всередині функції, вона повинна бути оголошена глобальною всередині визначення функції.

### Ключове слово `global`

Спочатку приклад використання `global`

**Приклад #1 Використання `global`**

```php
<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
}

Sum();
echo $b;
?>
```

Наведений вище скрипт виведе `3`. Після визначення $a і $b всередині функції як global всі посилання на будь-яку з цих змінних будуть вказувати на їхню глобальну версію. Немає жодних обмежень на кількість глобальних змінних, які можуть оброблятися функцією.

Другий спосіб доступу до змінних глобальної області видимості - використання спеціального, що визначається PHP масиву [$GLOBALS](reserved.variables.globals.md). Попередній приклад може бути переписаний так:

**Приклад #2 Використання [$GLOBALS](reserved.variables.globals.md) замість global**

```php
<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

Sum();
echo $b;
?>
```

[$GLOBALS](reserved.variables.globals.md) - це асоціативний масив, ключем якого є ім'я, а значенням – вміст глобальної змінної. Зверніть увагу, що [$GLOBALS](reserved.variables.globals.md) існує в будь-якій області видимості, це пояснюється тим, що [$GLOBALS](reserved.variables.globals.md) є [суперглобальним](language.variables.superglobals.md). Нижче наведено приклад, що демонструє можливості суперглобальних змінних:

**Приклад #3 Суперглобальні змінні та область видимості**

```php
<?php
function test_superglobal()
{
    echo $_POST['name'];
}
?>
```

> **Зауваження**
> 
> Використання ключового слова `global` поза функцією не є помилкою. Він може бути використаний у файлі, який включається всередині функції.

### Використання статичних (`static`) змінних

Інший важливою особливістю області видимості змінної є *статична* змінна. Статична змінна існує тільки в локальній області видимості функції, але не втрачає свого значення, коли виконання програми виходить із цієї області видимості. Розглянемо наступний приклад:

**Приклад #4 Демонстрація необхідності статичних змінних**

```php
<?php
function test()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
```

Ця функція досить марна, оскільки при кожному виклику вона встановлює $a в `0` і виводить `0`. Інкремент змінної $a++ тут ​​не відіграє ролі, тому що при виході з функції змінна $a зникає. Щоб написати корисну функцію підрахунку, яка не втрачатиме поточного значення лічильника, змінна $a оголошується як static:

**Приклад #5 Приклад використання статичних змінних**

```php
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
```

Тепер $a буде проініціалізована тільки при першому виклику функції, а кожен виклик функції `test()` буде виводити значення $a та інкрементувати його.

Статичні змінні також дозволяють працювати з рекурсивними функціями. Рекурсивною є функція, що викликає саму себе. При написанні рекурсивної функції слід бути уважним, оскільки є можливість зробити рекурсію нескінченною. Ви повинні переконатися, що є адекватний спосіб завершення рекурсії. Наступна проста функція рекурсивно рахує до 10, використовуючи для визначення моменту зупинки статичну змінну $count:

**Приклад #6 Статичні змінні та рекурсивні функції**

```php
<?php
function test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
?>
```

Статичним змінним можна присвоїти значення, що є результатом виразу, але не можна використовувати для цього функцію, так це викликає помилку аналізу.

**Приклад #7 Оголошення статичних змінних**

```php
<?php
function foo() {
    static $int = 0;          // верно
    static $int = 1+2;        // верно
    static $int = sqrt(121);  // неверно (поскольку это функция)

    $int++;
    echo $int;
}
?>
```

Починаючи з PHP 8.1.0, коли метод, що використовує статичні змінні, успадковується (але не перевизначається), успадкований метод тепер використовуватиме статичні змінні спільно з батьківським методом. Це означає, що статичні змінні в методах тепер поводяться так само, як і статичні властивості.

**Приклад #8 Використання статичних змінних у успадкованих методах**

```php
<?php
class Foo {
    public static function counter() {
        static $counter = 0;
        $counter++;
        return $counter;
    }
}
class Bar extends Foo {}
var_dump(Foo::counter()); // int(1)
var_dump(Foo::counter()); // int(2)
var_dump(Bar::counter()); // int(3), до PHP 8.1.0 int(1)
var_dump(Bar::counter()); // int(4), до PHP 8.1.0 int(2)
?>
```

> **Зауваження**
> 
> Статичні оголошення обчислюються під час компіляції скрипту.

### Посилання з глобальними (`global`) та статичними (`static`) змінними

PHP використовує модифікатори змінних [static](language.variables.scope.md#language.variables.scope.static) і [global](language.variables.scope.md#language.variables.scope.global) як [посилання](language.references.md). Наприклад, реальна глобальна змінна, впроваджена область видимості функції вказівкою ключового слова `global`, Насправді створює посилання на глобальну змінну. Це може призвести до несподіваної поведінки, як це показано в наступному прикладі:

```php
<?php
function test_global_ref() {
    global $obj;
    $new = new stdclass;
    $obj = &$new;
}

function test_global_noref() {
    global $obj;
    $new = new stdclass;
    $obj = $new;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
```

Результат виконання цього прикладу:

```
NULL
object(stdClass)#1 (0) {
}
```

Аналогічно поводиться і вираз `static`. Посилання не зберігаються статично:

```php
<?php
function &get_instance_ref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        $new = new stdclass;
        // Присвоить ссылку статической переменной
        $obj = &$new;
    }
    if (!isset($obj->property)) {
        $obj->property = 1;
    } else {
        $obj->property++;
    }
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        $new = new stdclass;
        // Присвоить объект статической переменной
        $obj = $new;
    }
    if (!isset($obj->property)) {
        $obj->property = 1;
    } else {
        $obj->property++;
    }
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
```

Результат виконання цього прикладу:

```
Статический объект: NULL
Статический объект: NULL

Статический объект: NULL
Статический объект: object(stdClass)#3 (1) {
  ["property"]=>
  int(1)
}
```

Цей приклад демонструє, що при привласненні посилання статичної змінної вона не *запам'ятовується*, коли ви викликаєте функцію `&get_instance_ref()` вдруге.
