---
navigation:
  - migration70.md: « Миграция с PHP 5.6.x на PHP 7.0.x
  - migration70.new-features.html: Новая функциональность »
  - index.md: PHP Manual
  - migration70.md: Миграция с PHP 5.6.x на PHP 7.0.x
title: 'Зміни, що ламають зворотну сумісність'
---
## Зміни, що ламають зворотну сумісність

### Зміни в обробці помилок та винятків

Багато фатальних і поправних фатальних помилок було перероблено у винятки в PHP 7. Ці винятки успадковують клас [Error](class.error.md), який, у свою чергу, реалізує інтерфейс [Throwable](class.throwable.md) (Новий базовий інтерфейс, який успадковують усі винятки).

Це означає, що користувальницькі обробники помилок можуть не бути викликані, тому що замість виклику помилки, буде викинуто виняток (породжуючи нові фатальні помилки через неперехоплені винятки класу [Error](class.error.md)

Докладніше про те, як помилки працюють у PHP 7, можна знайти на сторінці [ошибки PHP 7](language.errors.php7.md). Це керівництво лише перераховує зміни, які можуть призвести до зворотної несумісності.

#### [setexceptionhandler()](function.set-exception-handler.md) більше не гарантує отримання об'єкта класу [Exception](class.exception.md)

Код, що реалізує реєстрацію обробника винятків за допомогою [setexceptionhandler()](function.set-exception-handler.md), використовуючи декларацію типу [Exception](class.exception.md), викличе фатальну помилку, якщо буде викинуто виняток [Error](class.error.md)

Якщо потрібна робота оброблювача в PHP 5 і 7, ви повинні прибрати оголошення класу з оброблювача. Якщо код передбачається використовувати тільки в PHP 7, то можна просто змінити тип з [Exception](class.exception.md) на [Throwable](class.throwable.md)

```php
<?php
// Только PHP 5. В PHP 7 может вызвать фатальную ошибку.
function handler(Exception $e) { ... }
set_exception_handler('handler');

// Будет работать PHP 5 и 7.
function handler($e) { ... }

// Только PHP 7.
function handler(Throwable $e) { ... }
?>
```

#### Вбудовані конструктори завжди викликають винятки у разі невдачі

Раніше деякі внутрішні класи повертали **`null`** або марний об'єкт, коли конструктор зазнав невдачі. Усі вбудовані класи тепер у такому разі викидатимуть виняток [Exception](class.exception.md), Як це вже роблять користувальницькі класи.

#### Помилки розбору кидають виняток класу [ParseError](class.parseerror.md)

Помилки розбору кидають виняток класу [ParseError](class.parseerror.md). Обробка помилок [eval()](function.eval.md) повинна включати блок [`catch`](language.exceptions.html#language.exceptions.catch), який ловитиме цю помилку.

#### Зміна суворості повідомлень ESTRICT

Всі повідомлення **`E_STRICT`** перекваліфіковані за іншими рівнями. Константа **`E_STRICT`** збережено, так що `error_reporting(E_ALL|E_STRICT)` не викликає помилки.

**Зміна суворості повідомлень **`E_STRICT`****

| Ситуация | Новый уровень/поведение |
| --- | --- |
| Індексування ресурсом | **`E_NOTICE`** |
| Абстрактні статичні методи | Повідомлення прибрано, не викликає помилки |
| "Перевизначення" конструктора | Повідомлення прибрано, не викликає помилки |
| Недотримання сигнатури під час наслідування | **`E_WARNING`** |
| Однакові (сумісні) властивості у двох різних трейтах | Повідомлення прибрано, не викликає помилки |
| Нестатичний доступ до статичної властивості | **`E_NOTICE`** |
| Тільки змінні можуть бути присвоєні за посиланням | **`E_NOTICE`** |
| Тільки змінні можуть бути передані за посиланням | **`E_NOTICE`** |
| Виклик нестатичного методу статично | **`E_DEPRECATED`** |

### Зміни в обробці змінних

PHP 7 використовує абстрактне синтаксичне дерево для аналізу файлів з вихідним кодом. Це дозволило внести безліч покращень у мову, які раніше були неможливі через обмеження парсера, що використовувався в попередніх версіях PHP, але призвело до видалення деяких особливих можливостей з міркувань узгодженості та порушило зворотну сумісність. Опис цих особливих випадків наведено у цій секції.

#### Зміни в обробці непрямих змінних, властивостей та методів

Непрямий доступ до змінних, властивостей та методів тепер розкривається строго зліва-направо, на противагу попередньому поєднанню зі спеціальних правил. У таблиці подано зміни у порядку розкриття.

**Стара та нова оцінка непрямих виразів**

| Выражение | Интерпретация PHP 5 | Интерпретация PHP 7 |
| --- | --- | --- |
| `$$foo['bar']['baz']` | `${$foo['bar']['baz']}` | `($$foo)['bar']['baz']` |
| `$foo->$bar['baz']` | `$foo->{$bar['baz']}` | `($foo->$bar)['baz']` |
| `$foo->$bar['baz']()` | `$foo->{$bar['baz']}()` | `($foo->$bar)['baz']()` |
| `Foo::$bar['baz']()` | `Foo::{$bar['baz']}()` | `(Foo::$bar)['baz']()` |

Код, який використовує старий порядок розкриття справа-ліворуч, повинен бути переписаний з використанням фігурних дужок (дивіться середній стовпець у таблиці вище). Це зробить код робочим як у PHP 5.x, так і в PHP 7.x.

Також це стосується і ключового слова [`global`](language.variables.scope.html#language.variables.scope.global). Для емуляції старої поведінки необхідно використовувати фігурні дужки:

```php
<?php
function f() {
    // Корректно только в PHP 5.
    global $$foo->bar;

    // Корректно в PHP 5 и 7.
    global ${$foo->bar};
}
?>
```

#### Зміна в обробці [list()](function.list.md)

##### [list()](function.list.md) більше не надає змінних у зворотному порядку

Тепер [list()](function.list.md) привласнює змінні тому порядку, як вони перераховані, а чи не у протилежному. Загалом це впливає тільки на випадки, коли [list()](function.list.md) використовується спільно з оператором масиву `[]`, як показано нижче:

```php
<?php
list($a[], $a[], $a[]) = [1, 2, 3];
var_dump($a);
?>
```

Результат виконання цього прикладу в PHP 5:

```
array(3) {
  [0]=>
  int(3)
  [1]=>
  int(2)
  [2]=>
  int(1)
}
```

Результат виконання цього прикладу в PHP 7:

```
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
}
```

Також хочеться відзначити, що покладатися на порядок присвоєння оператором [list()](function.list.md) - не найрозумніше рішення, оскільки він знову може змінитися у майбутньому.

##### Порожнє присвоєння [list()](function.list.md) більше не дозволено

Конструкція [list()](function.list.md) більше не може бути порожнім. Наступні приклади неприпустимі:

```php
<?php
list() = $a;
list(,,) = $a;
list($x, list(), $y) = $a;
?>
```

##### [list()](function.list.md) не може розкривати рядки

[list()](function.list.md) більше не може розкривати рядки. Використовуйте [strsplit()](function.str-split.md)

#### Змінено порядок масиву при автоматичному створенні через присвоєння за посиланням

Порядок створення елементів у масиві було змінено, коли елемент створюється шляхом присвоєння значення змінної, яку посилається цей елемент. Приклад:

```php
<?php
$array = [];
$array["a"] =& $array["b"];
$array["b"] = 1;
var_dump($array);
?>
```

Результат виконання цього прикладу в PHP 5:

```
array(2) {
  ["b"]=>
  &int(1)
  ["a"]=>
  &int(1)
}
```

Результат виконання цього прикладу в PHP 7:

```
array(2) {
  ["a"]=>
  &int(1)
  ["b"]=>
  &int(1)
}
```

#### Дужки навколо аргументів функції більше ні на що не впливають

У PHP 5 під час використання надлишкових дужок навколо аргументів функції не виводилося попередження, коли аргумент передавався за посиланням. Тепер попередження завжди виводиться.

```php
<?php
function getArray() {
    return [1, 2, 3];
}

function squareArray(array &$a) {
    foreach ($a as &$v) {
        $v **= 2;
    }
}

// Выведет предупреждение в PHP 7.
squareArray((getArray()));
?>
```

Результат виконання цього прикладу:

```
Notice: Only variables should be passed by reference in /tmp/test.php on line 13
```

### Зміни [foreach](control-structures.foreach.md)

Невеликі зміни були внесені до поведінки керуючої структури [foreach](control-structures.foreach.md). Основна зміна стосується модифікації масиву, що ітерується, і обробки його внутрішнього покажчика.

#### [foreach](control-structures.foreach.md) більше не змінює внутрішній покажчик масиву

До PHP 7 в процесі ітерації масиву [foreach](control-structures.foreach.md), його внутрішній покажчик змінювався. У прикладі нижче показано, що ця поведінка змінена:

```php
<?php
$array = [0, 1, 2];
foreach ($array as &$val) {
    var_dump(current($array));
}
?>
```

Результат виконання цього прикладу в PHP 5:

```
int(1)
int(2)
bool(false)
```

Результат виконання цього прикладу в PHP 7:

```
int(0)
int(0)
int(0)
```

#### [foreach](control-structures.foreach.md) за значеннями оперує копією масиву

Якщо [foreach](control-structures.foreach.md) використовується для стандартного перебору за значенням, він оперує копією масиву, а чи не самим масивом. Це означає, що зміни внесені в масив усередині циклу не торкнуться значення, що перебираються.

#### Для [foreach](control-structures.foreach.md) за посиланням покращили поведінку при ітерації

Коли [foreach](control-structures.foreach.md) використовується для перебору за посиланням, він краще відстежуватиме зміни, що вносяться в масив у процесі ітерації. Наприклад, додавання елементів до маси, що ітерується, призведе до того, що ці нові елементи потраплять у перебір:

```php
<?php
$array = [0];
foreach ($array as &$val) {
    var_dump($val);
    $array[1] = 1;
}
?>
```

Результат виконання цього прикладу в PHP 5:

```
int(0)
```

Результат виконання цього прикладу в PHP 7:

```
int(0)
int(1)
```

#### Ітерація об'єктів, що не реалізують [Traversable](class.traversable.md)

Ітерація об'єктів, що не реалізують [Traversable](class.traversable.md) тепер відбувається так само, як і ітерація масиву за посиланням. Так виходить через те, що [улучшения поведения при изменении Масива во время итерации](migration70.incompatible.html#migration70.incompatible.foreach.by-ref) також впливає при додаванні або видаленні властивостей об'єкта.

### Зміна в обробці значень типу int

#### Некоректна вісімкова нотація

Раніше вісімкові літерали, що містять некоректні числа, мовчки обрізалися (`0128` вважалися за `012`). Зараз у таких випадках буде видано помилку розбору.

#### Негативні побітові усунення

Тепер побитові зміщення на негативну величину кидатимуть виняток [ArithmeticError](class.arithmeticerror.md)

```php
<?php
var_dump(1 >> -1);
?>
```

Результат виконання цього прикладу в PHP 5:

```
int(0)
```

Результат виконання цього прикладу в PHP 7:

```
Fatal error: Uncaught ArithmeticError: Bit shift by negative number in /tmp/test.php:2
Stack trace:
#0 {main}
  thrown in /tmp/test.php on line 2
```

#### Побітові усунення з виходом з допустимого діапазону

Побітові зміщення (в обох напрямках) за межі ширини типу int завжди повертатимуть 0. Раніше поведінка залежала від архітектури.

#### Зміна у розподілі на нуль

Раніше використання нуля як дільника в операціях поділу (/) або поділу за модулем (%) призводило до помилки рівня EWARNING та поверненню значення **`false`**. Тепер оператор поділу повертає число з плаваючою точкою, що дорівнює +INF, -INF або NAN, як визначено в IEEE 754. Поділ по модулю замість помилки рівня EWARNING викидатиме виняток [DivisionByZeroError](class.divisionbyzeroerror.md)

```php
<?php
var_dump(3/0);
var_dump(0/0);
var_dump(0%0);
?>
```

Результат виконання цього прикладу в PHP 5:

```
Warning: Division by zero in %s on line %d
bool(false)

Warning: Division by zero in %s on line %d
bool(false)

Warning: Division by zero in %s on line %d
bool(false)
```

Результат виконання цього прикладу в PHP 7:

```
Warning: Division by zero in %s on line %d
float(INF)

Warning: Division by zero in %s on line %d
float(NAN)

PHP Fatal error:  Uncaught DivisionByZeroError: Modulo by zero in %s line %d
```

### Зміни у обробці рядків

#### Шістнадцяткові рядки більше не рахуються за числові

Рядки, що містять шістнадцяткові символи, більше не вважаються за числові. Приклад:

```php
<?php
var_dump("0x123" == "291");
var_dump(is_numeric("0x123"));
var_dump("0xe" + "0x1");
var_dump(substr("foo", "0x1"));
?>
```

Результат виконання цього прикладу в PHP 5:

```
bool(true)
bool(true)
int(15)
string(2) "oo"
```

Результат виконання цього прикладу в PHP 7:

```
bool(false)
bool(false)
int(0)

Notice: A non well formed numeric value encountered in /tmp/test.php on line 5
string(3) "foo"
```

Використовуйте функцію [filtervar()](function.filter-var.md) для перевірки рядка на утримання шістнадцяткового числа та перетворення цього рядка до значення типу int:

```php
<?php
$str = "0xffff";
$int = filter_var($str, FILTER_VALIDATE_INT, FILTER_FLAG_ALLOW_HEX);
if (false === $int) {
    throw new Exception("Некорректное целое число!");
}
var_dump($int); // int(65535)
?>
```

#### `\u{` може викликати помилки

У зв'язку з додаванням нового [синтаксису екранування кодів Unicode](migration70.new-features.html#migration70.new-features.unicode-codepoint-escape-syntax), рядки, що містять рядок `\u{`, що попереджає некоректну послідовність, може призвести до фатальної помилки. Для того, щоб цього уникнути, необхідно екранувати перший зворотний сліш.

### Віддалені функції

#### **callusermethod()** і **calluserметодarray()**

Функції, оголошені застарілими у PHP 4.1.0 на користь [calluserfunc()](function.call-user-func.html) і [calluserfuncarray()](function.call-user-func-array.html). Можливо, вам також буде цікаво розглянути можливість [звернення до функцій через змінні](functions.variable-functions.md) та/або оператор[](functions.arguments.html#functions.variable-arg-list)

#### Усі функції ereg

Усі функції `ereg` видалено. Рекомендована альтернатива - [PCRE](book.pcre.md)

#### Псевдоніми [mcrypt](book.mcrypt.md)

Застаріла функція **mcryptgenericend()** була видалена на користь функції [mcryptgenericdeinit()](function.mcrypt-generic-deinit.md)

Крім цього, застарілі функції **mcryptecb()** **mcryptcbc()** **mcryptcfb()** і **mcryptofb()** були видалені на користь використання [mcryptdecrypt()](function.mcrypt-decrypt.md) з відповідною константою **`MCRYPT_MODE_*`**

#### Усі функції модуля mysql

Усі функції [ext/mysql](book.mysql.md) були вилучені. Для вибору іншого MySQL API дивіться розділ [Вибір MySQL API](mysqlinfo.api.choosing.md)

#### Усі функції модуля mssql

Усі функції `ext/mssql` були вилучені.

-   [PDOSQLSRV](ref.pdo-sqlsrv.md)
-   [PDOODBC](ref.pdo-odbc.md)
-   [SQLSRV](book.sqlsrv.md)
-   [Unified ODBC API](book.uodbc.md)

#### Псевдоніми [intl](book.intl.md)

Застарілі псевдоніми **datefmtsettimezoneid()** і **IntlDateFormatter::setTimeZoneID()** були видалені на користь [datefmtsettimezone()](intldateformatter.settimezone.md) і [IntlDateFormatter::setTimeZone()](intldateformatter.settimezone.md) відповідно.

#### **setmagicquotesruntime()**

**setmagicquotesruntime()** та її псевдонім **magicquotesruntime()** були вилучені. Вони були оголошені застарілими в PHP 5.3.0 і повністю втратили свій сенс із відмовою від магічних лапок у PHP 5.4.0.

#### **setsocketblocking()**

Застарілий псевдонім **setsocketblocking()** був видалений на користь [streamsetblocking()](function.stream-set-blocking.md)

#### [dl()](function.dl.md) у PHP-FPM

Функція [dl()](function.dl.md) більше не можна використовувати в PHP-FPM. Однак вона збереглася в CLI і вбудованих SAPI.

#### Функції [ДД](book.image.md) Type1

Підтримка шрифтів PostScript Type1 видалена із модуля GD. Відповідно були видалені такі функції:

-   **imagepsbbox()**
-   **imagepsencodefont()**
-   **imagepsextendfont()**
-   **imagepsfreefont()**
-   **imagepsloadfont()**
-   **imagepsslantfont()**
-   **imagepstext()**

Замість них рекомендується використовувати шрифти TrueType та пов'язані з ними функції.

### Видалені директиви INI-файлу

#### Віддалені можливості

Наступні INI-директиви були видалені, оскільки пов'язані з ними функції також були видалені:

-   `always_populate_raw_post_data`
-   `asp_tags`

#### `xsl.security_prefs`

Директива `xsl.security_prefs` було видалено. Замість неї контролю налаштувань безпеки повинен викликатися метод [XsltProcessor::setSecurityPrefs()](xsltprocessor.setsecurityprefs.md) лише на рівні кожного процесора.

### Інші зміни, що стосуються зворотної сумісності

#### Нові об'єкти не можуть надаватися за посиланням

Результат оператора [`new`](language.oop5.basic.html#language.oop5.basic.new) більше не може бути присвоєний змінною за посиланням:

```php
<?php
class C {}
$c =& new C;
?>
```

Результат виконання цього прикладу в PHP 5:

```
Deprecated: Assigning the return value of new by reference is deprecated in /tmp/test.php on line 3
```

Результат виконання цього прикладу в PHP 7:

```
Parse error: syntax error, unexpected 'new' (T_NEW) in /tmp/test.php on line 3
```

#### Некоректні імена класів, інтерфейсів та трейтів

Наступні імена не можна використовувати для класів, інтерфейсів та трейтів:

-   bool
-   int
-   float
-   string
-   **`null`**
-   **`true`**
-   **`false`**

Більше того, такі імена не повинні використовуватися. Вони не приведуть до помилки в PHP 7.0, але вони зарезервовані на майбутнє і мають вважатися застарілими.

-   resource
-   object
-   [mixed](language.types.declarations.html#language.types.declarations.mixed)
-   numeric

#### Видалені PHP-теги ASP та script

Видалено підтримку використання тегів ASP та script для визначення коду PHP.

**Видалені теги ASP та script**

| Открывающий тег | Закрывающий тег |
| --- | --- |
| `<%` | `%>` |
| `<%=` | `%>` |
| `<script language="php">` | `</script>` |

#### Видалено дзвінки з невідповідного контексту

[Раніше визнані застарілими у PHP 5.6](migration56.deprecated.html#migration56.deprecated.incompatible-context) статичні виклики нестатичних методів з невідповідного контексту тепер призведуть до того, що для методу, що викликається, змінна `$this` буде не визначено та буде виведено попередження.

```php
<?php
class A {
    public function test() { var_dump($this); }
}

// Обратите вимание: НЕ расширяет класс A
class B {
    public function callNonStaticMethodOfA() { A::test(); }
}

(new B)->callNonStaticMethodOfA();
?>
```

Результат виконання цього прикладу в PHP 5.6:

```
Deprecated: Non-static method A::test() should not be called statically, assuming $this from incompatible context in /tmp/test.php on line 8
object(B)#1 (0) {
}
```

Результат виконання цього прикладу в PHP 7:

```
Deprecated: Non-static method A::test() should not be called statically in /tmp/test.php on line 8

Notice: Undefined variable: this in /tmp/test.php on line 3
NULL
```

#### [yield](language.generators.syntax.html#control-structures.yield) тепер право-асоціативний оператор

Конструкція [yield](language.generators.syntax.html#control-structures.yield) більше не вимагає обертання в дужки і є право-асоціативним оператором з пріоритетом між `print` і `=>`. Це може призвести до зміни поведінки:

```php
<?php
echo yield -1;
// Ранее интерпретировалось так
echo (yield) - 1;
// А теперь так
echo yield (-1);

yield $foo or die;
// Ранее интерпретировалось так
yield ($foo or die);
// А теперь так
(yield $foo) or die;
?>
```

Дужки можуть бути використані для усунення неоднозначності у таких випадках.

#### Функції не можуть мати декілька параметрів з однаковими іменами

Більше не можна визначити кілька параметрів з однаковими іменами. Наприклад, така функція видасть помилку рівня **`E_COMPILE_ERROR`**

```php
<?php
function foo($a, $b, $unused, $unused) {
    //
}
?>
```

#### Функції, що працюють із аргументами, тепер повертають їх *поточні* значення

**funcgetarg()** [funcgetargs()](function.func-get-args.html) [debugbacktrace()](function.debug-backtrace.md) і трасування винятків повертають не вихідні передані значення, а поточні значення, які можуть бути змінені.

```php
<?php
function foo($x) {
    $x++;
    var_dump(func_get_arg(0));
}
foo(1);?>
```

Результат виконання цього прикладу в PHP 5:

```
1
```

Результат виконання цього прикладу в PHP 7:

```
2
```

#### Оператор switch більше не може мати декілька блоків default

Більше неможливо встановити більше одного блоку default в операторі switch. Наприклад, така конструкція видасть помилку **`E_COMPILE_ERROR`**

```php
<?php
switch (1) {
    default:
    break;
    default:
    break;
}
?>
```

#### Видалено $HTTPRAWPOSTDATA

$HTTPRAWPOSTDATA більше недоступне. Замість нього використовуйте потік [`php://input`](wrappers.php.html#wrappers.php.input)

#### Заборонені коментарі `#` в INI-файлах

Підтримка префіксу коментаря `#` в INI-файлах видалено. Використовуйте префікс `;` замість нього. Ця зміна стосується як php.ini, так і файлів, що обробляються функціями [parseinifile()](function.parse-ini-file.html) і [parseinistring()](function.parse-ini-string.md)

#### Модуль JSON замінено на JSOND

Модуль JSON замінений на JSOND, що породжує три невеликі зворотні несумісності. Перше - числа не повинні закінчуватися на крапку (тобто `34.` має бути замінено на `34.0` або `34`). Друге – при використанні наукової нотації, експонента `e` не повинна слідувати відразу за десятковою точкою (тобто `3.e3` потрібно поміняти на `3.0e3` або `3e3`). Третє - порожній рядок більше не вважається коректним JSON.

#### Помилки внутрішніх функцій при переповненні

Раніше вбудовані функції могли тихо обрізати числа, отримані при наведенні типу float до integer, якщо float був більшим, ніж здатний вмістити integer. Тепер же видаватиметься помилка EWARNING та повертатися **`null`**

#### Виправлення для значень користувальницького оброблювача сесії, що повертаються.

Будь-які предикатні функції, реалізовані за допомогою користувальницьких обробників сесії та повертають **`false`** або `-1`, викликають фатальну помилку Якщо ці функції повернуть будь-яке значення, крім логічного, `-1` або `0`, вони будуть вважатися завершеними з помилкою та викличуть попередження EWARNING.

#### Порядок сортування однакових елементів

Внутрішній алгоритм сортування був змінений, що може позначитися на відмінному від попереднього сортованого порядку елементів, визначених як однакові.

> **Зауваження**
> 
> Не покладайтеся на порядок однакових елементів, оскільки він може змінитися.

#### Зміна порядку обробки операторів break та switch

Оператори `break` і `continue` поза циклом або керуючою структурою `switch` тепер обробляються під час компіляції, а не під час виконання, як це було раніше, тому видають помилки рівня **`E_COMPILE_ERROR`**

#### Mhash більше не є модулем

Модуль Mhash повністю інтегрований у модуль [Hash](book.hash.md). Таким чином, тепер не можна визначити доступність підтримки Mhash за допомогою функції [extensionloaded()](function.extension-loaded.html); замість неї використовуйте [functionexists()](function.function-exists.html). Крім того, Mhash більше не виводитиме за допомогою [getloadedextensions()](function.get-loaded-extensions.md) та подібних функцій.

#### declare(ticks)

Директива [declare(ticks)](control-structures.declare.html#control-structures.declare.ticks) більше не проникає у різні модулі компіляції.
