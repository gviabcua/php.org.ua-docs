---
navigation:
  - session.examples.md: « Приклади
  - session.idpassing.md: Передача ідентифікатора сесії »
  - index.md: PHP Manual
  - session.examples.md: Приклади
title: Основи використання
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
## Основи використання

Сесії є простим способом зберігання інформації окремих користувачів з унікальним ідентифікатором сесії. Це може бути використане для збереження стану між запитами сторінок. Ідентифікатори сесій зазвичай відправляються браузеру через сесійний cookie та використовуються для отримання наявних даних сесії. Відсутність ідентифікатора сесії або сесійного cookie повідомляє PHP про те, що необхідно створити нову сесію та згенерувати новий ідентифікатор сесії.

Сесії використовують просту технологію. Коли сесія створена, PHP або отримуватиме існуючу сесію, використовуючи переданий ідентифікатор (зазвичай із сесійного cookie) або, якщо нічого не передавалося, буде створена нова сесія. PHP заповнить суперглобальну змінну [$\_SESSION](reserved.variables.session.md) сесійною інформацією після того, як буде запущено сесію. Коли PHP завершує роботу, він автоматично серіалізує вміст суперглобальної змінної [$\_SESSION](reserved.variables.session.md) та відправить для збереження, використовуючи сесійний оброблювач для запису сесії.

По умолчанию PHP использует внутренний обработчик`files` для збереження сесій, який встановлений в INI-змінній [session.save\_handler](session.configuration.md#ini.session.save-handler). Цей обробник зберігає дані на сервері в директорії, вказаній у конфігураційній директиві [session.save\_path](session.configuration.md#ini.session.save-path)

Сесії можуть запускатися вручну за допомогою функції [session\_start()](function.session-start.md). Якщо директива [session.auto\_start](session.configuration.md#ini.session.auto-start)установлена в , сесія автоматично запуститься на початку запиту.

Сесія зазвичай завершує свою роботу, коли PHP закінчує виконувати скрипт, але може бути завершена і вручну за допомогою функції [session\_write\_close()](function.session-write-close.md)

**Приклад #1 Реєстрація змінної за допомогою [$\_SESSION](reserved.variables.session.md)**

```php
<?php
session_start();
if (!isset($_SESSION['count'])) {
  $_SESSION['count'] = 0;
} else {
  $_SESSION['count']++;
}
?>
```

**Приклад #2 Скасування оголошення змінної за допомогою [$\_SESSION](reserved.variables.session.md)**

```php
<?php
session_start();
unset($_SESSION['count']);
?>
```

**Застереження**

НЕ ОЧИЩАЙТЕ[$\_SESSION](reserved.variables.session.md) повністю, використовуючи `unset($_SESSION)`, так як це відключити можливість реєстрації сесійних змінних через супер глобальну змінну [$\_SESSION](reserved.variables.session.md)

**Увага**

Ви не можете використовувати посилання в сесійних змінних, так як немає реального способу відновлення посилання до іншої змінної.

> **Зауваження** :
> 
> Сесії, що використовують файли (за замовчуванням у PHP), блокують файл сесії відразу при відкритті сесії функцією [session\_start()](function.session-start.md)или косвенно при указании[session.auto\_start](session.configuration.md#ini.session.auto-start). Після блокування, жодний інший скрипт не може отримати доступ до цього ж файлу сесії, доки він не буде закритий або при завершенні скрипту або виклику функції [session\_write\_close()](function.session-write-close.md)
> 
> Швидше за все це стане проблемою для сайтів, які активно використовують AJAX та роблять кілька одночасних запитів. Найпростішим шляхом вирішити цю проблему буде виклик функції [session\_write\_close()](function.session-write-close.md) відразу ж як тільки всі необхідні зміни у сесії будуть зроблені, переважно ближче до початку роботи скрипту. Також можна використовувати інший механізм сесії, що підтримує конкурентний доступ.
