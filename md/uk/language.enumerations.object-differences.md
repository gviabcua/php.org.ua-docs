Відмінності від об'єктів

-   [« Значення перерахування у постійних виразах](language.enumerations.expressions.md)
    
-   [Список значений »](language.enumerations.listing.md)
    
-   [PHP Manual](index.md)
    
-   [Перечисления](language.enumerations.md)
    
-   Відмінності від об'єктів
    

## Відмінності від об'єктів

Хоча перерахування побудовані на класах та об'єктах, вони не підтримують усі функціональні можливості, пов'язані з об'єктами. Зокрема, варіантам перерахувань заборонено мати стан.

-   Конструктори та деструктори заборонені.
-   Спадкування не підтримується. Переліки не можуть успадковувати або успадковуватися.
-   Статичні властивості чи властивості об'єкта не допускаються.
-   Клонування варіанта перерахування не підтримується, оскільки варіанти мають бути одноелементними екземплярами.
-   [Магічні методи](language.oop5.magic.md), крім наведених нижче, заборонені.
-   Переліки завжди повинні бути оголошені до їхнього використання.

Доступні такі функціональні можливості об'єкта, які поводяться так само, як і для будь-якого іншого об'єкта:

-   Методи public, private і protected.
-   Статичні методи public, private і protected.
-   Константи public, private і protected.
-   Переліки можуть реалізовувати будь-яку кількість інтерфейсів.
-   До перерахувань та варіантів можуть бути додані [атрибути](language.attributes.md). Цільовий фільтр **`TARGET_CLASS`** включає самі перерахування. Цільовий фільтр **`TARGET_CLASS_CONST`** включає варіанти перерахувань.
-   Магічні методи [call](language.oop5.overloading.html#object.call) [callStatic](language.oop5.overloading.html#object.callstatic), і [invoke](language.oop5.magic.html#object.invoke)
-   Константи **`__CLASS__`** і **`__FUNCTION__`** поводяться як завжди.

Магічна константа `::class` для типу перерахування оцінює ім'я типу, включаючи будь-який простір імен, так само, як об'єкт. Магічна константа `::class` в екземплярі варіанта також оцінюється як тип перерахування, оскільки вона є екземпляром цього типу.

Крім того, варіанти перерахування не можуть бути створені безпосередньо за допомогою `new` або за допомогою [ReflectionClass::newInstanceWithoutConstructor()](reflectionclass.newinstancewithoutconstructor.md). Обидва способи призведуть до помилки.

```php
<?php
$clovers = new Suit();
// Error: Cannot instantiate enum Suit
$horseshoes = (new ReflectionClass(Suit::class))->newInstanceWithoutConstructor()
// Error: Cannot instantiate enum Suit
?>
```