Режими роботи періодичних спостерігачів

-   [« Watcher callbacks](ev.watcher-callbacks.html)
    
-   [Ev »](class.ev.html)
    
-   [PHP Manual](index.html)
    
-   [Ev](book.ev.html)
    
-   Режими роботи періодичних спостерігачів
    

# Режими роботи періодичних спостерігачів

Спостерігачі [EvPeriodic](class.evperiodic.html) працюють у різних режимах залежно від значення параметрів `offset` `interval` і `reschedule_cb`

1.  *Абсолютний таймер*. У цьому режимі `interval` **`0`** `reschedule_cb` **`null`**. Таймер просто спрацює один раз у задане в `offset` час. Він не компенсує стрибки часу і якщо вказано спрацювати в *1 Січня 2014*, то він спрацює коли системний час дорівнюватиме або більше цього значення.
    
2.  *Таймер із фіксованим інтервалом*. У цьому режимі `interval` > **`0`**, а `reschedule_cb` **`null`**. Кожне подальше спрацювання буде рівно через `offset` **`N`** `interval` (де **`N`** - ціле число), незважаючи на стрибки часу.
    
    Це можна використовувати для створення таймерів, які не розходяться із системним часом:
    
    ```php
    <?php
    $hourly = EvPeriodic(0, 3600, NULL, function () {
      echo "один раз в час\n";
    });
    ?>
    ```
    
    Це не означає, що між спрацюваннями завжди буде рівно **`3600`** секунд. Це означає, що callback-функція буде викликана тільки коли системний годинник покаже повну годину (*UTC*
    
    У цьому режимі, [EvPeriodic](class.evperiodic.html) буде намагатися запустити callback-функцію в наступний доступний час, коли time = `offset` `mod` `interval`), незалежно від стрибків часу.
    
3.  *Режим ручного перевизначення часу спрацьовування*. У цьому режимі `reschedule_cb` є коректним параметром типу [callable](language.types.callable.html)
    
    `interval` і `offset` ігноруються. Натомість, при кожному спрацьовуванні, спостерігач запускає callback-функцію (`reschedule_cb`) з двома аргументами, посиланням на спостерігача та часом.
    
    Ця callback-функція ніколи *не повинна* зупиняти або знищувати цей або будь-який інший періодичний спостерігач і *не повинна* викликати функції та методи подієвого циклу. Для зупинки можна повернути дуже велику кількість, наприклад, **`1e30`**і зупинити спостерігач за межами цієї функції. Для цього можна використати спостерігачів [EvPrepare](class.evprepare.html)
    
    Ця функція повинна повернути наступний час спрацьовування, ґрунтуючись на переданому значенні часу (тобто найменше значення часу більше або дорівнює другому аргументу). Зазвичай вона викликається перед тим, як буде викликана основна callback-функція спостерігача, але може пізніше.
    
    **Приклад #1 Використання спостерігача з ручним перевизначенням часу спрацьовування**
    
    ```php
    <?php
    // Срабатывать каждые 10.5 секунд
    
    function reschedule_cb ($watcher, $now) {
       return $now + (10.5. - fmod($now, 10.5));
    }
    
    $w = new EvPeriodic(0., 0., "reschedule_cb", function ($w, $revents) {
       echo time(), PHP_EOL;
    });
    
    Ev::run();
    ?>
    ```