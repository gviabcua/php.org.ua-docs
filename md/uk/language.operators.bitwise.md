- [« Оператор присвоєння](language.operators.assignment.md)
- [Оператори порівняння »](language.operators.comparison.md)

- [PHP Manual](index.md)
- [Оператори](language.operators.md)
- Побітові оператори

## Побітові оператори

Побітові оператори дозволяють зчитувати та встановлювати конкретні біти
цілих чисел.

| приклад      | Назва                                                                                                        | Результат                                                                                                 |
| ------------ | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------- |
| **$a & $b**  | І                                                                                                            | Встановлюються тільки ті біти, які встановлені і в $a, і в $b.                                            |                                                                                                                  |                                                                                                           
| **$a         | $b**                                                                                                         | Або                                                                                                       | Встановлюються ті біти, які встановлені в $a або $b.                                                      
| **$a^$b**    | Виключне або                                                                                                 | Встановлюються тільки ті біти, які встановлені або тільки в $a, або тільки в $b, але не в обох одночасно. |
| **~ $a**     | Заперечення                                                                                                  | Встановлюються ті біти, які не встановлені в $a, і навпаки.                                               |
| **$a << $b** | Зсув ліворуч Усі біти змінної $a зсуваються на $b позицій вліво (кожна позиція має на увазі "множення на 2") |                                                                                                           |
| **$a >> $b** | Зсув праворуч                                                                                                | Усі біти змінної $a зсуваються на $b позицій вправо (кожна позиція має на увазі "розподіл на 2")          |

**Побітові оператори**

Побітове зрушення в PHP - це арифметична операція. Біти, зрушені за
межі числа відкидаються. Зсув вліво доповнює число нулями праворуч,
зрушуючи в той же час знаковий біт числа вліво, що означає що знак
операнда не зберігається. Зсув праворуч зберігає копію зрушеного
знакового біта зліва, що означає, що знак операнда зберігається.

Використовуйте дужки для забезпечення необхідного [пріоритету операторов](language.operators.precedence.md). Наприклад,
`$a & $b == true` спочатку перевіряє на рівність, а потім виконує
побітове та; тоді як `($a & $b) == true` спочатку виконує побітове
і, а потім виконує перевірку на рівність.

Якщо обидва операнди для `&`, `|` і `^` рядка, то операція буде
проводитися з кодами ASCII всіх символів рядка і в результаті поверне
рядок. У всіх інших випадках, обидва операнди будуть [перетворені до цілому](language.types.integer.md#language.types.integer.casting) та
результатом буде ціле число.

Якщо операнд для рядка, то операція буде проводитися з кодами
ASCII всіх символів рядка і в результаті поверне рядок, в іншому випадку
як операнд, і результат, вважатимуться цілими.

Обидва операнди і результат виконання `<<` та `>>` завжди вважаються за
ціле.

``` literallayout
Опція налаштувань PHP error_reporting використовує побітові значення, забезпечуючи
реальну демонстрацію видалення значень бітів. Щоб показати всі помилки, крім
зауважень, інструкції у файлі php.ini пропонують використовувати:
E_ALL & ~E_NOTICE

````

``` literallayout
Починаємо зі значення E_ALL:
00000000000000000111011111111111
Потім беремо значення E_NOTICE...
00000000000000000000000001000
... та інвертуємо його за допомогою ~:
111111111111111111111111111110111
Нарешті, використовуємо побітове І (&), щоб встановити тільки ті біти,
які встановлені в одиницю в обох значеннях:
00000000000000000111011111110111

````

``` literallayout
Інший спосіб досягти цього - використовувати ВИКЛЮЧНЕ АБО (XOR, ^),
щоб отримати лише ті біти, які встановлені в одиницю
або тільки в одному, або тільки в іншому значенні:
E_ALL ^ E_NOTICE

````

``` literallayout
Опція error_reporting також може бути використана для демонстрації
установки бітів Показати тільки помилки та помилки, що обробляються, можна
наступним чином:
E_ERROR | E_RECOVERABLE_ERROR

````

``` literallayout
Тут ми поєднуємо E_ERROR
000000000000000000000000000001
і
000000000000000000000000000000
за допомогою оператора АБО (|),
щоб отримати біти, встановлені хоча б в одному операнді:
0000000000000000001000000000001

````

**Приклад #1 Побітові операції І, АБО і ВИКЛЮЧНЕ АБО (AND, OR і XOR)
над цілими числами**

` <?php/* * Не звертайте уваги на це верхній розділ коду, * це просто форматування для більш ясного висновку. */$format==''(%1$2d==%1$04b)==(%2$2d==%2$04b)'         . ' %3$s (%4$2d = %4$04b)' . "
";echo <<<EOH ----------   ----------- -- ---------- результат      значення      оп тест ------ ----  ----------- -- ----------EOH;/* * От самі приклади. */$values = array(0, 1, 2, 4 , 8);$test = 1 + 4;echo "
Побітове І (AND)
";foreach ($values as $value) {   $result = $value & $test;    printf($format, $result, $value, '&', $test);}echo 
Побітове (включає) АБО (OR)
";foreach ($values as $value) {   $result = $value | $test;    printf($format, $result, $value, '|', $test);}echo 
Побітове ВИКЛЮЧАЄ АБО (XOR)
";foreach ($values as $value) {   $result = $value ^ $test;    printf($format, $result, $value, '^', $test);}?> `

Результат виконання цього прикладу:

---------- ----------- -- ----------
результат значення оп тест
---------- ----------- -- ----------
Побітове І (AND)
(0 = 0000) = (0 = 0000) & (5 = 0101)
(1 = 0001) = (1 = 0001) & (5 = 0101)
(0 = 0000) = (2 = 0010) & (5 = 0101)
(4 = 0100) = (4 = 0100) & (5 = 0101)
(0 = 0000) = (8 = 1000) & (5 = 0101)

Побітове (включає) АБО (OR)
(5 = 0101) = (0 = 0000) | (5 = 0101)
(5 = 0101) = (1 = 0001) | (5 = 0101)
(7 = 0111) = (2 = 0010) | (5 = 0101)
(5 = 0101) = (4 = 0100) | (5 = 0101)
(13 = 1101) = (8 = 1000) | (5 = 0101)

Побітове ВИКЛЮЧНЕ АБО (XOR)
(5 = 0101) = (0 = 0000) ^ (5 = 0101)
(4 = 0100) = (1 = 0001) ^ (5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
(1 = 0001) = (4 = 0100) ^ (5 = 0101)
(13 = 1101) = (8 = 1000) ^ (5 = 0101)

**Приклад #2 Побітова операція ВИКЛЮЧНЕ АБО (XOR) над рядками**

`<?phpecho 12 ^ 9; // Виводить '5'echo"12"^^"9"; // Виводить символ Backspace (ascii 8)                  // ('1' (ascii 49))| // Виводить ascii-значення #0 #4 #0 #0 #0               /             // Виводить 1               // 2 ^ ((int)"3") == 1echo "2" ^ 3; // Виводить 1               //((int)"2") ^ 3 == 1?> `

**Приклад #3 Побітовий зсув над цілими числами**

`<?php/* * Кілька прикладів. */echo "
--- СДВИГ ВПРАВО НАД ПІДСТАВНИМИ Цілими ЧИСЛАМИ ---
$val = 4;$places = 1;$res = $val >> $places;p($res, $val, '>>', $places, 'зліва вставлена копія знакового біта');$val = 4;$places = 2;$res = $val >> $places;p($res, $val, '>>', $places);$val = 4;$places = 3;$res = $val >> $places;p($res, $val, '>>', $places, 'бити висунуті за правий край');$val = 4;$places = 4;$res = $val >> $places ;p($res, $val, '>>', $places, 'те ж, і і вище; не можна зрушити далі 0');echo ""
--- СДВИГ ВПРАВО НАД ЗАГАДНИМИ ЦИЛИМИ ЧИСЛАМИ ---
$val = -4;$places = 1;$res = $val >> $places;p($res, $val, '>>', $places, 'зліва була вставлена копія знакового біта');$$ val = -4;$places = 2;$res = $val >> $places;p($res, $val, '>>', $places, 'бити були висунуті за правий край');$val = 4. "
--- СДВИГ ВЛІВО НАД ПІДСТАВНИМИ Цілими ЧИСЛАМИ ---
$val = 4;$places = 1;$res = $val << $places;p($res, $val, '<<', $places, 'правий край був доповнений нулями');$val = 4;$places = (PHP_INT_SIZE * 8) - 4;$res = $val << $places;p($res, $val, '<<', $places);$val = 4;$places = (PHP_INT * 8) - 3;$res = $val << $places;p($res, $val, '<<', $places, 'знакові біти були висунуті');$val = 4;$places = (PHP_INT * 8) - 2;$res = $val << $places;p($res, $val, '<<', $places, 'біти були висунуті за лівий край');echo ""
--- СДВИГ ВЛІВО НАД НЕГАТИВНИМИ Цілими ЧИСЛАМИ ---
$val = -4;$places = 1;$res = $val << $places;p($res, $val, '<<', $places, 'правий край був доповнений нулями');$val = -4;$places = (PHP_INT_SIZE * 8) - 3;$res = $val << $places;p($res, $val, '<<', $places);$val = -4;$places = (PHP_INT_SIZE * 8) - 2;$res = $val << $places;p($res, $val, '<<', $places, 'бити були висунуті за лівий край, в  | * * Не звертайте уваги на цей нижній розділ кода, * це просто форматування для ясного виводу. */function p($res, $val, $op,          ' . (PHP_INT_SIZE * 8) . "b
";    printf("Вираз: %d = %d %s %d
", $res, $val, $op, $places);   echo " Десятичний вигляд:
";   printf(" val=%d
", $val);   printf("res=%d
", $res);    echo " Двійковий вигляд:
";   printf('  val=' . $format, $val);    printf('  res=' . $format, $res);    if ($note) Я|                
";    }    echo "
";}?> `

Результат виконання цього прикладу на 32-бітних машинах:


--- Сдвиг вправо над позитивними цілими числами ---
Вираз: 2 = 4 >> 1
Десятковий вигляд:
val=4
res=2
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000000010
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: 1 = 4 >> 2
Десятковий вигляд:
val=4
res=1
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000000001

Вираз: 0 = 4 >> 3
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000000000
ПРИМІТКА: біти були висунуті за правий край

Вираз: 0 = 4 >> 4
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000000000
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі


--- ЗРУХ ВПРАВО НА ЗАГАЛЬНИХ ЦІЛІХ ЧИСЛАХ ---
Вираз: -2 = -4 >> 1
Десятковий вигляд:
val=-4
res=-2
Двійковий вигляд:
val=111111111111111111111111111111100
res=111111111111111111111111111111110
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: -1 = -4 >> 2
Десятковий вигляд:
val=-4
res=-1
Двійковий вигляд:
val=111111111111111111111111111111100
res=111111111111111111111111111111111
ПРИМІТКА: біти були висунуті за правий край

Вираз: -1 = -4 >> 3
Десятковий вигляд:
val=-4
res=-1
Двійковий вигляд:
val=111111111111111111111111111111100
res=111111111111111111111111111111111
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі -1


--- Сдвиг вліво над позитивними цілими числами ---
Вираз: 8 = 4 << 1
Десятковий вигляд:
val=4
res=8
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000001000
ПРИМІТКА: правий край був доповнений нулями

Вираз: 1073741824 = 4 << 28
Десятковий вигляд:
val=4
res=1073741824
Двійковий вигляд:
val=000000000000000000000000000100
res=010000000000000000000000000000

Вираз: -2147483648 = 4 << 29
Десятковий вигляд:
val=4
res=-2147483648
Двійковий вигляд:
val=000000000000000000000000000100
res=100000000000000000000000000000
ПРИМІТКА: знакові біти були висунуті

Вираз: 0 = 4 << 30
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=000000000000000000000000000100
res=000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край


--- Сдвиг вліво над негативними цілими числами ---
Вираз: -8 = -4 << 1
Десятковий вигляд:
val=-4
res=-8
Двійковий вигляд:
val=111111111111111111111111111111100
res=111111111111111111111111111111000
ПРИМІТКА: правий край був доповнений нулями

Вираз: -2147483648 = -4 << 29
Десятковий вигляд:
val=-4
res=-2147483648
Двійковий вигляд:
val=111111111111111111111111111111100
res=100000000000000000000000000000

Вираз: 0 = -4 << 30
Десятковий вигляд:
val=-4
res=0
Двійковий вигляд:
val=111111111111111111111111111111100
res=000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край, включаючи знаковий біт

Результат виконання цього прикладу на 64-бітних машинах:


--- Сдвиг вправо над позитивними цілими числами ---
Вираз: 2 = 4 >> 1
Десятковий вигляд:
val=4
res=2
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=00000000000000000000000000000000000000000000000000000000
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: 1 = 4 >> 2
Десятковий вигляд:
val=4
res=1
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=0000000000000000000000000000000000000000000000000000000000

Вираз: 0 = 4 >> 3
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за правий край

Вираз: 0 = 4 >> 4
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=000000000000000000000000000000000000000000000000000000000
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі


--- Сдвиг вправо над негативними цілими числами ---
Вираз: -2 = -4 >> 1
Десятковий вигляд:
val=-4
res=-2
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=11111111111111111111111111111111111111111111111111111111111111110
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: -1 = -4 >> 2
Десятковий вигляд:
val=-4
res=-1
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=11111111111111111111111111111111111111111111111111111111111111111
ПРИМІТКА: біти були висунуті за правий край

Вираз: -1 = -4 >> 3
Десятковий вигляд:
val=-4
res=-1
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=11111111111111111111111111111111111111111111111111111111111111111
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі -1


--- Сдвиг вліво над позитивними цілими числами ---
Вираз: 8 = 4 << 1
Десятковий вигляд:
val=4
res=8
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=00000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: правий край був доповнений нулями

Вираз: 4611686018427387904 = 4 << 60
Десятковий вигляд:
val=4
res=4611686018427387904
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=010000000000000000000000000000000000000000000000000000000

Вираз: -9223372036854775808 = 4 << 61
Десятковий вигляд:
val=4
res=-9223372036854775808
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=100000000000000000000000000000000000000000000000000000000
ПРИМІТКА: знакові біти були висунуті

Вираз: 0 = 4 << 62
Десятковий вигляд:
val=4
res=0
Двійковий вигляд:
val=00000000000000000000000000000000000000000000000000000000000000000000
res=000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край


--- Сдвиг вліво над негативними цілими числами ---
Вираз: -8 = -4 << 1
Десятковий вигляд:
val=-4
res=-8
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=11111111111111111111111111111111111111111111111111111111111111000
ПРИМІТКА: правий край був доповнений нулями

Вираз: -9223372036854775808 = -4 << 61
Десятковий вигляд:
val=-4
res=-9223372036854775808
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=100000000000000000000000000000000000000000000000000000000

Вираз: 0 = -4 << 62
Десятковий вигляд:
val=-4
res=0
Двійковий вигляд:
val=11111111111111111111111111111111111111111111111111111111111111100
res=000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край, включаючи знаковий біт

**Увага**

Використовуйте функції з модуля [gmp](book.gmp.md) для побітових
операцій над числами, більшими за `PHP_INT_MAX`.

### Дивіться також

- [pack()](function.pack.md)
- [unpack()](function.unpack.md)
- [gmp_and()](function.gmp-and.md)
- [gmp_or()](function.gmp-or.md)
- [gmp_xor()](function.gmp-xor.md)
- [gmp_testbit()](function.gmp-testbit.md)
- [gmp_clrbit()](function.gmp-clrbit.md)
