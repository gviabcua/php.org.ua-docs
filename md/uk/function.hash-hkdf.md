---
navigation:
  - function.hash-final.md: « hash\_final
  - function.hash-hmac-algos.md: hash\_hmac\_algos »
  - index.md: PHP Manual
  - ref.hash.md: Функції Hash
title: hash\_hkdf
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# hash\_hkdf

(PHP 7 >= 7.1.2, PHP 8)

hash\_hkdf — Формування ключа HKDF для заданих вхідних даних

### Опис

```methodsynopsis
hash_hkdf(    string $algo,    string $key,    int $length = 0,    string $info = "",    string $salt = ""): string
```

### Список параметрів

`algo`

Ім'я вибраного хешируючого алгоритму (наприклад, "sha256", "sha512", "haval160,4" і т.д.) Список підтримуваних алгоритмів можна переглянути в описі функції [hash\_algos()](function.hash-algos.md)

> **Зауваження** :
> 
> Не криптографічні функції, що хешують, не допускаються.

`key`

Вхідні дані (необроблені бінарні дані). Не може бути порожнім.

`length`

Вибрана довжина виведення у байтах. Не може бути більш ніж у 255 разів більше розміру обраної функції, що хешує.

Якщо `length`установлено как , то висновок по довжині дорівнюватиме розміру обраної функції, що хешує.

`info`

Інформаційний рядок, специфічний для застосування/контексту.

`salt`

Сіль, що використовується для формування ключа.

Хоча необов'язково, але додавання випадкової солі значно покращує силу HKDF.

### Значення, що повертаються

Повертає рядок, що містить необроблені бінарні дані, що становлять сформований ключ.

### Помилки

Викидається [ValueError](class.valueerror.md), якщо параметр `key`пуст, в параметре`algo` вказано невідомий або криптографічний алгоритм, параметр `length`меньше або дуже великий (більш ніж у 255 разів більше за розмір хеш-функції).

### список змін

| Версия | Опис |
| --- | --- |
| 8.0.0 | Тепер викидається виняток[ValueError](class.valueerror.md) у разі виникнення помилки; раніше видавалася помилка рівня **`E_WARNING`** і поверталося значення **`false`** |

### Приклади

**Пример #1 Пример использования**hash\_hkdf()\*\*\*\*

```php
<?php
// Генерируем случайный ключ и соль для усиления процесса формирования.
$inputKey = random_bytes(32);
$salt = random_bytes(16);

// Формируем пару разных ключей, используя одни и те же входные данные.
$encryptionKey = hash_hkdf('sha256', $inputKey, 32, 'aes-256-encryption', $salt);
$authenticationKey = hash_hkdf('sha256', $inputKey, 32, 'sha-256-authentication', $salt);

var_dump($encryptionKey !== $authenticationKey); // bool(true)
?>
```

У прикладі вище створена пара різних ключів, придатних для створення конструкції encrypt-then-HMAC, використовуючи AES-256 та SHA-256 для кодування та аутентифікації відповідно.

### Дивіться також

-   [hash\_pbkdf2()](function.hash-pbkdf2.md) \- Формування ключа PBKDF2 для заданих вхідних даних
-   [» RFC 5869](http://www.faqs.org/rfcs/rfc5869)
-   [» користувацька реалізація](https://github.com/narfbg/hash_hkdf_compat)
