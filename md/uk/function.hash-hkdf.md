Формування ключа HKDF для заданих вхідних даних

-   [« hashfinal](function.hash-final.html)
    
-   [hashhmacalgos »](function.hash-hmac-algos.html)
    
-   [PHP Manual](index.html)
    
-   [Функции Hash](ref.hash.html)
    
-   Формування ключа HKDF для заданих вхідних даних
    

# hashhkdf

(PHP 7> = 7.1.2, PHP 8)

hashhkdf — Формування ключа HKDF для заданих вхідних даних

### Опис

```methodsynopsis
hash_hkdf(    string $algo,    string $key,    int $length = 0,    string $info = "",    string $salt = ""): string
```

### Список параметрів

`algo`

Ім'я вибраного хешируючого алгоритму (наприклад, "sha256", "sha512", "haval160,4" і т.д.) Список підтримуваних алгоритмів можна переглянути в описі функції [hashalgos()](function.hash-algos.html)

> **Зауваження**
> 
> Не криптографічні функції, що хешують, не допускаються.

`key`

Вхідні дані (необроблені бінарні дані). Не може бути порожнім.

`length`

Вибрана довжина виведення у байтах. Не може бути більш ніж у 255 разів більше розміру обраної функції, що хешує.

Якщо `length` встановлено як `0`, то висновок по довжині дорівнюватиме розміру обраної функції, що хешує.

`info`

Інформаційний рядок, специфічний для застосування/контексту.

`salt`

Сіль, що використовується для формування ключа.

Хоча необов'язково, але додавання випадкової солі значно покращує силу HKDF.

### Значення, що повертаються

Повертає рядок, що містить необроблені бінарні дані, що представляють сформований ключ або **`false`** у разі невдачі.

### Помилки

Помилка рівня **`E_WARNING`** буде згенерована у разі, якщо параметр `key` порожній, у параметрі `algo` вказано невідомий або криптографічний алгоритм, параметр `length` менше `0` або дуже великий (більш ніж у 255 разів більше за розмір хеш-функції).

### Приклади

**Приклад #1 Приклад використання **hashhkdf()****

```php
<?php
// Генерируем случайный ключ и соль для усиления процесса формирования.
$inputKey = random_bytes(32);
$salt = random_bytes(16);

// Формируем пару разных ключей, используя одни и те же входные данные.
$encryptionKey = hash_hkdf('sha256', $inputKey, 32, 'aes-256-encryption', $salt);
$authenticationKey = hash_hkdf('sha256', $inputKey, 32, 'sha-256-authentication', $salt);

var_dump($encryptionKey !== $authenticationKey); // bool(true)
?>
```

У прикладі вище створена пара різних ключів, придатних для створення конструкції encrypt-then-HMAC, використовуючи AES-256 та SHA-256 для кодування та аутентифікації відповідно.

### Дивіться також

-   [hashpbkdf2()](function.hash-pbkdf2.html) - Формування ключа PBKDF2 для заданих вхідних даних
-   [» RFC 5869](http://www.faqs.org/rfcs/rfc5869)
-   [» користувацька реалізація](https://github.com/narfbg/hash_hkdf_compat)