---
navigation:
  - function.array-merge.md: « array\_merge
  - function.array-pad.md: array\_pad »
  - index.md: PHP Manual
  - ref.array.md: Функції для роботи з масивами
title: array\_multisort
origin_hash: ddf652f5224dc9f1fa9671347921941ca401ea50
---
# array\_multisort

(PHP 4, PHP 5, PHP 7, PHP 8)

array\_multisort — Сортує кілька масивів або багатовимірні масиви

### Опис

```methodsynopsis
array_multisort(    array &$array1,    mixed $array1_sort_order = SORT_ASC,    mixed $array1_sort_flags = SORT_REGULAR,    mixed ...$rest): bool
```

функцією **array\_multisort()** користуються для одночасного сортування кількох масивів або одного багатовимірного масиву за одним або декількома рівнями вкладеності.

Асоціативні рядкові ключі будуть збережені, але числові ключі будуть переіндексовані.

> **Зауваження** :
> 
> Якщо обидва порівнювані значення еквівалентні, вони зберігають свій початковий порядок. До PHP 8.0.0 їх відносний порядок у відсортованому масиві не було визначено.

> **Зауваження** :
> 
> Скидає внутрішній покажчик масиву перший елемент.

### Список параметрів

`array1`

Сортується масив (array).

`array1_sort_order`

Порядок, у якому буде відсортовано аргумент-масив (array), заданий перед цим параметром. Дозволено вказувати одну з констант: **`SORT_ASC`** для сортування за зростанням, або **`SORT_DESC`** для сортування за спаданням.

Цей параметр можна змінювати місцями з параметром `array1_sort_flags` або не вказувати, тоді за основу буде взято значення **`SORT_ASC`**

`array1_sort_flags`

Налаштування сортування для аргументу-масиву (array), який був вказаний перед цим параметром:

Прапор способу сортування:

-   \*\*`SORT_REGULAR`\*\*- Звичайне порівняння елементів (без зміни типів)
-   \*\*`SORT_NUMERIC`\*\*- Порівняння елементів як чисел
-   \*\*`SORT_STRING`\*\*- Порівняння елементів як рядків
-   \*\*`SORT_LOCALE_STRING`\*\*- Порівняння елементів як рядків з урахуванням встановленого мовного стандарту (локалі). Буде вибрано мовний стандарт, який дозволено змінювати функцією[setlocale()](function.setlocale.md)
-   \*\*`SORT_NATURAL`\*\*— порівняння елементів як рядків через алгоритм природного сортування (natural order), як у функції[natsort()](function.natsort.md)
-   \*\*`SORT_FLAG_CASE`**\- Можна об'єднувати (бінарним АБО) з**`SORT_STRING`** або **`SORT_NATURAL`\*\*для сортування без урахування регістру

Цей аргумент можна міняти місцями з параметром `array1_sort_order` або не вказувати, тоді за основу буде взято значення **`SORT_REGULAR`**

`rest`

Додаткові масиви, які необов'язково йдуть після порядку сортування та прапорів. Порівнюються лише елементи, які відповідають таким самим елементам у попередніх масивах. Тобто масиви сортуються у лексикографічному порядку.

### Значення, що повертаються

Повертає **`true`** у разі успішного виконання або \*\*`false`\*\*в случае возникновения ошибки.

### Приклади

**Приклад #1 Сортування кількох масивів**

```php
<?php

$ar1 = array(10, 100, 100, 0);
$ar2 = array(1, 3, 2, 4);
array_multisort($ar1, $ar2);

var_dump($ar1);
var_dump($ar2);
?>
```

У наведеному прикладі після закінчення сортування перший масив міститиме значення: 0, 10, 100, 100. Другий — 4, 1, 2, 3. Елементи другого масиву, які відповідають тим самим елементам першого масиву (100 і 100), також будуть відсортовані .

```
array(4) {
  [0]=> int(0)
  [1]=> int(10)
  [2]=> int(100)
  [3]=> int(100)
}
array(4) {
  [0]=> int(4)
  [1]=> int(1)
  [2]=> int(2)
  [3]=> int(3)
}
```

**Приклад #2 Сортування багатовимірного масиву**

```php
<?php

$ar = array(
    array("10", 11, 100, 100, "a"),
    array(1, 2, "2", 3, 1)
);
array_multisort(
    $ar[0], SORT_ASC, SORT_STRING,
    $ar[1], SORT_NUMERIC, SORT_DESC
);
var_dump($ar);
?>
```

У наведеному прикладі після закінчення сортування перший масив міститиме значення: "10", 100, 100, 11, "a" (його елементи були відсортовані у порядку, що зростає), а другий масив - 1, 3, "2", 2, 1 (Елементи відсортовані як числа, у порядку спадання).

```
array(2) {
  [0]=> array(5) {
    [0]=> string(2) "10"
    [1]=> int(100)
    [2]=> int(100)
    [3]=> int(11)
    [4]=> string(1) "a"
  }
  [1]=> array(5) {
    [0]=> int(1)
    [1]=> int(3)
    [2]=> string(1) "2"
    [3]=> int(2)
    [4]=> int(1)
  }
}
```

**Приклад #3 Сортування результатів бази даних**

У цьому вся прикладі кожен елемент масиву data — це рядок таблиці. Такий набір даних є типовим для записів бази даних.

Зразкові дані:

```
# том  | издание
volume | edition
-------+--------
    67 |       2
    86 |       1
    85 |       6
    98 |       2
    86 |       6
    67 |       7
```

Дані як масиву з ім'ям data. Зазвичай їх можна отримати, наприклад, з циклу функції [mysqli\_fetch\_assoc()](mysqli-result.fetch-assoc.md)

```php
<?php

$data[] = array('volume' => 67, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 1);
$data[] = array('volume' => 85, 'edition' => 6);
$data[] = array('volume' => 98, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 6);
$data[] = array('volume' => 67, 'edition' => 7);
?>
```

У цьому прикладі дані будуть відсортовані по полю volume у спадному порядку, а по полю edition - у зростаючому.

Є масив рядків, але функція **array\_multisort()** вимагає масив стовпців, тому спочатку буде викликаний наступний код, щоб отримати стовпці, а потім дані будуть відсортовані.

```php
<?php

// Получение списка столбцов
foreach ($data as $key => $row) {
    $volume[$key]  = $row['volume'];
    $edition[$key] = $row['edition'];
}

// Получение тех же данных функцией array_column() вместо перебора
$volume  = array_column($data, 'volume');
$edition = array_column($data, 'edition');

// Сортируем данные по полю volume по убыванию и по полю edition по возрастанию
// Добавляем переменную $data в качестве последнего параметра, для сортировки по общему ключу
array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);
?>
```

Тепер дані відсортовані і виглядатимуть так:

```
volume | edition
-------+--------
    98 |       2
    86 |       1
    86 |       6
    85 |       6
    67 |       2
    67 |       7
```

**Приклад #4 Сортування без урахування регістру**

Обидві константи **`SORT_STRING`** і **`SORT_REGULAR`** враховують регістр при сортуванні, рядки, що починаються з великої літери, будуть виставлені раніше рядків, що починаються з малої літери.

Для реєстронезалежного сортування, потрібно працювати з копією вихідного масиву, приведеного до нижнього регістру.

```php
<?php

$array = array('Alpha', 'atomic', 'Beta', 'bank');
$array_lowercase = array_map('strtolower', $array);

array_multisort($array_lowercase, SORT_ASC, SORT_STRING, $array);

print_r($array);
?>
```

Результат виконання наведеного прикладу:

```
Array
(
    [0] => Alpha
    [1] => atomic
    [2] => bank
    [3] => Beta
)
```

### Дивіться також

-   [usort()](function.usort.md) \- Сортує масив за значеннями використовуючи функцію користувача для порівняння елементів
-   [Порівняння функцій сортування масивів](array.sorting.md)
